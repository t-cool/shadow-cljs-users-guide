////
`shadow-cljs.edn` will also need a `:builds` section. Builds should be a map of builds keyed by build ID:
////
`shadow-cljs.edn` には、 `:builds` セクションも必要です。ビルドは、ビルド ID をキーにしたビルドのマップでなければなりません。

////
.A configuration file with a build map.
////

.ビルドマップの設定ファイル

```
{:dependencies [[some-library "1.2.1"] ...]
 :source-paths ["src"]
 :builds
 {:app   {:target     :browser
          ... browser-specific options ...}
  :tests {:target :karma
          ... karma-specific options ...}}}
```

////
Each build describes artifacts that the compiler will build. The build target is an extensible feature of `shadow-cljs`, and the compiler comes with quite a few of them already.
////
各ビルドには、コンパイラがビルドする成果物が記述されています。ビルドターゲットは `shadow-cljs` の拡張可能な機能であり、コンパイラにはすでにかなりの数が付属しています。

== ビルドターゲット

//Build Target

////
Each build in `shadow-cljs` must define a `:target` which defines where you intend your code to be executed. There are default built-ins for the <<target-browser,browser>> and <<target-node,`node.js`>>. They all share the basic concept of having `:dev` and `:release` modes. `:dev` mode provides all the usual development goodies like fast compilation, live code reloading and a REPL. `:release` mode will produce optimized output intended for production.
////
`shadow-cljs` の各ビルドでは、コードをどこで実行するかを定義する `:target` を定義する必要があります。<<target-browser,browser>> と <<target-node,`node.js`>> のデフォルトのビルドインがあります。これらはすべて、 `:dev` モードと `:release` モードを持つという基本的なコンセプトを共有しています。 `dev` モードでは、高速なコンパイル、ライブコードリロード、REPL など、通常の開発に必要な機能をすべて提供します。 `release` モードでは、プロダクション向けに最適化された出力が得られます。

////
Targets are covered in separate chapters.
////
ターゲットについては別の章で説明します。

////
Here are some of them:
////
ここでは一部をご紹介します。

////
[Horizontal]
<<target-browser, `:browser`>>:: Output code suitable for running in a web browser.
<<target-bootstrap, `:bootstrap`>>:: Output code suitable for running in bootstrapped cljs environment.
<<target-browser-test, `:browser-test`>>:: Scan for tests to determine required files, and output tests suitable for running in the browser.
<<target-karma, `:karma`>>:: Scan for tests to determine required files, and output karma-runner compatible tests. See http://karma-runner.github.io/2.0/index.html[Karma].
<<target-node-library, `:node-library`>>:: Output code suitable for use as a node library.
<<target-node-script, `:node-script`>>:: Output code suitable for use as a node script.
<<target-npm-module, `:npm-module`>>:: Output code suitable for use as an NPM module.
////
[Horizontal]
<<target-browser, `:browser`>>:: Web ブラウザでの実行に適したコードを出力します。
<<target-bootstrap, `:bootstrap`>>::ブートストラップされた cljs 環境で実行するのに適したコードを出力します。
<<target-browser-test, `:browser-test`>>:: テストをスキャンして必要なファイルを決定し、ブラウザで実行するのに適したテストを出力します。
<<target-karma, `:karma`>>:: テストをスキャンして必要なファイルを決定し、karma-runner互換のテストを出力します。 http://karma-runner.github.io/2.0/index.html[Karma] を参照してください。
<<target-node-library, `:node-library`>>:: ノードライブラリとして使用するのに適したコードを出力します。
<<target-node-script, `:node-script`>>:: ノードスクリプトとして使用するのに適したコードを出力します。
<<target-npm-module, `:npm-module`>>:: ノードスクリプトとしての使用に適したコードを出力します。 npm モジュールとして使用するのに適したコードを出力します。


////
Each target is covered in more detail in its own chapter since the remaining build options vary on
the target you select.
////
ターゲットを選択すると残りのビルドオプションが変わるため、ターゲットについては各々の章で詳しく説明します。

== 開発オプション [[devtools]]

//Development Options [[devtools]]

////
Each build `:target` typically provides some development support. They are grouped under the `:devtools` key for each `:build`.
////
通常、各ビルド `:target` は複数の開発サポートを提供します。それらは各 `:build` の `:devtools` キーの下にまとめられています。

=== REPL

////
When running `watch` code for the REPL is injected automatically and usually does not require additional configuration. Additional options are available to control REPL behavior:
////
`watch` を実行すると、REPL用のコードが自動的に注入され、通常は追加の設定は必要ありません。 REPL の動作を制御するための追加オプションも用意されています。

////
- `:repl-init-ns` allows configuring which namespace the REPL will start in. It defaults to `cljs.user`.
- `:repl-pprint` makes the REPL use `cljs.pprint` instead of the regular `pr-str` when printing eval results. Defaults to false.
////
- `:repl-init-ns` では、REPL をどの名前空間で起動するかを設定することができます。デフォルトでは `cljs.user` となります。
- `repl-pprint` では、REPL が eval の結果を print するときに、通常の `pr-str` の代わりに `cljs.pprint` を使用します。デフォルトは false です。

```
{...
 :builds
 {:app {...
        :devtools {:repl-init-ns my.app
                   :repl-pprint true
                   ...}}}}
```


=== プリロード

//Preloads

////
As a developer most of your time is spent in development mode. You're probably familiar with tools like `figwheel`,
`boot-reload`, and `devtools`. It's almost certain that you want one or more of these in your builds.
////
開発者は、そのほとんどの時間を開発モードで過ごします。おそらく、 `figwheel`、 `boot-reload`、 `devtools` などのツールに精通していることでしょう。
`boot-reload`、 `devtools` などのツールをご存知でしょう。これらのツールの 1 つ以上を自分のビルドに使用することはほぼ確実でしょう。

////
Preloads are used to force certain namespaces into the front of your generated Javascript. This is generally used to inject tools and instrumentation before the application actually loads and runs. The preloads option is simply a list of namespaces either in the `:devtools`/`:preloads` section of `shadow-cljs.edn` or within the `:preloads` key of a specific module:
////
プリロードは、生成された Javascript の先頭に特定の名前空間を強制的に導入するために使用されます。これは一般的に、アプリケーションが実際にロードされて実行される前に、ツールやインスツルメンテーションを注入するために使用されます。preloads オプションは、 `shadow-cljs.edn` の `:devtools` / `:preloads` セクション内、または特定のモジュールの `:preloads` キー内にある名前空間の単純なリストです。

```
{...
 :builds
 {:app {...
        :devtools {:preloads [fulcro.inspect.preload]
                   ...}}}}

```

////
For example to only include the preloads within a main module during development, and not in a web worker:
////
例えば、開発中のメインモジュール内でのみプリロードを行い、ウェブワーカーでは行わないようにするなどです。

```
{...
 :builds
 {:app {...
        :modules {:main {...
                         :preloads
                         [com.fulcrologic.fulcro.inspect.preload
                          com.fulcrologic.fulcro.inspect.dom-picker-preload]
                         :depends-on #{:shared}}
                  :shared {:entries []}
                  :web-worker {...
                    :depends-on #{:shared}
                    :web-worker true}}}}}
```

////
`:preloads` are only applied to development builds and will not be applied to release builds.
////
`:preloads` は開発用ビルドにのみ適用され、リリース用ビルドには適用されません。

////
NOTE: Since version 2.0.130 shadow-cljs automatically adds `cljs-devtools` to the preloads in `watch` and `compile` if they are on the classpath. All you need to do is make sure `binaryage/devtools` is in your `dependencies` list. (Note, *not* binaryage/**cljs-**devtools.) If you don't want to have `cljs-devtools` in specific targets, you can suppress this by adding `:console-support false` to the `:devtools` section of those targets.
////
注意: バージョン 2.0.130 以降の shadow-cljs は、 `watch` と `compile` のクラスパス上に `cljs-devtools` がある場合、自動的にそのプリロードに `cljs-devtools` を追加します。必要なことは、 `binaryage/devtools` があなたの `dependencies` リストにあることを確認するだけです。(注意: binaryage/cljs-devtools ではない) もし、特定のターゲットに `cljs-devtools` を入れたくない場合は、それらのターゲットの `:devtools` セクションに `:console-support false` を追加することで、これを抑制することができます。

=== ホットコードリロード
//Hot Code Reload

////
The React and ClojureScript ecosystems combine to make this kind of thing super useful. The `shadow-cljs`
system includes everything you need to do your hot code reload, without needing to resort to external tools.
////
React と ClojureScript のエコシステムを組み合わせることで、このようなことが超便利になります。 `shadow-cljs` のシステムには、外部ツールに頼ることなく、ホットコードリロードを行うために必要なものがすべて含まれています。

////
In order to use it you simply run:
////
使うには、以下のように実行するだけです。

```
shadow-cljs watch build-id
```

=== ライフサイクルフック

//Lifecycle Hooks

////
You can configure the compiler to run functions just before hot code reload brings in updated code, and just after. These are useful for stopping/starting things that would otherwise close over old code.
////
ホットコードリロードで更新されたコードが入ってくる直前と直後に関数を実行するようにコンパイラを設定することができます。これは、古いコードの上で閉じてしまうような処理を停止/開始するのに便利です。

////
These can be configured via the `:devtools` section in your build config or directly in your code via metadata tags.
////
これらの設定は、ビルド設定の `:devtools` セクションを介して、またはメタデータタグを介してコード内で直接行うことができます。


==== メタデータ
//Metadata

////
You can set certain metadata on normal CLJS `defn` vars to inform the compiler that these functions should be called at a certain time when live reloading.
////
通常の CLJS の `defn` 変数に特定のメタデータを設定することで、ライブリロード時にこれらの関数が特定のタイミングで呼び出されるべきであることをコンパイラに知らせることができます。


////
.hook config via metadata
////
.メタデータを利用した hook の設定

```clojure
(ns my.app)

(defn ^:dev/before-load stop []
  (js/console.log "stop"))

(defn ^:dev/after-load start []
  (js/console.log "start"))
```

////
This would call `my.app/stop` before loading any new code and `my.app/start` when all new code was loaded. You can tag multiple functions like this and they will be called in dependency order of their namespaces.
////
これは、新しいコードを読み込む前に `my.app/stop` を呼び出し、新しいコードがすべて読み込まれたときに `my.app/start` を呼び出します。このように複数の関数をタグ付けすることができ、それらは名前空間の依存関係の順に呼び出されます。

////
There are also async variants of these in case you need to do some async work that should complete before proceeding with the reload process.
////
また、リロード処理を行う前に完了すべき非同期処理を行う必要がある場合は、これらの非同期版もあります。


////
.async hooks example
////
.async フックの例

```clojure
(ns my.app)

(defn ^:dev/before-load-async stop [done]
  (js/console.log "stop")
  (js/setTimeout
    (fn []
      (js/console.log "stop complete")
      (done)))

(defn ^:dev/after-load-async start [done]
  (js/console.log "start")
  (js/setTimeout
    (fn []
      (js/console.log "start complete")
      (done)))
```

////
IMPORTANT: The functions will receive one callback function that must be called when their work is completed. If the callback function is not called the reload process will not proceed.
////
IMPORTANT: 各関数には、それぞれの作業が完了したときに呼び出されるべきコールバック関数が 1 つあります。このコールバック関数が呼び出されないと、リロード処理は進みません。


////
It is possible to tag namespaces with metadata so they will never be reloaded even if they are recompiled.
////
名前空間にメタデータをタグ付けすることで、再コンパイルされても再読み込みされないようにすることが可能です。

////
.A non-reloadable ns
////

```
(ns ^:dev/once my.thing)

(js/console.warn "will only execute once")
```

////
Namespaces can also be tagged to always reload.
////
名前空間は常にリロードするようにタグ付けすることもできます。

////
.An always-reloadable ns
////

```
(ns ^:dev/always my.thing)

(js/console.warn "will execute on every code change")
```


==== 設定
//Config

////
In addition to the metadata you can configure the lifecycle hooks via `shadow-cljs.edn`.
////
メタデータに加えて、ライフサイクルフックを `shadow-cljs.edn` で設定することができます。

////
[Horizontal]
`:before-load` :: A symbol (with namespace) of a function to run just before refreshing
files that have been recompiled.  This function *must* be synchronous in nature.
`:before-load-async` :: A symbol (with namespace) of a function `(fn [done])` to run just before refreshing. This function can do async processing, but *must* call `(done)` to indicate it is complete.
`:after-load` :: A symbol (with namespace) of a function to run after hot code reload is complete.
`:after-load-async` :: A symbol (with namespace) of a function `(fn [done])` to run after hot code reload is complete. This function can do async processing, but *must* call `(done)` to indicate it is complete.
`:autoload` :: A boolean controlling whether code should be hot loaded. Implicitly set to `true` if either of the callbacks is set. Always enabled for the `:browser` target by default, set to `false` to disable.
`:ignore-warnings` :: A boolean controlling whether code with warnings should be reloaded. Defaults to `false`.
////
[Horizontal]
`:before-load` :: 再コンパイルされたファイルを更新する直前に実行される関数のシンボル（名前空間付き）です。
関数のシンボル（名前空間付き）です。 この関数は本質的に同期的でなければなりません。
`:before-load-async` :: リフレッシュする直前に実行する関数 `(fn [done])` のシンボル（名前空間付き）です。この関数は非同期処理を行うことができますが、処理が完了したことを示すために、 `(done)` を必ず*呼び出さなければなりません。
`:after-load` :: ホットコードのリロードが完了した後に実行する関数のシンボル(名前空間付き)です。
`:after-load-async` :: ホットコードのリロードが完了した後に実行される関数 `(fn [done])` のシンボル(名前空間を含む)です。この関数は非同期処理を行うことができますが、完了したことを示すために、 `(done)` を必ず呼び出さなければなりません。
`:autoload` :: コードをホットロードするかどうかを制御するブール値です。いずれかのコールバックが設定されると、暗黙的に `true` に設定されます。デフォルトでは `:browser` ターゲットに対して常に有効で、無効にするには `false` を設定します。
`:deignore-warnings` :: 警告を含むコードをリロードするかどうかを制御するブール値です。デフォルトでは `false` に設定されます。

////
.A sample of lifecycle hooks.
////
.ライフサイクルフックの例

```
{...
 :builds
 {:app {...
        :devtools {:before-load  my.app/stop
                   :after-load   my.app/start
                   ...}}}}
```

////
IMPORTANT: Hooks cannot be declared in the `cljs.user` namespace. Hooks are only used if the namespace containing them is actually included in the build. If you use an extra namespace make sure to include it via `:preloads`.
////
IMPORTANT: フックは `cljs.user` 名前空間では宣言できません。フックは、それを含む名前空間が実際にビルドに含まれている場合にのみ使用されます。追加の名前空間を使用する場合は、必ず `:preloads` でインクルードしてください。

////
TIP: If neither `:after-load` nor `:before-load` are set the compiler will only attempt to hot reload the code in the `:browser` target. If you still want hot reloading but don't need any of the callbacks you can set `:autoload true` instead.
////
TIP: `:after-load` や `:before-load` が設定されていない場合、コンパイラは `:browser` ターゲットのコードのホットリロードのみを試みます。もし、ホットリロードを行いたいが、コールバックが不要な場合は、代わりに `:autoload true` を設定してください。

== ビルドフック [[build-hooks]]
//Build Hooks [[build-hooks]]

////
It is sometimes desirable to execute some custom code at a specific stage in the compilation pipeline. `:build-hooks` let you declare which functions should be called and they have full access to the build state at that time. This is quite powerful and opens up many possible tool options.
////
カスタムコードをコンパイルパイプラインの特定の段階で実行したい場合があります。`:build-hooks` では、どの関数を呼び出すかを宣言することができ、その関数はその時点でのビルド状態に完全にアクセスすることができます。これは非常に強力で、様々なツールのオプションが可能になります。


////
They are configured per build under the `:build-hooks` key
////
ビルドごとに `:build-hooks` キーで設定されます。

////
.Exampe :build-hooks
////
.Example :build-hooks

```clojure
{...
 :builds
 {:app {:target ...
        :build-hooks
        [(my.util/hook 1 2 3)]
        ...}}}}
```

////
.Example hook code
////
.Example hook code

```clojure
(ns my.util)

(defn hook
  {:shadow.build/stage :flush}
  [build-state & args]
  (prn [:hello-world args])
  build-state)
```

////
This example would call `(my.util/hook build-state 1 2 3)` after the build completed the `:flush` <<compilation-stages, stage>> (ie. written to disk). The example would print `[:hello-world (1 2 3)]` but please do something more useful in actual hooks.
////
この例では、ビルドが `:flush` <<compilation-stages, stage>> を完了した(つまりディスクに書き込まれた)後に `(my.util/hook build-state 1 2 3)` を呼び出します。この例では `[:hello-world (1 2 3)]` と表示されますが、実際のフックではもっと便利なことをしてください。

////
The hook is a just a normal *Clojure* function with some additional metadata. The `{:shadow.build/stage :flush}` metadata informs the compiler to call this hook for `:flush` only. You may instead configure `{:shadow.build/stages #{:configure :flush}}` if the hook should be called after multiple stages. At least one configured stage is required since the hook otherwise would never do anything.
////
フックは通常の *Clojure* 関数にいくつかのメタデータを追加したものです。 `shadow.build/stage :flush}` メタデータは、このフックを `:flush` でのみ呼び出すようにコンパイラに通知します。フックが複数のステージの後に呼び出されるべきであれば、代わりに `{:shadow.build/stages #{:configure :flush}}` を設定することができます。そうしないとフックは何もしないので、少なくともひとつの設定済みステージが必要です。

////
All build hooks will be called after the `:target` work is done. They will receive the `build-state` (a clojure map with all the current build data) as their first argument and *must* return this `build-state` modified or unmodified. When using multiple stages you can add additional data to the `build-state` that later stages can see. It is strongly advised to use namespaced keys only to ensure not accidentally breaking the entire build.
////
すべてのビルドフックは、 `:target` の作業が終わった後に呼び出されます。これらのフックは、最初の引数として `build-state` (現在のすべてのビルドデータを含む clojure マップ) を受け取り、 *必ず* この `build-state` を修正して、または修正しないで返します。複数のステージを使用する場合、後のステージが見ることができる追加データを `build-state` に追加することができます。誤ってビルド全体を壊してしまわないように、名前付きのキーのみを使用することを強くお勧めします。

////
The `build-state` has some important entries which might be useful for your hooks:
////
`build-state` には、フックに有用ないくつかの重要なエントリがあります。

////
- `:shadow.build/build-id` - the id of the current build (eg. `:app`)
- `:shadow.build/mode` - `:dev` or `:release`
- `:shadow.build/stage` - the current stage
- `:shadow.build/config` - the build config. You can either store config data for the hook in the build config directly or pass it as arguments in the hook itself
////
- `:shadow.build/build-id` - 現在のビルドの ID（例：`:app`）。
- `:shadow.build/mode` - `:dev` または `:release` です。
- `:shadow.build/stage` - 現在のステージです。
- `:shadow.build/config` - ビルドの設定。フック用の設定データは、ビルドコンフィグに直接格納するか、フック自体の引数として渡すことができます。

////
IMPORTANT: With a running `watch` all hooks will be called repeatedly for each build. Avoid doing too much work as they can considerably impact your build performance.
////
IMPORTANT: `watch` を実行していると、すべてのフックがビルドのたびに繰り返し呼び出されます。ビルドのパフォーマンスに大きな影響を与える可能性がありますので、あまり多くの作業を行わないようにしてください。

=== コンパイル・ステージ [[compile-stages]]
//Compilation Stages [[compile-stages]]

////
The possible stages the `:build-hooks` can use are:
////
`:build-hooks` が使用できるステージは以下の通りです。

////
- `:configure` - initial `:target` specific configuration
- `:compile-prepare` - called before any compilation is done
- `:compile-finish` - called after all compilation finishes
- `:optimize-prepare` - called before running the Closure Compiler optimization phase (`:release` only)
- `:optimize-finish` - called after Closure is done (`:release` only)
- `:flush` - called after everything was flushed to disk
////
- `:configure` - 初期の `:target` 特定の設定
- `:compile-prepare` - コンパイルが行われる前に呼び出されます。
- `:compile-finish` - すべてのコンパイルが終了した後に呼び出されます。
- `optimize-prepare` - Closure Compiler の最適化フェーズを実行する前に呼び出されます (`:release` のみ)
- `:optime-finish` - Closure が終了した後に呼び出されます (`:release` のみ)
- `:flush` - すべてがディスクにフラッシュされた後に呼び出されます。

////
With a running `watch` the `:configure` is only called once. Any of the others may be called
again (in order) for each re-compile. The `build-state` will be re-used until the build config changes at which point it will be thrown away and a fresh one will be created.
////
watch を実行していると、:configure は一度しか呼ばれません。再コンパイルのたびに、他の項目が
再コンパイルのたびに（順番に）呼び出されます。`build-state` はビルドコンフィグが変更されるまで再利用され、その時点で破棄されて新しいものが作成されることになる。

== コンパイラ・キャッシュ
//Compiler Cache

////
`shadow-cljs` will cache all compilation results by default. The cache is invalidated whenever anything relevant to the individual source files changes (eg. changed compiler setting, changed dependencies, etc.). This greatly improves the developer experience since incremental compilation will be **much** faster than starting from scratch.
////
`shadow-cljs` はデフォルトで全てのコンパイル結果をキャッシュします。このキャッシュは、個々のソースファイルに関連する何かが変更されるたびに無効になります（例：コンパイラの設定変更、依存関係の変更など）。これにより、インクリメンタルなコンパイルはスクラッチから始めるよりも **はるかに** 早くなるので、開発者の経験が大幅に改善されます。

////
Invalidating the cache however can not always be done reliably if you are using a lot of macros with side-effects (reading files, storing things outside the compiler state, etc.). In those cases you might need to disable caching entirely.
////
しかし、キャッシュを無効にすることは、副作用のあるマクロ（ファイルの読み込み、コンパイラの状態外での保存など）を多く使用している場合、常に確実に実行できるとは限りません。そのような場合には、キャッシュを完全に無効にする必要があります。

////
Namespaces that are known to include side-effecting macros can be blocked from caching. They won't be cached themselves and namespaces requiring them will not be cached as well. The https://github.com/cerner/clara-rules[clara-rules] library has side-effecting macros and is blocked by default. You can specify which namespaces to block globally via the `:cache-blockers` configuration. It expects a set of namespace symbols.
////
副作用のあるマクロが含まれていることがわかっている名前空間は、キャッシュからブロックすることができます。その名前空間自体はキャッシュされず、それを必要とする名前空間もキャッシュされません。 https://github.com/cerner/clara-rules[clara-rules] ライブラリには副作用のあるマクロが含まれており、デフォルトでブロックされます。どの名前空間をグローバルにブロックするかは、 `:cache-blockers` 設定で指定できます。この設定には、名前空間のシンボルのセットが必要です。

////
.clara.rules cache blocking example (this is done by default)
////
.clara.rules のキャッシュブロックの例（これはデフォルトで行われます)

```
{...
 :cache-blockers #{clara.rules}
 :builds {...}}
```

////
In addition you can control how much caching is done more broadly via the `:build-options` `:cache-level` entry. The supported options are:
////
さらに、 `:build-options` `:cache-level` エントリーを使って、どの程度のキャッシングが行われるかをより広範囲に渡ってコントロールすることができます。サポートされているオプションは次のとおりです。

////
[horizontal]
`:all` :: The default, all CLJS files are cached
`:jars` :: Only caches files from libraries, ie. source files in `.jar` files
`:off` :: Does not cache any CLJS compilation results (by far the slowest option)
////
[horizontal]
`:all` :: デフォルトでは、すべての CLJS ファイルがキャッシュされます。
`:jars` :: ライブラリからのファイル、つまり `.jar` ファイル内のソースファイルのみをキャッシュします。
`:off` :: CLJS のコンパイル結果を一切キャッシュしません（圧倒的に遅いオプションです）。

////
.Compiling without Cache
////
.キャッシュを使わずにコンパイルする


```
{...
 :builds
 {:app
  {:target :browser
   ...
   :build-options
   {:cache-level :off}}}}
```

////
The cache files are stored in a dedicated directory for each build so the cache is never shared between builds. A build with the id `:app` will have the `:dev` cache in the directory:
////
キャッシュファイルは、ビルドごとに専用のディレクトリに保存されるので、ビルド間でキャッシュが共有されることはありません。 id が `:app` のビルドには、 `:dev` のキャッシュがディレクトリに格納されます。

////
.Cache location for `cljs/core.cljs`
////
.cljs/core.cljs のキャッシュ場所

```
target/shadow-cljs/builds/app/dev/ana/cljs/core.cljs.cache.transit.json
```

////
The `:cache-root` setting defaults to `target/shadow-cljs` and controls where ALL cache files will be written. It can only be configured globally, not per build.
////
`:cache-root` の設定は、デフォルトでは `target/shadow-cljs` となり、すべてのキャッシュファイルがどこに書き込まれるかを制御します。これはグローバルにのみ設定可能で、ビルドごとに設定することはできません。

////
```
{:source-paths [...]
 :dependencies [...]
 :cache-root ".shadow-cljs"
 :builds ...}

;; cache then goes to
;; .shadow-cljs/builds/app/dev/ana/cljs/core.cljs.cache.transit.json
```
////

```
{:source-paths [...]
 :dependencies [...]
 :cache-root ".shadow-cljs"
 :builds ...}

;; キャッシュは、.shadow-cljs/builds/app/dev/ana/cljs/core.cljs.cache.transit.json になります。
```



////
The `:cache-root` is always resolved relative to the project directory. You can also specify absolute paths (eg. `/tmp/shadow-cljs`).
////
また、 `:cache-root` は常にプロジェクトディレクトリからの相対パスで指定します。絶対パスを指定することもできます (例: `/tmp/shadow-cljs`)。

== Closure の定義 [[closure-defines]]
//Closure Defines [[closure-defines]]

////
The Closure Library & Compiler allow you to define variables that are essentially compile time constants. You can use these to configure certain features of your build. Since the Closure compiler treats these as constants when running `:advanced` optimizations they are fully supported in the Dead-Code-Elimination passes and can be used to remove certain parts of the code that should not be included in `release` builds.
////
Closure Library と Compiler では、基本的にコンパイル時の定数である変数を定義することができます。これを使って、ビルドの特定の機能を設定することができます。 Closure コンパイラは、 `:advanced` 最適化を実行する際にこれらを定数として扱うため、Dead-Code-Elimination パスが完全にサポートされており、 `release` ビルドに含めるべきではないコードの特定の部分を削除するために使用することができます。

////
You can define them in your code
////
コードの中で定義することができます。

```clojure
(ns your.app)

(goog-define VERBOSE false)

(when VERBOSE
  (println "Hello World"))
```

////
This defines the `your.app/VERBOSE` variable as `false` by default. This will cause the `println` to be removed in `:advanced` compilation. You can toggle this to `true` via the `:closure-defines` options which will enable the `println`. This can either be done for development only or always.
////
これにより、 `your.app/VERBOSE` 変数がデフォルトで `false` と定義されます。これにより、 `:advanced` のコンパイル時に `println` が削除されます。これを `:closure-defines` オプションで `true` に変更すると、 `println` が有効になります。これは、開発時のみ、または常に行うことができます。

////
```clojure
{...
 :builds
 {:app
  {:target :browser
   ...
   :modules {:app {:entries [your.app]}}
   ;; to enable in development only
   :dev {:closure-defines {your.app/VERBOSE true}}
   ;; to enable always
   :closure-defines {your.app/VERBOSE true}
   ;; you may also enable it for release as well
   :release {:closure-defines {your.app/VERBOSE true}}
   }}
```
////

```clojure
{...
 :builds
 {:app
  {:target :browser
   ...
   :modules {:app {:entries [your.app]}}
   ;; 開発時のみ有効
   :dev {:closure-defines {your.app/VERBOSE true}}
   ;; 常に有効にする
   :closure-defines {your.app/VERBOSE true}
   ;; リリース時の有効化も可能
   :release {:closure-defines {your.app/VERBOSE true}}
   }}
```

////
TIP: It is generally safer to use the "disabled" variant as the default since it makes things less likely to be included in a `release` build when they shouldn't be. Forgetting to set a `:closure-defines` variable should almost always result in less code being used not more.
////
TIP: 一般的には、disabled バリアントをデフォルトで使用する方が安全です。なぜなら、release ビルドに含まれるべきでないものが含まれる可能性が低くなるからです。また、 `:closure-defines` 変数の設定を忘れると、ほとんどの場合、使用されるコードが増えるのではなく、減ることになります。

////
Closure Defines from the Closure Library
////
Closure Library の Closure 定義

////
- `goog.DEBUG`: The Closure Library uses this for many development features. `shadow-cljs` automatically sets this to `false` for `release` builds.
- `goog.LOCALE` can be used to configure certain localization features like `goog.i18n.DateTimeFormat`. It accepts a standard locale string and defaults to `en`. Pretty much all locales are supported, see https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbols.js[here] and https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbolsext.js[here] .
////
- `goog.DEBUG` です。Closure Library では、多くの開発機能でこれを使用しています。 `shadow-cljs` は、 `release` のビルドでは、自動的にこれを `false` に設定します。
- `goog.LOCALE` : `goog.i18n.DateTimeFormat` のような、ある種のローカリゼーション機能を設定するために使用されます。これは標準的なロケール文字列を受け入れ、デフォルトでは `en` となります。ほとんどすべてのロケールがサポートされています。 https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbols.js[こちら] と https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbolsext.js[こちら] を参照してください。

== コンパイラのオプション [[compiler-options]]
//Compiler Options [[compiler-options]]

////
The CLJS compiler supports several options to influence how some code is generated. For the most part `shadow-cljs` will pick some good defaults for each `:target` but you might occasionally want to change some of them.
////
CLJS コンパイラは、コードの生成方法に影響を与えるいくつかのオプションをサポートしています。ほとんどの場合、 `shadow-cljs` は各 `:target` に対して良いデフォルトを選んでくれますが、時折それらのいくつかを変更したいと思うかもしれません。

////
These are all grouped under the `:compiler-options` key in your build config.
////
これらはすべて、ビルド設定の `:compiler-options` キーにまとめられています。

```clojure
{:dependencies [...]
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:fn-invoke-direct true}}}}
```

////
Most of the standard ClojureScript https://clojurescript.org/reference/compiler-options[Compiler Options] are either enabled by default or do not apply. So very few of them actually have an effect. A lot of them are also specific to certain `:target` types and do not apply universally (e.g. `:compiler-options {:output-wrapper true}` is only relevant for `:target :browser`).
////
標準的な ClojureScript https://clojurescript.org/reference/compiler-options[Compiler Options]のほとんどは、デフォルトで有効になっているか、適用されていません。そのため、実際に効果があるものはほとんどありません。また、多くのオプションは特定の `:target` タイプに固有のもので、普遍的に適用されるわけではありません (例えば、 `:compiler-options {:output-wrapper true}` は `:target :browser` にのみ関係します)。

////
Currently supported options include
////
現在サポートされているオプションは以下の通りです。

////
- `:optimizations` supports `:advanced`, `:simple` or `:whitespace`, defaults to `:advanced`. `:none` is the default for development and cannot be set manually. `release` with `:none` won't work.
- `:infer-externs` `:all`, `:auto`, `true` or `false`, defaults to `true`
- `:static-fns` (Boolean) defaults to `true`
- `:fn-invoke-direct` (Boolean) defaults to `false`
- `:elide-asserts` (Boolean) default to `false` in development and `true` in `release` builds
- `:pretty-print` and `:pseudo-names` default to `false`. You can use `shadow-cljs release app --debug` to enable both temporarily without touching your config. This is very useful when running into problem with `release` builds
- `:source-map` (Boolean) defaults to `true` during development, `false` for `release`.
- `:source-map-include-sources-content` (Boolean) defaults to `true` and decides whether source maps should contains their sources in the `.map` files directly.
- `:source-map-detail-level` `:all` or `:symbols` (`:symbols` reduces overall size a bit but also a bit less accurate)
- `:externs` vector of paths, defaults to `[]`
- `:checked-arrays` (Boolean), defaults to `false`
- `:anon-fn-naming-policy`
- `:rename-prefix` and `:rename-prefix-namespace`
- `:warnings` as a map of `{warning-type true|false}`, eg. `:warnings {:undeclared-var false}` to turn off specific warnings.
////
- `:optimizations` は `:advanced`, `:simple`, `:whitespace` のいずれかをサポートしていますが、デフォルトは `:advanced` です。 `none` は開発時のデフォルトで、手動で設定することはできません。 `none` を指定した `release` は動作しません。
- `:infer-externs` `:all`, `:auto`, `true` または `false`, デフォルトは `true` です。
- `:static-fns` (ブール値) デフォルトでは `true` です。
- `:fn-invoke-direct` (Boolean) デフォルトは `false` です。
- `:ide-asserts` (Boolean) のデフォルトは、開発版では `false` 、 `release` ビルドでは `true` です。
- `:pretty-print` と `:pseudo-names` はデフォルトで `false` になります。 `shadow-cljs release app --debug` を使用すると、設定に手を加えることなく、一時的に両方を有効にすることができます。これは `release` のビルドで問題が発生したときにとても便利です。
- `:source-map` (Boolean) 開発中のデフォルトは `true` で、 `release` では `false` です。
- `:source-map-include-sources-content` (Boolean) デフォルトは `true` で、ソースマップが `.map` ファイルに直接ソースを含めるかどうかを決定します。
- `:source-map-detail-level` `:all` または `:symbols` (`:symbols` は全体のサイズを少し小さくしますが、精度も少し低くなります)
- `:externs` パスのベクトル、デフォルトでは `[]` です。
- `:checked-arrays` (Boolean), デフォルトは `false` です。
- `:anon-fn-naming-policy` (論理値)
- `:rename-prefix` と `:rename-prefix-namespace` の対応表です。
- 例えば、 `:warnings {:undeclared-var false}` とすると、特定の警告を消すことができます。


////
Unsupported or non-applicable Options
////
サポートされていない、または適用されていないオプション、

////
Options that don't have any effect at all include
////
全く効果がない選択肢は、以下の通りです。

////
- `:verbose` is controlled by running `shadow-cljs compile app --verbose` not in the build config.
- `:foreign-libs` and `:libs`
- `:stable-names` always enabled, cannot be disabled
- `:install-deps`
- `:source-map-path`, `:source-asset-path` and `:source-map-timestamp`
- `:cache-analysis` always enabled, cannot be disabled.
- `:recompile-dependents`
- `:preamble`
- `:hashbang` (the `:node-script` target supports this, others don't)
- `:compiler-stats` use `--verbose` to get detailed information instead
- `:optimize-constants` always done for `release` builds, cannot be disabled
- `:parallel-build` always enabled
- `:aot-cache`
- `:package-json-resolution` see <<js-resolve, :js-options :resolve>> instead
- `:watch-fn`
- `:process-shim`
////
- `:verbose` は、 `shadow-cljs compile app --verbose` を実行することで制御されますが、ビルド設定にはありません。
- `:foreign-libs` と `:libs` です。
- `:stable-names` は常に有効で、無効にすることはできません。
- `:install-deps` (インストールディプス)
- `:source-map-path`, `:source-asset-path`, `:source-map-timestamp` です。
- `:cache-analysis` 常に有効で、無効にすることはできません。
- `:recompile-dependents` (リコンパイル依存)
- `:preamble` (前置き)
- `:hashbang` (`:node-script` ターゲットはこれをサポートしていますが、他のターゲットはサポートしていません)
- `:compiler-stats` 詳細な情報を得るには、代わりに `--verbose` を使用してください。
- `:optimize-constants` は `release` のビルドでは常に行われ、無効にはできません。
- `:parallel-build` は常に有効です。
- `:aot-cache` (キャッシュ)
- `:package-json-resolution` 代わりに <<js-resolve, :js-options :resolve>> を参照してください。
- `:watch-fn`
- `:process-shim` (プロセスシム)

=== エラーとしてのワーニング [[warnigs-as-errors]]
//Warnings as Errors [[warnigs-as-errors]]

////
It is sometimes desireable to fail a build with warnings rather than continuing with the build (eg. in CI envs). You can use the `:warnings-as-errors` compiler options to customize how that is handled.
////
ビルドを続行するのではなく、警告を表示してビルドを失敗させたい場合があります（例：CI環境など）。 `warnings-as-errors` コンパイラオプションを使って、その処理方法をカスタマイズすることができます。

////
.Treat all warnings as errors
////
.すべての警告をエラーとして扱う

```
{...
 :builds
 {:app
  {...
   :compiler-options {:warnings-as-errors true}}}}
```

////
.Only throw certain warnings
////
.特定の警告のみを表示する

```
{...
 :builds
 {:app
  {...
   :compiler-options {:warnings-as-errors #{:undeclared-var}}}}
```

////
A set of possible warning-type keywords can be found https://github.com/clojure/clojurescript/blob/5ad96a8b3ae2e3616a19715ba9ba2471a36933a2/src/main/clojure/cljs/analyzer.cljc#L124-L163[here].
////
可能な警告タイプのキーワードのセットは、https://github.com/clojure/clojurescript/blob/5ad96a8b3ae2e3616a19715ba9ba2471a36933a2/src/main/clojure/cljs/analyzer.cljc#L124-L163[こちら] にあります。

////
.Only throw for certain namespaces
////
.特定の名前空間にのみエラーを投げる

```
{...
 :builds
 {:app
  {...
   :compiler-options {:warnings-as-errors {:ignore #{some.ns some.library.*}
                                           :warnings-types #{:undeclared-var}}}
```

////
`:ignore` takes a set of symbols refering to namespaces. Either direct matches or `.*` wildcards are allowed. `:warning-types` has the same functionality as above, not specifying it means all warnings will throw except the ignored namespaces.
////
`ignore` には、名前空間を参照するシンボルのセットを指定します。直接マッチするか、または `.*` のワイルドカードを使用することができます。`:warning-types` は上記と同じ機能を持っています。これを指定しないと、無視された名前空間以外のすべての警告がスローされます。

== 出力言語オプション
//Output Language Options

////
By default the generated JS output will be compatible with ES5 and all "newer" features will be transpiled to compatible code using polyfills. This is currently the safest default and supports most browsers in active use (including IE10+).
////
デフォルトでは、生成される JS 出力は ES5と互換性があり、すべてのより新しい機能はポリフィルを使用して互換性のあるコードに変換されます。これは現在のところ最も安全なデフォルトであり、現在使用されているほとんどのブラウザ（IE10+を含む）をサポートしています。

////
You can select other output options if you only care about more modern environments and want to keep the original code without replacements (eg. `node`, Chrome Extensions, ...)
////
よりモダンな環境にのみ関心があり、置換せずに元のコードを維持したい場合は、他の出力オプションを選択することができます（例：`node`、Chrome Extensions、...）。

////
IMPORTANT: Note that this mostly affects imported JS code from <<npm, npm>> or `.js` files from the <<classpath-js, classpath>>. CLJS will currently only generate ES5 output and is not affected by setting higher options.
////
IMPORTANT: これは主に<<npm, npm>>からインポートされた JS コードや<<classpath-js, classpath>>からの `.js` ファイルに影響することに注意してください。 CLJS は現在、ES5 の出力のみを生成し、より高いオプションを設定しても影響を受けません。

////
You can configure this via the `:output-feature-set` in `:compiler-options`. The older `:language-out` option should not be used as `:output-feature-set` replaced it.
////
これは `:compiler-options` の `:output-feature-set` で設定できます。古い `:language-out` オプションは `:output-feature-set` に置き換わるので、使用しないでください。

////
Supported options are:
////
サポートされているオプションは以下の通りです。

////
- `:es3`
- `:es5`
- `:es6` - `class`, `const`, `let`, ...
- `:es7` - exponent `**` operator
- `:es8` - `async/await`, `generators`, object literals with spread, ...
- `:es-next` - all the features the Closure Compiler currently supports
////
- `:es3`
- `:es5` - `class`, `const`, `let`, ...
- `:es6` - `class`, `const`, `let`, ...
- `:es7` - 指数演算子 `**` 。
- `:es8` - `async/await`, `generators`, スプレッド付きオブジェクトリテラル, ...
- `es-next` - Closure コンパイラが現在サポートしているすべての機能です。

////
.Example
////
.Example

```
{...
 :builds
 {:script
  {:target :node-script
   :main foo.bar/main
   ...
   :compiler-options {:output-feature-set :es7}}}}
```

////
Documentation on these options is a bit sparse and is mostly documented in the code https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java[here] .
////
これらのオプションに関するドキュメントは少し少なく、ほとんどがコード https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java[こちら] に記載されています。


== Conditional Reading
//Conditional Reading

////
CAUTION: This feature only works in `shadow-cljs`. It was officially https://dev.clojure.org/jira/browse/CLJS-2396[rejected] by the ClojureScript project. It will still compile fine in CLJS but only the official branches work (e.g. `:cljs`). It might still be https://groups.google.com/d/msg/clojure-dev/8YJJM8lJuQs/hR5_vUZPCQAJ[supported] one day but as of now it is not.
////
CAUTION: この機能は `shadow-cljs` でのみ動作します。これは ClojureScript プロジェクトによって公式に https://dev.clojure.org/jira/browse/CLJS-2396[rejected] されました。 CLJS でもコンパイルは可能ですが、公式のブランチでのみ動作します(例: `:cljs`)。いつかは https://groups.google.com/d/msg/clojure-dev/8YJJM8lJuQs/hR5_vUZPCQAJ[support] になるかもしれませんが、今のところはそうではありません。

////
`shadow-cljs` lets you configure additional reader features in `.cljc` files. By default you can only use reader conditionals to generate separate code for `:clj`, `:cljs` or `:cljr`. In many CLJS builds however it is also desirable to select which code is generated based on your `:target`.
////
`shadow-cljs` では、 `.cljc` ファイルに追加のリーダ機能を設定することができます。デフォルトでは、リーダの条件式を使用して、 `:clj`、 `:cljs`、または `:cljr` 用の個別のコードを生成することしかできません。しかし、多くの CLJS のビルドでは、 `:target` に基づいて、どのコードを生成するかを選択することも望ましいことです。

////
Example: Some `npm` packages only work when targeting the `:browser`, but you may have a `ns` that you also want to use in a `:node-script` build. This might happen frequently when trying to use Server-Side Rendering (SSR) with your React App. `codemirror` is one such package.
////
例 一部の `npm` パッケージは `:browser` をターゲットにしたときにのみ動作しますが、 `:node-script` のビルドでも使用したい `ns` があるかもしれません。これは、React アプリでサーバサイドレンダリング(SSR)を使おうとしているときに頻繁に起こるかもしれません。 `codemirror` はそのようなパッケージの一つです。

////
```clojure
(ns my.awesome.component
  (:require
    ["react" :as react]
    ["codemirror" :as CodeMirror]))

;; suppose you create a CodeMirror instance on some React :ref
(defn init-cm [dom-node]
  (let [cm (CodeMirror/fromTextArea dom-node #js {...})]
    ...))

...
```
////


```clojure
(ns my.awesome.component
  (:require
    ["react" :as react]
    ["codemirror" :as CodeMirror]))

;; React :ref に CodeMirror のインスタンスを作成する場合
(defn init-cm [dom-node]
  (let [cm (CodeMirror/fromTextArea dom-node #js {...})]
    ...))

...
```


////
This namespace will compile fine for both builds (`:node-script` and `:browser`) but when trying to run the `:node-script` it will fail since the `codemirror` package tries to access the DOM. Since `react-dom/server` does not use refs the `init-cm` function will never be called anyways.
////
この名前空間は、両方のビルド( `:node-script` と `:browser` )で正常にコンパイルされますが、 `:node-script` を実行しようとすると、 `codemirror` パッケージが DOM にアクセスしようとするため、失敗します。しかし、 `:node-script` を実行しようとすると、 `codemirror` パッケージが DOM にアクセスしようとするので失敗します。

////
While you can use <<closure-defines, :closure-defines>> to conditionally compile away the `init-cm` fn you can not use it to get rid of the extra `:require`. Reader conditionals let you do this easily.
////
<<closure-defines, :closure-defines>> を使って条件付きで `init-cm` fn をコンパイルすることはできますが、余分な `:require` を取り除くために使うことはできません。リーダの条件式を使えば、これが簡単にできます。

////
```clojure
(ns my.awesome.component
 (:require
   ["react" :as react]
   ;; NOTE: The order here matters. Only the first applicable
   ;; branch is used. If :cljs is used first it will still be
   ;; taken by the :server build
   #?@(:node [[]]
       :cljs [["codemirror" :as CodeMirror]])))

#?(:node ;; node platform override
   (defn init-cm [dom-node]
    :no-op)
   :cljs ;; default impl
   (defn init-cm [dom-node]
     ... actual impl ...))

...
```
////

```clojure
(ns my.awesome.component
 (:require
   ["react" :as react]
   ;; 注：ここでの順序は重要です。
   ;; 適用可能な最初のブランチのみが使用されます。
   ;; もし :cljs が最初に使用されたとしても、
   ;; それは :server build に引き継がれます。
   #?@(:node [[]]
       :cljs [["codemirror" :as CodeMirror]])))

#?(:node ;; Node プラットフォームのオーバーライド
   (defn init-cm [dom-node]
    :no-op)
   :cljs ;; デフォルトの処理系
   (defn init-cm [dom-node]
     ... actual impl ...))

...
```


////
.`:reader-features` config examples
////
.`:reader-features` 設定例

////
```clojure
{...
 :builds
 ;; app build configured normally, no adjustments required
 {:app
  {:target :browser
   ...}
  ;; for the server we add the :node reader feature
  ;; it will then be used instead of the default :cljs
  :server
  {:target :node-script
   :compiler-options
   {:reader-features #{:node}}}}}
```
////


```clojure
{...
 :builds
 ;; アプリのビルドが正常に設定されており、調整は不要
 {:app
  {:target :browser
   ...}
  ;; サーバには :node reader の機能が追加される
  ;; デフォルトの :cljs の代わりに使用される
  :server
  {:target :node-script
   :compiler-options
   {:reader-features #{:node}}}}}
```

////
The `:server` build will then no longer have the `codemirror` require and the `init-cm` function is removed. Becoming only
////
これにより、 `:server` のビルドには `codemirror` の必要性がなくなり、 `init-cm` の機能も削除されます。ベコミングのみ


////
```clojure
(ns my.awesome.component
  (:require
    ["react" :as react]))

;; this will likely be removed as dead code if
;; its never actually called anywhere

(defn init-cm [dom-node] :no-op)
...
```
////

```clojure
(ns my.awesome.component
  (:require
    ["react" :as react]))

;; 実際にどこにも呼び出されなければ、
;; これはデッドコードとして削除されるでしょう。

(defn init-cm [dom-node] :no-op)
...
```


////
IMPORTANT: This feature is only available in `.cljc` files and will fail in `.cljs` files.
////
IMPORTANT: この機能は、 `.cljc` ファイルでのみ利用可能で、 `.cljs` ファイルでは失敗します。

== CLI からのオーバーライド [[config-merge]]
//Overriding from the CLI [[config-merge]]

////
It is sometimes desirable to make small adjustments to the build configuration from the command line with values that can't be added statically to the `shadow-cljs.edn` config or may change depending on the environment you are in.
////
`shadow-cljs.edn` の設定に静的に追加できない値や、環境によって変わる可能性のある値を使って、コマンドラインからビルド構成を少しずつ調整したい場合があります。

////
You can pass additional config data via the `--config-merge {:some "data"}` command line option which will be merged into the build config. Data added from the CLI will override data from the `shadow-cljs.edn` file.
////
追加の設定データを `--config-merge {:some "data"}` コマンドラインオプションで渡すことができ、ビルド時の設定にマージされます。 CLI から追加されたデータは、 `shadow-cljs.edn` ファイルからのデータよりも優先されます。

////
.Example `shadow-cljs.edn` config
////
.Example `shadow-cljs.edn` の設定

```
{...
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   ...}}}
```

////
.Overriding the `:output-dir` from the CLI
////
.CLI からの `:output-dir` をオーバーライドする

```bash
$ shadow-cljs release app --config-merge '{:output-dir "somewhere/else"}'
```

////
.Overriding the `:closure-defines` from the CLI
////
.CLI からの `:closure-defines` をオーバーライドする

```bash
$ shadow-cljs release app --config-merge '{:closure-defines {your.app/DEBUG true}}'
```

////
`--config-merge` expects one EDN map and can be used multiple times, they will be merged left to right. The data added is also visible to build-hooks.
////
`--config-merge` は 1 つの EDN マップを想定していますが、複数回使用することができ、左から右に向かってマージされます。追加されたデータは build-hooks でも確認できます。

////
IMPORTANT: If you specify multiple build ids the data will be merged into all specified builds. `shadow-cljs release frontend backend --config-merge '{:hello "world"}'` will be applied to both.
////
IMPORTANT: 複数のビルド ID を指定した場合、データは指定したすべてのビルドにマージされます。`shadow-cljs release frontend backend --config-merge '{:hello "world"}'` を指定すると、両方に適用されます。

== 環境変数の使用 [[shadow-env]]
//Using Environment Variables [[shadow-env]]

////
It is possible to use environment variables to set configuration values in `shadow-cljs.edn` but you should consider using `--config-merge` instead. If you really must use an environment variable you can do so via the `#shadow/env "FOO"` reader tag. You can also use the shorter `#env`.
////
環境変数を使って `shadow-cljs.edn` の設定値を設定することは可能ですが、代わりに `--config-merge` の使用を検討すべきです。どうしても環境変数を使わなければならない場合は、 `#shadow/env "FOO"` というリーダタグを使って設定することができます。また、より短い `#env` も使用できます。

////
.Example `shadow-cljs.edn` config
////
.Example `shadow-cljs.edn` の設定

```
{...
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   :closure-defines {your.app/URL #shadow/env "APP_URL"}
   ...}}}
```

////
The are also a few more supported forms that you can use `#shadow/env` with.
////
また、 `#shadow/env` を使用できるサポートされたフォームもいくつかあります。

////
```
#shadow/env "APP_URL"
#shadow/env ["APP_URL"]
;; with default value, used if env variable is not set
#shadow/env ["APP_URL" "default-value"]
#shadow/env ["APP_URL" :default "default-value"]
;; turn PORT env into an integer, with default
#shadow/env ["PORT" :as :int :default 8080]
```
////

```
#shadow/env "APP_URL"
#shadow/env ["APP_URL"]
;; デフォルトの値で、env 変数が設定されていない場合に使用される
#shadow/env ["APP_URL" "default-value"]
#shadow/env ["APP_URL" :default "default-value"]
;; PORT env をデフォルトで整数に変換する
#shadow/env ["PORT" :as :int :default 8080]
```


////
Supported `:as` coercions are `:int`, `:bool`, `:keyword`, `:symbol`. Supplied `:default` values will not be converted and are expected to be in the correct type already.
////
サポートされている `:as` の強制は `:int`, `:bool`, `:keyword`, `:symbol` です。与えられた `:default` の値は変換されず、すでに正しい型になっていることが期待されます。

////
IMPORTANT: The environment variables used when the `shadow-cljs` process was started are used. If a server process is used its environment variables will be used over those potentially set by other commands. This is mostly relevant during development but may be confusing. `--config-merge` does not have this limitation.
////
IMPORTANT: `shadow-cljs` プロセスが開始されたときに使用された環境変数が使用されます。サーバプロセスが使用されている場合、その環境変数は他のコマンドで設定されたものよりも優先して使用されます。これは主に開発中に関係することですが、混乱を招くかもしれません。また、 `--config-merge` にはこのような制限はありません。

== ビルドとターゲットのデフォルト [[build-target-defaults]]

//Build and Target defaults [[build-target-defaults]]

////
It is possible to use set defaults that will be used for all builds, or for all targets of a certain type.
////
すべてのビルド、または特定のタイプのすべてのターゲットに使用されるデフォルトの設定を使用することができます。

////
Configuration merge order is as follows `:build-defaults` -> `:target-defaults` -> actual build config -> extra config overrides.
////
設定のマージ順序は以下の通りです。 `:build-defaults` -> `:target-defaults` -> 実際のビルドコンフィグ -> エクストラコンフィグのオーバーライド。

////
.Example `shadow-cljs.edn` config
////
.Example `shadow-cljs.edn` の設定

```
{...
 :build-defaults
 {:closure-defines 
   {your.app/VERBOSE true}}
   
 :target-defaults
 {:browser
   {:js-options
     {:resolve {"react" {:target :global
                         :global "React"}}}}}
 
 :builds
 {:app
  {:target :browser
   ...}}}
```

////
In this example the `:app` target will inherit both `:build-defaults` and the `:target-defaults` for `:browser`.
////
この例では、 `:app` ターゲットは、 `:build-defaults` と `:browser` の `:target-defaults` の両方を継承します。

////
IMPORTANT: Configs later in the merge order can override, but not remove previous configuration items. Once a default is set, the only way to remove it is by overriding it.
////
IMPORTANT: マージ順で後の方の設定は、前の設定項目を上書きすることはできても、削除することはできません。いったんデフォルトが設定されると、それを削除するにはオーバーライドするしかありません。
