= はじめに

////
`shadow-cljs` provides everything you need to compile your ClojureScript projects with a focus on simplicity and ease of use. The provided build targets abstract away most of the manual configuration so that you only have to configure the essentials for your build. Each target provides optimal defaults for each environment and get an optimized experience during development and in release builds.
////
shadow-cljsは、シンプルさと使いやすさに重点を置いて、ClojureScriptプロジェクトをコンパイルするために必要なすべてを提供します。提供されているビルドターゲットは、手動による設定のほとんどを抽象化し、ビルドに必要なものだけを設定することができます。各ターゲットはそれぞれの環境に最適なデフォルトを提供し、開発時やリリースビルド時に最適なエクスペリエンスを得ることができます。


== 高レベルな概要

////
`shadow-cljs` is composed of 2 parts:
////
shadow-cljs は2つの部分から構成されています。

////
- The https://clojars.org/thheller/shadow-cljs[shadow-cljs] Clojure library which handles all the actual work.
////
- https://clojars.org/thheller/shadow-cljs[shadow-cljs] : こちらは実際の仕事をすべて行うClojureライブラリです。

////
- The https://www.npmjs.com/package/shadow-cljs[shadow-cljs] `npm` package which provides a convenient interface for running most of the build functionality directly from command line.
////
- https://www.npmjs.com/package/shadow-cljs[shadow-cljs] : 
もう一方は、ビルド機能の大半をコマンドラインから直接実行するための便利なインターフェースを提供するnpmパッケージです。


////
If desired you can easily integrate the `shadow-cljs` Clojure library into any other Clojure/JVM build tool (eg. https://leiningen.org/[leiningen] or the https://clojure.org/guides/deps_and_cli[Clojure CLI] tools).
////
必要であれば、Clojureライブラリであるshadow-cljsを、他のClojure/JVMビルドツール（例えば https://leiningen.org/[leiningen] や https://clojure.org/guides/deps_and_cli[Clojure CLI]ツール）に簡単に統合することができます。

////
It is recommended to use the `npm` package as that provides a more optimized development experience tailored towards CLJS development.
////
CLJSの開発に合わせて、より最適化された開発環境を提供するので、npmパッケージを使用することをお勧めします。

== 基本的なワークフロー

////
When working with `shadow-cljs` you will be defining one or more builds in the `shadow-cljs.edn` configuration file. Each build will have a `:target` property which represents a configuration preset optimized for the target environment (eg. the Browser, a `node.js` application or a Chrome Extension).
////
shadow-cljs を使用する際には、設定ファイル shadow-cljs.edn で 1 つ以上のビルドを定義します。それぞれのビルドは、ターゲットとなる環境（例えば、ブラウザ、node.jsアプリケーション、Chrome拡張機能等）に最適化された構成プリセットを表す :target プロパティをもちます。

////
Each build can either produce development or release output depending on the command used to trigger the compilation. The standard build commands are: `compile`, `watch` and `release`.
////
各ビルドは、コンパイルのトリガーとなったコマンドに応じて、開発用またはリリース用の出力を生成します。標準的なビルドコマンドは、compile、watch、release です。

=== development モード

////
You can either `compile` a development build once or run a `watch` process which will monitor your source files and re-compile them automatically (and live-reload the code if desired).
////
開発ビルドを一度だけコンパイルすることも、watch プロセスを実行してソースファイルを監視して自動的に再コンパイルすることもできます（必要に応じてコードをライブロードすることもできます）。

////
All development builds are optimized for the developer experience with fast feedback cycles and other features like a REPL to directly interact with your running code.
////
すべての開発ビルドは、高速なフィードバックサイクルや、実行中のコードと直接やりとりできるREPLなどの機能により、開発者の体験を最適化します。

////
A development build should never be shipped publicly since they can become quite large and may only work on the machine they were compiled on depending on the `:target`.
////
開発用のビルドは、非常に大きなサイズになる可能性があり、:targetに応じてコンパイルされたマシンでしか動作しない可能性があるため、決して一般に配布してはいけません。

=== release モード

////
Creating a `release` build will strip out all the development related code and finally run the code through the Closure Compiler. This is an optimizing Compiler for JavaScript which will significantly reduce the overall size of the code.
////
リリース (release) ビルドを作成すると、開発モード関連のコードがすべて取り除かれ、最後にClosure Compilerにコードを通します。これにより、JavaScript用の最適化コンパイラが、コードの全体的なサイズを大幅に削減します。

== 重要な概念

////
There are several important concepts that you should familiarize yourself with when using `shadow-cljs`. They are integral to understanding how everything fits together and how the tool works with your code.
////
shadow-cljsを使用する際には、いくつかの重要な概念を理解しておく必要があります。これらの概念は、すべてがどのように組み合わされるのか、また、このツールがあなたのコードとどのように連動するのかを理解するために不可欠です。

=== Classpath

////
`shadow-cljs` uses the Java Virtual Machine (JVM) and its "classpath" when working with files. This is a virtual filesystem composed of many classpath entries. Each entry is either
////
shadow-cljsは、ファイルを扱う際に、Java Virtual Machine (JVM) とそのclasspathを使用します。これは、多くのclasspathのエントリからなる仮想ファイルシステムです。各エントリは次のいずれかです。


////
- A local filesystem directory, managed by `:source-paths` entry in the configuration.
- Or a `.jar` file, representing Clojure(Script) or JVM libraries. These are compressed archives containing many files (basically just a `.zip` file). These are added by your `:dependencies`.
////
- 設定の:source-pathsエントリで管理される、ローカルファイルシステムのディレクトリです。
- あるいは、Clojure(Script)やJVMのライブラリを表す.jar` ファイルです。これらは、多くのファイルを含む圧縮アーカイブです(基本的には.zipファイルです)。これらは:dependenciesによって追加されます。

////
In the Clojure(Script) everything is namespaced and each name is expected to resolve to a file. If you have a `(ns demo.app)` namespace the compiler expects to find a `demo/app.cljs` (or `.cljc`) on the classpath. The classpath will be searched in order until it is found. Suppose you configured the `:source-paths ["src/main" "src/test"]` the compiler will first look for a `src/main/demo/app.cljs` and then `src/test/demo/app.cljs`. When the file is not found on any source path the JVM will begin looking into the `.jar` files on the classpath. When it finds a `demo/app.cljs` at the root of any of the libraries that file it will be used.
////
Clojure(Script)では、すべてが名前空間化されていて、それぞれの名前がファイルに解決することが期待されています。(ns demo.app)という名前空間があれば、コンパイラはクラスパス上にdemo/app.cljs(または `.cljc`)があることを期待します。クラスパスは、それが見つかるまで順番に検索されます。例えば、 `:source-paths ["src/main" "src/test"]` を設定したとすると、コンパイラはまず `src/main/demo/app.cljs` を探し、次に `src/test/demo/app.cljs` を探します。どのソースパスにもファイルが見つからない場合、JVMはクラスパス上の.jarファイルを探し始めます。そして、いずれかのライブラリのルートにdemo/app.cljsが見つかると、そのファイルが使用されます。

////
IMPORTANT: When a filename exists multiple times on the classpath then only the first one is used. Everything on the JVM and Clojure(Script) is namespaced to avoid such conflicts. Very similar to `npm` where each package must have a unique name.
////
重要：あるファイル名がクラスパス上に複数回存在する場合、最初のものだけが使用されます。JVMとClojure(Script)上のすべてのものは、このような衝突を避けるために名前空間が設けられています。各パッケージが一意の名前を持たなければならないnpmと非常によく似ています。

////
It is therefore recommended to be very disciplined about the names you choose and properly namespacing everything. It may seem repetitive to always use `(ns your-company.components.foo)` over `(ns components.foo)` but it will save you from lot of headaches later on.
////
そのため、名前の選択には細心の注意を払い、すべてのものに適切な名前空間をつけることをお勧めします。(ns component.foo)よりも(ns your-company.components.foo)を常に使うことは反復的に見えるかもしれませんが、後で多くの頭痛の種をなくすことができます。

////
This is unlike `npm` where the package name itself is never used inside the package itself and only relative paths are used.
////
これはnpmとは異なり、パッケージ名自体がパッケージ内部で使用されることはなく、相対パスのみが使用されます。


=== server モード

////
`shadow-cljs` can be started in "server" mode which is required for long-running tasks such as `watch`. A `watch` will implicitly start the server instance if it is not already running. The server will provide the Websocket endpoint that builds will connect to as well as all the other endpoints for nREPL, Socket REPL and the development HTTP servers.
////
`shadow-cljs` はserverモードで起動することができます。これはwatchのような長時間稼働するタスクに必要です。watchは、サーバインスタンスがまだ起動していなければ、暗黙のうちに起動します。serverは、ビルドが接続するWebsocketのエンドポイントを提供します。また、nREPL、Socket REPL、開発用HTTPサーバの他のすべてのエンドポイントも同様に提供します。


////
When using the `shadow-cljs` CLI all commands will re-use a running server instance JVM instead of starting a new JVM. This is substantially faster since start-up time can be quite slow.
////
CLI のshadow-cljsを使用する場合、すべてのコマンドは新しいJVMを起動する代わりに、実行中のサーバインスタンスのJVMを再利用します。起動時間がかなり遅くなることがあるため、動作が大幅に速くなります。

////
Once the server is running however you only have to restart it whenever your `:dependencies` change and everything else can be done via the REPL.
////
しかし、いったんサーバが稼働すれば、:dependenciesに変更があったときに再起動するだけで、あとはすべてREPLで行うことができます。

=== REPL

////
The REPL is at the heart of all Clojure(Script) development and every CLI command can also be used directly from the REPL as well. It is absolutely worth getting comfortable with the REPL even if the command line may seem more familiar.
////
REPLは、すべてのClojure(Script)開発の中心であり、すべてのCLIコマンドはREPLから直接使用することもできます。コマンドラインの方が馴染みがあるように見えても、REPLを使いこなすことには、絶対に価値があります。

