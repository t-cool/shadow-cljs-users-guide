<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="author" content="Thomas Heller , Tony Kay (邦訳: 野口 浩幹)">
<title>Shadow CLJS User&#8217;s Guide 邦訳</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:initial}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px 0}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:.4em .75em 0 .75em;line-height:1;vertical-align:top}
.colist>table tr>td:first-of-type img{max-width:initial}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Shadow CLJS User&#8217;s Guide 邦訳</h1>
<div class="details">
<span id="author" class="author">Thomas Heller , Tony Kay (邦訳: 野口 浩幹)</span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">Jan 10, 2018</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目次</div>
<ul class="sectlevel1">
<li><a href="#_はじめに">1. はじめに</a>
<ul class="sectlevel2">
<li><a href="#_ハイレベルな概要">1.1. ハイレベルな概要</a></li>
<li><a href="#_基本的なワークフロー">1.2. 基本的なワークフロー</a>
<ul class="sectlevel3">
<li><a href="#_development_モード">1.2.1. development モード</a></li>
<li><a href="#_release_モード">1.2.2. release モード</a></li>
</ul>
</li>
<li><a href="#_重要な概念">1.3. 重要な概念</a>
<ul class="sectlevel3">
<li><a href="#_classpath">1.3.1. Classpath</a></li>
<li><a href="#_server_モード">1.3.2. server モード</a></li>
<li><a href="#_repl">1.3.3. REPL</a></li>
</ul>
</li>
<li><a href="#_本書について">1.4. 本書について</a>
<ul class="sectlevel3">
<li><a href="#_進行中">1.4.1. 進行中</a></li>
<li><a href="#_貢献">1.4.2. 貢献</a></li>
<li><a href="#_使用した規約">1.4.3. 使用した規約</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_インストール">2. インストール</a>
<ul class="sectlevel2">
<li><a href="#_npm_によるスタンドアロン化">2.1. npm によるスタンドアロン化</a></li>
<li><a href="#_ライブラリ">2.2. ライブラリ</a></li>
</ul>
</li>
<li><a href="#_利用法">3. 利用法</a>
<ul class="sectlevel2">
<li><a href="#_コマンドライン">3.1. コマンドライン</a>
<ul class="sectlevel3">
<li><a href="#server-mode">3.1.1. サーバモード</a></li>
</ul>
</li>
<li><a href="#_ビルドツールの統合">3.2. ビルドツールの統合</a>
<ul class="sectlevel3">
<li><a href="#Leiningen">3.2.1. Leiningen</a></li>
<li><a href="#deps-edn">3.2.2. tools.deps / deps.edn</a></li>
<li><a href="#_boot">3.2.3. Boot</a></li>
</ul>
</li>
<li><a href="#clj-run">3.3. Clojure コードの実行</a>
<ul class="sectlevel3">
<li><a href="#_clj_run_による_watch_の呼び出し">3.3.1. clj-run による watch の呼び出し</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_repl_2">4. REPL</a>
<ul class="sectlevel2">
<li><a href="#_clojurescript_repl">4.1. ClojureScript REPL</a>
<ul class="sectlevel3">
<li><a href="#node-repl">4.1.1. Node REPL</a></li>
<li><a href="#browser-repl">4.1.2. Browser REPL</a></li>
<li><a href="#build-repl">4.1.3. ビルドに特化した REPL</a></li>
</ul>
</li>
<li><a href="#_clojure_repl">4.2. Clojure REPL</a>
<ul class="sectlevel3">
<li><a href="#embedded">4.2.1. 組み込み</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#config">5. 設定</a>
<ul class="sectlevel2">
<li><a href="#source-paths">5.1. ソースのパス</a></li>
<li><a href="#_依存関係">5.2. 依存関係</a>
<ul class="sectlevel3">
<li><a href="#_clojure_script">5.2.1. Clojure(Script)</a></li>
<li><a href="#npm-install">5.2.2. JavaScript</a></li>
</ul>
</li>
<li><a href="#user-config">5.3. ユーザの設定</a></li>
<li><a href="#_サーバのオプション">5.4. サーバのオプション</a>
<ul class="sectlevel3">
<li><a href="#nREPL">5.4.1. nREPL</a></li>
<li><a href="#socket-repl">5.4.2. Socket REPL</a></li>
<li><a href="#_ssl">5.4.3. SSL</a></li>
<li><a href="#http">5.4.4. Primary HTTP(S)</a></li>
<li><a href="#dev-http">5.4.5. 開発の HTTP(S)</a></li>
</ul>
</li>
<li><a href="#jvm-opts">5.5. JVM の設定</a></li>
</ul>
</li>
<li><a href="#_ビルドの設定">6. ビルドの設定</a>
<ul class="sectlevel2">
<li><a href="#_ビルドターゲット">6.1. ビルドターゲット</a></li>
<li><a href="#devtools">6.2. 開発オプション</a>
<ul class="sectlevel3">
<li><a href="#_repl_3">6.2.1. REPL</a></li>
<li><a href="#_プリロード">6.2.2. プリロード</a></li>
<li><a href="#_ホットコードリロード">6.2.3. ホットコードリロード</a></li>
<li><a href="#_ライフサイクルフック">6.2.4. ライフサイクルフック</a></li>
</ul>
</li>
<li><a href="#build-hooks">6.3. ビルドフック</a>
<ul class="sectlevel3">
<li><a href="#compile-stages">6.3.1. コンパイル・ステージ</a></li>
</ul>
</li>
<li><a href="#_コンパイラ_キャッシュ">6.4. コンパイラ・キャッシュ</a></li>
<li><a href="#closure-defines">6.5. Closure の定義</a></li>
<li><a href="#compiler-options">6.6. コンパイラのオプション</a>
<ul class="sectlevel3">
<li><a href="#warnigs-as-errors">6.6.1. エラーとしての警告</a></li>
</ul>
</li>
<li><a href="#_出力言語オプション">6.7. 出力言語オプション</a></li>
<li><a href="#_conditional_reading">6.8. Conditional Reading</a></li>
<li><a href="#config-merge">6.9. CLI からのオーバーライド</a></li>
<li><a href="#shadow-env">6.10. 環境変数の使用</a></li>
<li><a href="#build-target-defaults">6.11. ビルドとターゲットのデフォルト</a></li>
</ul>
</li>
<li><a href="#target-browser">7. ブラウザを対象とする</a>
<ul class="sectlevel2">
<li><a href="#_出力設定">7.1. 出力設定</a></li>
<li><a href="#_モジュール">7.2. モジュール</a></li>
<li><a href="#CodeSplitting">7.3. コードスプリッティング</a>
<ul class="sectlevel3">
<li><a href="#_動的にコードを読み込む">7.3.1. 動的にコードを読み込む</a></li>
</ul>
</li>
<li><a href="#output-wrapper">7.4. アウトプット・ラッパー</a></li>
<li><a href="#_web_worker">7.5. Web Worker</a></li>
<li><a href="#_キャッシュ可能な出力">7.6. キャッシュ可能な出力</a>
<ul class="sectlevel3">
<li><a href="#release-version">7.6.1. リリースバージョン</a></li>
<li><a href="#NameHashing">7.6.2. フィンガープリント・ハッシュを使ったファイル名</a></li>
</ul>
</li>
<li><a href="#BrowserManifest">7.7. 出力マニフェスト</a></li>
<li><a href="#_開発サポート">7.8. 開発サポート</a>
<ul class="sectlevel3">
<li><a href="#hud">7.8.1. ヘッドアップディスプレイ（HUD）</a></li>
<li><a href="#_css_リローディング">7.8.2. CSS リローディング</a></li>
<li><a href="#proxy-support">7.8.3. プロキシサポート</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#target-react-native">8. React Native をターゲットにする</a>
<ul class="sectlevel2">
<li><a href="#_react_native">8.1. React Native</a></li>
<li><a href="#_expo">8.2. Expo</a></li>
</ul>
</li>
<li><a href="#target-node">9. Node.js を対象とする</a>
<ul class="sectlevel2">
<li><a href="#target-node-script">9.1. Node.js のスクリプト</a>
<ul class="sectlevel3">
<li><a href="#_ビルドオプション">9.1.1. ビルドオプション</a></li>
<li><a href="#NodeHotCodeReload">9.1.2. ホットコードリロード</a></li>
</ul>
</li>
<li><a href="#target-node-library">9.2. Node.js ライブラリ</a>
<ul class="sectlevel3">
<li><a href="#_単一で静的な_デフォルト_エクスポート">9.2.1. 単一で静的な デフォルト・エクスポート</a></li>
<li><a href="#_複数の静的な名前付きエクスポート">9.2.2. 複数の静的な名前付きエクスポート</a></li>
<li><a href="#_動的エクスポート">9.2.3. 動的エクスポート</a></li>
<li><a href="#_完全な例">9.2.4. 完全な例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#target-npm-module">10. JS エコシステムへの組み込み - :npm-module ターゲット</a>
<ul class="sectlevel2">
<li><a href="#_最適化の作業">10.1. 最適化の作業</a></li>
</ul>
</li>
<li><a href="#_テスト">11. テスト</a>
<ul class="sectlevel2">
<li><a href="#_node_js_におけるテスト_a_id_target_node_test_a">11.1. Node.js におけるテスト　<a id="target-node-test"></a></a></li>
<li><a href="#target-browser-test">11.2. ブラウザにおけるテスト</a>
<ul class="sectlevel3">
<li><a href="#_test_dir_に生成された出力">11.2.1. :test-dir に生成された出力</a></li>
</ul>
</li>
<li><a href="#target-karma">11.3. 継続的インテグレーションのためにテストを Karma にターゲットする</a>
<ul class="sectlevel3">
<li><a href="#_karma_のインストール">11.3.1. Karma のインストール</a></li>
<li><a href="#_build">11.3.2. Build</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#js-deps">12. JavaScript との統合</a>
<ul class="sectlevel2">
<li><a href="#_npm_a_id_npm_a">12.1. npm<a id="npm"></a></a>
<ul class="sectlevel3">
<li><a href="#_npm_パッケージの使用">12.1.1. npm パッケージの使用</a></li>
<li><a href="#js-provider">12.1.2. パッケージプロバイダ</a></li>
<li><a href="#js-entry-keys">12.1.3. CommonJS vs ESM</a></li>
<li><a href="#js-resolve">12.1.4. パッケージを解決する</a></li>
<li><a href="#alt-node-modules">12.1.5. 代替モジュールのディレクトリ</a></li>
</ul>
</li>
<li><a href="#classpath-js">12.2. .js ファイルへの対応</a>
<ul class="sectlevel3">
<li><a href="#_js_を_require_する">12.2.1. JS を require する</a></li>
<li><a href="#_言語サポート">12.2.2. 言語サポート</a></li>
<li><a href="#_javascript_の方言">12.2.3. JavaScript の方言</a></li>
<li><a href="#_js_から_cljs_へのアクセス">12.2.4. JS から CLJS へのアクセス</a></li>
</ul>
</li>
<li><a href="#cljsjs">12.3. cljsjs.* の移行について</a>
<ul class="sectlevel3">
<li><a href="#_cljsjs_を使いませんか">12.3.1. CLJSJS を使いませんか?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#release">13. プロダクションコードの生成&#8201;&#8212;&#8201;全ターゲット</a>
<ul class="sectlevel2">
<li><a href="#_リリースの構成">13.1. リリースの構成</a>
<ul class="sectlevel3">
<li><a href="#Optimization">13.1.1. 最適化</a></li>
<li><a href="#_release_固有_vs_開発環境">13.1.2. release 固有 vs 開発環境</a></li>
</ul>
</li>
<li><a href="#externs">13.2. extern </a>
<ul class="sectlevel3">
<li><a href="#infer-externs">13.2.1. Externs の推論</a></li>
<li><a href="#_手動のextern">13.2.2. 手動のextern</a></li>
<li><a href="#_簡易なextern">13.2.3. 簡易なextern</a></li>
</ul>
</li>
<li><a href="#_コード_ストリッピング">13.3. コード・ストリッピング</a></li>
<li><a href="#build-report">13.4. ビルドレポート</a></li>
</ul>
</li>
<li><a href="#_エディタの統合">14. エディタの統合</a>
<ul class="sectlevel2">
<li><a href="#_cursive">14.1. Cursive</a></li>
<li><a href="#cider">14.2. Emacs / CIDER</a>
<ul class="sectlevel3">
<li><a href="#_clojurescript_repl_の起動">14.2.1. ClojureScript REPL の起動</a></li>
<li><a href="#_dir_local_によるスタートアップの簡素化">14.2.2. dir-local によるスタートアップの簡素化</a></li>
</ul>
</li>
<li><a href="#_proto_repl_atom">14.3. Proto REPL (Atom)</a></li>
<li><a href="#_chlorine_atom">14.4. Chlorine (Atom)</a></li>
<li><a href="#_calva_vs_code">14.5. Calva (VS Code)</a>
<ul class="sectlevel3">
<li><a href="#_依存関係_2">14.5.1. 依存関係</a></li>
<li><a href="#_calva_と_repl_の接続">14.5.2. Calva と REPL の接続</a></li>
<li><a href="#_特徴">14.5.3. 特徴</a></li>
</ul>
</li>
<li><a href="#_fireplace_vim_vim_neovim">14.6. Fireplace.vim (Vim/Neovim)</a>
<ul class="sectlevel3">
<li><a href="#_依存関係_3">14.6.1. 依存関係</a></li>
<li><a href="#_アプリの準備">14.6.2. アプリの準備</a></li>
<li><a href="#_fireplace_vim_と_repl_サーバの接続">14.6.3. Fireplace.vim と REPL サーバの接続</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_トラブルシューティング">15. トラブルシューティング</a>
<ul class="sectlevel2">
<li><a href="#failed-to-load">15.1. 起動時のエラー</a>
<ul class="sectlevel3">
<li><a href="#_deps_edn_tools_deps">15.1.1. deps.edn / tools.deps</a></li>
<li><a href="#_project_clj_leiningen">15.1.2. project.clj / Leiningen</a></li>
</ul>
</li>
<li><a href="#repl-troubleshooting">15.2. REPL</a>
<ul class="sectlevel3">
<li><a href="#cljs-repl-anatomy">15.2.1. CLJS REPL の分析</a></li>
<li><a href="#_javascript_のランタイム">15.2.2. JavaScript のランタイム</a></li>
<li><a href="#missing-js-runtime">15.2.3. JS ランタイムの欠落</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#publish">16. ライブラリの publish</a>
<ul class="sectlevel2">
<li><a href="#publish-lein">16.1. Leiningen</a>
<ul class="sectlevel3">
<li><a href="#_jar_署名の無効化">16.1.1. JAR 署名の無効化</a></li>
<li><a href="#_jar_をクリーンに保つ">16.1.2. JAR をクリーンに保つ</a></li>
</ul>
</li>
<li><a href="#publish-deps-cljs">16.2. JS の依存関係を宣言する</a></li>
</ul>
</li>
<li><a href="#_上手くいかない場合はどうすればいいか">17. 上手くいかない場合はどうすればいいか</a></li>
<li><a href="#_hacking">18. Hacking</a>
<ul class="sectlevel2">
<li><a href="#_ライブラリのパッチ適用">18.1. ライブラリのパッチ適用</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_はじめに"><a class="anchor" href="#_はじめに"></a><a class="link" href="#_はじめに">1. はじめに</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>shadow-cljs</code> は、シンプルさと使いやすさに重点を置いて、ClojureScript プロジェクトをコンパイルするために必要なすべてを提供します。提供されているビルドターゲットは、手動による設定のほとんどを抽象化し、ビルドに必要なものだけを設定することができます。各ターゲットは、それぞれの環境に最適なデフォルト値を提供し、開発時やリリースビルド時に最適化された体験をえることができます。</p>
</div>
<div class="sect2">
<h3 id="_ハイレベルな概要"><a class="anchor" href="#_ハイレベルな概要"></a><a class="link" href="#_ハイレベルな概要">1.1. ハイレベルな概要</a></h3>
<div class="paragraph">
<p><code>shadow-cljs</code> は、以下の 2 つの部分から構成されています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://clojars.org/thheller/shadow-cljs">shadow-cljs</a> : 実際の仕事をすべて行う Clojure Library</p>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.npmjs.com/package/shadow-cljs">shadow-cljs</a> :
ビルド機能の大半をコマンドラインから直接実行するための便利なインターフェースを提供する npm パッケージ</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>必要であれば、Clojure Library である <code>shadow-cljs</code> を、他の Clojure/JVM ビルドツール（例えば <a href="https://leiningen.org/">leiningen</a> や <a href="https://clojure.org/guides/deps_and_cli">Clojure CLI</a>ツール）に簡単に統合することができます。</p>
</div>
<div class="paragraph">
<p>ClojureScript の開発に合わせて、より最適化された開発環境を提供するので、npm パッケージを使用することをお勧めします。</p>
</div>
</div>
<div class="sect2">
<h3 id="_基本的なワークフロー"><a class="anchor" href="#_基本的なワークフロー"></a><a class="link" href="#_基本的なワークフロー">1.2. 基本的なワークフロー</a></h3>
<div class="paragraph">
<p><code>shadow-cljs</code> を使用する際には、設定ファイル <code>shadow-cljs.edn</code> で 1 つ以上のビルドを定義します。それぞれのビルドは、ターゲットとなる環境（例えば、ブラウザ、node.js アプリケーション、Chrome 拡張機能等）に最適化された構成プリセットを表す <code>:target</code> プロパティをもちます。</p>
</div>
<div class="paragraph">
<p>各ビルドは、コンパイルのトリガーとなったコマンドに応じて、開発用またはリリース用の出力を生成します。標準的なビルドコマンドは、<code>compile</code> 、<code>watch</code> 、 <code>release</code> です。</p>
</div>
<div class="sect3">
<h4 id="_development_モード"><a class="anchor" href="#_development_モード"></a><a class="link" href="#_development_モード">1.2.1. development モード</a></h4>
<div class="paragraph">
<p>開発ビルドを一度だけコンパイルすることも、 <code>watch</code> プロセスを実行してソースファイルを監視して自動的に再コンパイルすることもできます（必要に応じてコードをライブロードすることもできます）。</p>
</div>
<div class="paragraph">
<p>すべての開発ビルドは、高速なフィードバックサイクルや、実行中のコードと直接やりとりできる REPL などの機能により、開発者の体験を最適化します。</p>
</div>
<div class="paragraph">
<p>開発用のビルドは、非常に大きなサイズになる可能性があり、<code>:target</code> に応じてコンパイルされたマシンでしか動作しない可能性があるため、決して一般に配布してはいけません。</p>
</div>
</div>
<div class="sect3">
<h4 id="_release_モード"><a class="anchor" href="#_release_モード"></a><a class="link" href="#_release_モード">1.2.2. release モード</a></h4>
<div class="paragraph">
<p><code>release</code> ビルドを作成すると、開発モード関連のコードがすべて取り除かれ、最後に Closure Compiler にコードを通します。これにより、JavaScript 用の最適化コンパイラが、コードの全体的なサイズを大幅に削減します。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_重要な概念"><a class="anchor" href="#_重要な概念"></a><a class="link" href="#_重要な概念">1.3. 重要な概念</a></h3>
<div class="paragraph">
<p>あなたが <code>shadow-cljs</code> を使用する際には、いくつかの重要な概念を理解しておく必要があります。これらの概念は、すべてがどのように組み合わされるのか、またツールがコードとどのように連動するのかを理解するために不可欠です。</p>
</div>
<div class="sect3">
<h4 id="_classpath"><a class="anchor" href="#_classpath"></a><a class="link" href="#_classpath">1.3.1. Classpath</a></h4>
<div class="paragraph">
<p><code>shadow-cljs</code> は、ファイルを扱う際に Java Virtual Machine (JVM) とその classpath を使用します。</p>
</div>
<div class="paragraph">
<p>これは、多くの classpath のエントリからなる仮想ファイルシステムです。各エントリは次のいずれかです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>設定の <code>:source-paths</code> エントリで管理される、ローカルファイルシステムのディレクトリです。</p>
</li>
<li>
<p>あるいは Clojure(Script)や JVM のライブラリを表す <code>.jar</code> ファイルです。これらは多くのファイルを含む圧縮アーカイブです(基本的には単なる <code>.zip</code> ファイルです)。これらは <code>:dependencies</code> によって追加されます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Clojure(Script) では、すべてが名前空間化されていて、それぞれの名前がファイルに解決することが期待されています。 <code>(ns demo.app)</code> という名前空間があれば、コンパイラはクラスパス上に <code>demo/app.cljs</code> (または <code>.cljc</code>)があることを期待します。クラスパスは、それが見つかるまで順番に検索されます。以下のように設定したとします。</p>
</div>
<div class="paragraph">
<p><code>:source-paths ["src/main" "src/test"]</code></p>
</div>
<div class="paragraph">
<p>この場合、コンパイラは、以下のように探索を行います。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>src/main/demo/app.cljs</code> を探す</p>
</li>
<li>
<p>次に <code>src/test/demo/app.cljs</code> を探す</p>
</li>
<li>
<p>ソースパスでファイルが見つからない場合、JVM はクラスパス上の <code>.jar</code> ファイルを探す</p>
</li>
<li>
<p>上記のいずれかのライブラリのルートに <code>demo/app.cljs</code> が見つかると、そのファイルが使用される</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
あるファイル名がクラスパス上に複数回存在する場合、最初のものだけが使用されます。 JVM と Clojure(Script)上のすべてのものは、このような衝突を避けるために名前空間が設けられています。各パッケージが一意の名前を持たなければならない <code>npm</code> と非常によく似ています。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>そのため、名前の選択には細心の注意を払い、すべてのものに適切な名前空間をつけることをお勧めします。</p>
</div>
<div class="paragraph">
<p><code>(ns component.foo)</code> よりも <code>(ns your-company.components.foo)</code> を常に使うことは反復的に見えるかもしれませんが、後で多くの頭痛の種をなくすことができます。</p>
</div>
<div class="paragraph">
<p>これは <code>npm</code> とは異なり、パッケージ名自体がパッケージ内部で使用されることはなく、相対パスのみが使用されます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_server_モード"><a class="anchor" href="#_server_モード"></a><a class="link" href="#_server_モード">1.3.2. server モード</a></h4>
<div class="paragraph">
<p><code>shadow-cljs</code> は <code>server</code> モードで起動することができます。これは <code>watch</code> のような長時間稼働するタスクに必要です。 <code>watch</code> は、サーバインスタンスがまだ起動していなければ、暗黙のうちに起動します。 <code>server</code> は、ビルドが接続する Websocket のエンドポイントを提供します。また、nREPL、Socket REPL、開発用 HTTP サーバの他のすべてのエンドポイントも同様に提供します。</p>
</div>
<div class="paragraph">
<p><code>shadow-cljs</code> CLI を使用する場合、すべてのコマンドは新しい JVM を起動する代わりに、実行中のサーバインスタンスの JVM を再利用します。起動時間がかなり遅くなることがありますが、動作が大幅に速くなります。</p>
</div>
<div class="paragraph">
<p>しかし一度サーバが稼働すれば、<code>:dependencies</code> に変更があったときに再起動するだけで、あとはすべて REPL で行うことができます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_repl"><a class="anchor" href="#_repl"></a><a class="link" href="#_repl">1.3.3. REPL</a></h4>
<div class="paragraph">
<p>REPL は、すべての Clojure(Script) 開発の中心であり、すべての CLI コマンドは REPL から直接使用することもできます。コマンドラインの方が馴染みがあるように見えても、REPL を使いこなすことには、絶対に価値があります。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_本書について"><a class="anchor" href="#_本書について"></a><a class="link" href="#_本書について">1.4. 本書について</a></h3>
<div class="sect3">
<h4 id="_進行中"><a class="anchor" href="#_進行中"></a><a class="link" href="#_進行中">1.4.1. 進行中</a></h4>
<div class="paragraph">
<p>これは現在進行中の作業です。エラーを発見した場合は、それを修正するための Pull Request 、または問題の詳細を記載した issue を提出してください。</p>
</div>
</div>
<div class="sect3">
<h4 id="_貢献"><a class="anchor" href="#_貢献"></a><a class="link" href="#_貢献">1.4.2. 貢献</a></h4>
<div class="paragraph">
<p>この本のソースは <a href="https://github.com/shadow-cljs/shadow-cljs.github.io">Github</a> にあります。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用した規約"><a class="anchor" href="#_使用した規約"></a><a class="link" href="#_使用した規約">1.4.3. 使用した規約</a></h4>
<div class="paragraph">
<p>この本にはたくさんの例題があります。これらの中で使われているほとんどのものは、その文脈から明らかなはずです。
しかし、誤解を防ぐためには、作者の意図を知ることが大切です。</p>
</div>
<div class="paragraph">
<p>コマンドラインの例を示すときには、BASH のコメント（ <code>#</code> で始まる）を含めることがあります。通常は、コマンドとその出力の分離を示すために、標準的なユーザー UNIX プロンプトである <code>$</code> を含めます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># コメントです。このコマンドは、ファイルを一覧表示します。
$ ls -l
shadow-cljs.edn
project.clj
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>例題の多くは、コンパイラの設定ファイルです。このファイルには、EDN マップが含まれています。必要なオプションについてすでに説明している場合は、わかりやすくするために省略することがあります。この場合、必要だが、現在の焦点ではない内容を示すために省略記号を入れるのが普通です。</p>
</div>
<div class="listingblock">
<div class="title">Example 1. 依存関係の指定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:dependencies [[lib "1.0"]]}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 2. ソースパスの追加</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :source-paths ["src"]
 ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、対象となる構成の入れ子を理解するのに十分なコンテキストを簡潔に含めることができます。</p>
</div>
<div class="listingblock">
<div class="title">Example 3. ネストのオプション</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds {:build-id {...
                     :output-dir "resources/public/js"}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>コード例も同様に短くすることができます。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_インストール"><a class="anchor" href="#_インストール"></a><a class="link" href="#_インストール">2. インストール</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_npm_によるスタンドアロン化"><a class="anchor" href="#_npm_によるスタンドアロン化"></a><a class="link" href="#_npm_によるスタンドアロン化">2.1. npm によるスタンドアロン化</a></h3>
<div class="paragraph">
<p>以下のことが必要となります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://nodejs.org"><code>node.js</code></a> (v6.0.0+, 最新のバージョンが望ましいです)</p>
</li>
<li>
<p><a href="https://www.npmjs.com"><code>npm</code></a> または <a href="https://www.yarnpkg.com"><code>yarn</code></a></p>
</li>
<li>
<p>任意の Java SDK (バージョン 8 以上): <a href="http://openjdk.java.net/install/">OpenJDK</a> もしくは <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>プロジェクトのディレクトリには、<code>package.json</code> が必要です。ない場合は <code>npm init -y</code> を実行して作成することができます。プロジェクトディレクトリがない場合は、次のコマンドを実行して作成してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">$ npx create-cljs-project my-project</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで必要な基本ファイルがすべて作成されるので、以下のコマンドは省略できます。</p>
</div>
<div class="paragraph">
<p>すでに <code>package.json</code> があり、 <code>shadow-cljs</code> を追加したいだけの場合は、以下を実行します。</p>
</div>
<div class="listingblock">
<div class="title">NPM</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npm install --save-dev shadow-cljs</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Yarn</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ yarn add --dev shadow-cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>便宜上、 <code>npm install -g shadow-cljs</code> または <code>yarn global add shadow-cljs</code> を実行することができます。これにより、後で <code>shadow-cljs</code> コマンドを直接実行できるようになります。あなたのプロジェクトには常に shadow-cljs のバージョンがインストールされている必要があり、グローバル・インストールは任意です。</p>
</div>
</div>
<div class="sect2">
<h3 id="_ライブラリ"><a class="anchor" href="#_ライブラリ"></a><a class="link" href="#_ライブラリ">2.2. ライブラリ</a></h3>
<div class="paragraph">
<p>スタンドアロン版は <code>npm</code> 経由で実行することが推奨されますが、 <code>shadow-cljs</code> を他の Clojure JVM ツール (例えば lein や boot 等) に組み込むこともできます。</p>
</div>
<div class="paragraph">
<p>artifact は以下のサイトで入手できます。</p>
</div>
<div class="paragraph">
<p><a href="https://clojars.org/thheller/shadow-cljs">https://clojars.org/thheller/shadow-cljs</a></p>
</div>
<div class="paragraph">
<p><a href="https://github.com/thheller/shadow-cljs">https://github.com/thheller/shadow-cljs</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_利用法"><a class="anchor" href="#_利用法"></a><a class="link" href="#_利用法">3. 利用法</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>shadow-cljs</code> は様々な方法で使用できますが、一般的なワークフローは同じです。</p>
</div>
<div class="paragraph">
<p>開発中には、ビルドを一度だけ <code>compile</code> するか、ソースファイルの変更を監視して自動的に再コンパイルする <code>watch</code> ワーカーを実行するかのオプションがあります。このワーカーはソースファイルの変更を監視し、自動的に再コンパイルします。<a href="#devtools">enabled</a> の場合、 <code>watch</code> はコードをホットリロードし、REPL を提供します。開発中は、迅速なフィードバックサイクルによる開発者の経験に重点を置いています。開発コードは決して公開してはいけません。</p>
</div>
<div class="paragraph">
<p>本格的に開発する場合には、<a href="#release"><code>release</code></a>というビルドを作成し、本番環境に適した最適化されたビルドを作成します。これには <a href="https://developers.google.com/closure/compiler/">Closure Compiler</a> が使用され、利用可能な最も最適な出力を作成するために、コードに深刻な <code>:advanced</code> 最適化を適用します。ネイティブ JavaScript とのインターロップを多用している場合には、適切に動作させるためにいくつかの<a href="#externs">チューニング</a>が必要になるかもしれませんが、ClojureScript(および <a href="https://developers.google.com/closure/library/">Closure Library</a> のコード)では完璧に動作します。</p>
</div>
<div class="sect2">
<h3 id="_コマンドライン"><a class="anchor" href="#_コマンドライン"></a><a class="link" href="#_コマンドライン">3.1. コマンドライン</a></h3>
<div class="paragraph">
<p>グローバル環境にインストールされている場合は、 <code>shadow-cljs</code> コマンドを直接使用することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs help</code></pre>
</div>
</div>
<div class="paragraph">
<p>ローカルにインストールした <code>npm</code> のみを使用したい場合は、 <code>npx</code> や <code>yarn</code> を介して起動することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># npm
$ npx shadow-cljs help

# yarn
$ yarn shadow-cljs help

# 手動で行う場合
$ ./node_modules/.bin/shadow-cljs help</code></pre>
</div>
</div>
<div class="paragraph">
<p>例を短くするため、このガイドではグローバルインストールを前提としていますが、これは必須ではありません。</p>
</div>
<div class="paragraph">
<p>開発中によく使う shadow-cljs コマンドは以下の通りです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># ビルドを一度コンパイルして終了
$ shadow-cljs compile app

# コンパイルと監視
$ shadow-cljs watch app

# ビルド用の REPL に接続 (watch の実行中に利用可能)$ shadow-cljs cljs-repl app

# スタンドアロンの Node repl への接続
$ shadow-cljs node-repl</code></pre>
</div>
</div>
<div class="paragraph">
<p>次のように、本番使用に最適化されたリリースビルドを実行します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">$ shadow-cljs release app</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:advanced</code> のコンパイルが原因で、リリース上の問題に遭遇することがあります。これらのコマンドは、その原因を追跡するのに役立ちます。</p>
</div>
<div class="paragraph">
<p>Release デバッグコマンド</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">$ shadow-cljs check app
$ shadow-cljs release app --debug</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="server-mode"><a class="anchor" href="#server-mode"></a><a class="link" href="#server-mode">3.1.1. サーバモード</a></h4>
<div class="paragraph">
<p><code>shadow-cljs</code> コマンドを使う際、起動にかなり時間がかかります。この点を改善するために、<code>shadow-cljs</code> はサーバモードで動作させることができます。</p>
</div>
<div class="paragraph">
<p>これにより専用のプロセスが開始され、他のすべてのコマンドがそれを利用して、新しい JVM/Clojure インスタンスを開始する必要がないため、より速く実行できます。</p>
</div>
<div class="paragraph">
<p>長時間実行される処理を行うコマンドは、暗黙のうちにサーバインスタンスを起動しますが（例えば <code>watch</code> の場合）、多くの場合は専用のサーバプロセスを起動することが望ましいでしょう。専用のサーバプロセスを実行することが望ましい場合もあります。</p>
</div>
<div class="paragraph">
<p>専用端末のフォアグラウンドでプロセスを実行することができます。サーバを終了するには <code>CTRL+C</code> を押してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs server
# または REPL にサーバプロセスを制御させたい場合
$ shadow-cljs clj-repl</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、一般的な <code>start|stop|restart</code> 関数を使って、バックグランドでサーバを制御することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs start
$ shadow-cljs stop
$ shadow-cljs restart</code></pre>
</div>
</div>
<div class="paragraph">
<p>いずれかのサーバが起動していれば、他のすべてのコマンドはそのサーバを使用し、より速く動作します。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ビルドツールの統合"><a class="anchor" href="#_ビルドツールの統合"></a><a class="link" href="#_ビルドツールの統合">3.2. ビルドツールの統合</a></h3>
<div class="paragraph">
<p><code>shadow-cljs</code> は他の Clojure ツールと統合することができます。なぜなら、主要な配布物は <a href="https://clojars.org/thheller/shadow-cljs">Clojars</a> を通じて入手できる <code>.jar</code> ファイルだからです。デフォルトでは <code>:dependencies</code> は <code>shadow-cljs.edn</code> で管理されますが、他のビルドツールを使って依存関係を管理することもできます。</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
スタンドアロンの <code>shadow-cljs</code> バージョンを使用することを強くお勧めします。このコマンドは、UX を最適化するために、他のツールでは行われない多くのことを行います (例えば、起動の高速化など)。また、依存関係の衝突やその他の関連するエラーに対処するための多くの頭痛の種を避けることができるでしょう。
</td>
</tr>
</table>
</div>
<div style="page-break-after: always;"></div>
<div class="sect3">
<h4 id="Leiningen"><a class="anchor" href="#Leiningen"></a><a class="link" href="#Leiningen">3.2.1. Leiningen</a></h4>
<div class="paragraph">
<p><a href="https://leiningen.org/">Leiningen</a> を使って依存関係を管理したい場合は、 <code>shadow-cljs.edn</code> の設定に <code>:lein</code> エントリを追加することで可能になります。この設定により、 <code>shadow-cljs</code> コマンドは JVM を起動する際に <code>lein</code> を使用し、 <code>shadow-cljs.edn</code> 内の <code>:source-paths</code> や <code>:dependencies</code> は一切無視し、代わりに <code>project.clj</code> から設定された <code>lein</code> を使用します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:lein true
; :source-paths と :dependencies はこのファイルでは無視されます

; これらを project.clj で設定する
 :builds { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">専用の <code>lein</code> プロファイルの使用</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:lein {:profile "+cljs"}
 :builds {...}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Sample project.clj</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(defproject my-awesome-project
  ...
  :profiles
  {:cljs
   {:source-paths ["src/cljs"]
    :dependencies [[thheller/shadow-cljs "..."]
                   [reagent "0.8.1"]]}})</code></pre>
</div>
</div>
<div class="paragraph">
<p>project.clj を使って :dependencies を管理する場合、 <a href="https://clojars.org/thheller/shadow-cljs">thheller/shadow-cljs</a> アーティファクトを :dependencies に (直接またはプロファイルで) 手動で含める必要があります。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>shadow-cljs</code> の起動時やコンパイル・ビルド時に奇妙な Java Stackstraces に遭遇した場合、依存関係の衝突が考えられます。重要なのは、 <code>shadow-cljs</code> が、適切にマッチした <code>org.clojure/clojurescript</code> と <code>closure-compiler</code> のバージョンと一緒に使われていることです。必要なバージョンは <a href="https://clojars.org/thheller/shadow-cljs">clojars</a> (右側)にリストアップされていますので、 <code>lein deps :tree</code> で確認できます。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_leiningen_から直接タスクを実行する"><a class="anchor" href="#_leiningen_から直接タスクを実行する"></a><a class="link" href="#_leiningen_から直接タスクを実行する">Leiningen から直接タスクを実行する</a></h5>
<div class="paragraph">
<p>また、 <code>shadow-cljs</code> コマンド自体を使いたくない場合は、 <code>lein</code> を使って <code>shadow-cljs</code> コマンドを直接実行することもできます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
コマンドを実行する際には、引き続き <code>shadow-cljs</code> コマンドを使用することをお勧めします。このコマンドは、実行中のサーバモードのインスタンスを最大限に活用します。これにより、 <code>lein</code> を直接使用して追加の JVM を起動するよりも、大幅に速くコマンドを実行することができます。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>REPL やライブリロードは不要で、dev モードで一度コンパイルするだけです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ lein run -m shadow.cljs.devtools.cli compile build-id</code></pre>
</div>
</div>
<div class="paragraph">
<p>リリースモードに最適化されたビルドを作成するには、次のようにします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ lein run -m shadow.cljs.devtools.cli release build-id</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="deps-edn"><a class="anchor" href="#deps-edn"></a><a class="link" href="#deps-edn">3.2.2. tools.deps / deps.edn</a></h4>
<div class="paragraph">
<p><a href="https://clojure.org/guides/deps_and_cli">deps.edn</a> を使うと、ビルトインのメソッドや <code>lein</code> を使用せずに、<code>:dependencies</code> や <code>:source-paths</code> を管理できます。
<code>shadow-cljs</code> コマンドは、代わりに新しい <code>clojure</code> ユーティリティを介して起動されます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>tools.deps</code> は現在も頻繁に変更されています。必ず最新のバージョンを使用してください。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>これを使うには、設定で <code>:deps true</code> プロパティを設定します。また、どの <code>deps.edn</code> のエイリアスを使用するかを設定することもできます。</p>
</div>
<div class="paragraph">
<p><code>thheller/shadow-cljs</code> の artifact(成果物) を手動で <code>deps.edn</code> に追加する必要があります。</p>
</div>
<div class="listingblock">
<div class="title">シンプルな shadow-cljs.edn の例</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:deps true
 :builds ...}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">シンプルな <code>deps.edn</code> の例</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:paths [...]
 :deps {thheller/shadow-cljs {:mvn/version &lt;latest&gt;}}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example <code>shadow-cljs.edn</code> に :cljs のエイリアスをつけたもの</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:deps {:aliases [:cljs]}
 :builds ...}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example deps.edn</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:paths [...]
 :deps {...}
 :aliases
 {:cljs
  {:extra-deps {thheller/shadow-cljs {:mvn/version &lt;latest&gt;}}}}</code></pre>
</div>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>clj で直接実行するには、次のように指定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:paths [...]
 :deps {...}
 :aliases
 {:shadow-cljs
  {:extra-deps {thheller/shadow-cljs {:mvn/version &lt;latest&gt;}}
   :main-opts ["-m" "shadow.cljs.devtools.cli"]}}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">clj -A:shadow-cljs watch app</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、 <code>shadow-cljs -A:foo:bar &#8230;&#8203;</code> のように、コマンドラインで <code>-A</code> を使って追加のエイリアスを指定することもできます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
エイリアスは、新しいインスタンか/サーバを起動したときにのみ適用されます。shadow-cljs コマンドを使って稼働中のサーバに接続するときには適用されません。 <code>clj</code> で起動すると、常に新しい JVM を起動することになり、サーバモードをサポートしません。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_boot"><a class="anchor" href="#_boot"></a><a class="link" href="#_boot">3.2.3. Boot</a></h4>
<div class="paragraph">
<p>著者は Boot の経験がほとんどないので、この章は貢献を必要としています。 Boot では関数からツールチェーンを構築できることを理解しています。 <code>shadow-cljs</code> は普通の JVM ライブラリなので、その中の関数を呼び出してタスクを起動することができます。</p>
</div>
<div class="paragraph">
<p>いくつかの Boot タスクは以下のリンクで入手できます。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/jgdavey/boot-shadow-cljs" class="bare">https://github.com/jgdavey/boot-shadow-cljs</a></p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect2">
<h3 id="clj-run"><a class="anchor" href="#clj-run"></a><a class="link" href="#clj-run">3.3. Clojure コードの実行</a></h3>
<div class="paragraph">
<p>コマンドラインから特定の Clojure関数を呼び出すために、 <code>shadow-cljs</code> という CLI を使うことができます。これは、あるタスクの前後にコードを実行したいときに便利です。例えば、 <code>release</code> ビルドの出力をリモートサーバに <code>rsync</code> したいとします。</p>
</div>
<div class="listingblock">
<div class="title">Example <code>src/my/build.clj</code> における Clojure の名前空間</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.build
  (:require
    [shadow.cljs.devtools.api :as shadow]
    [clojure.java.shell :refer (sh)]))

(defn release []
  (shadow/release :my-build)
  (sh "rsync" "-arzt" "path/to/output-dir" "my@server.com:some/path"))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">release 関数の実行</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs clj-run my.build/release
# または
$ shadow-cljs run my.build/release</code></pre>
</div>
</div>
<div class="paragraph">
<p>呼び出された関数には、コマンドラインから引数を渡すことができます。</p>
</div>
<div class="listingblock">
<div class="title">通常の Clojure fn の args を使った引数の使用</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">...
(defn release [server]
  (shadow/release :my-build)
  (sh "rsync" "-arzt" "path/to/output-dir" server))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">コマンドラインからのサーバの受け渡し</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs clj-run my.build/release my@server.com:some/path</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<a href="https://github.com/clojure/tools.cli">tools.cli</a> のように引数を解析したい場合は、通常の <code>(defn release [&amp; args])</code> の構造でも動作します。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>ここでは、Clojure のフルパワーにアクセスできます。必要に応じて、この上にツール全体を構築することができます。おまけに、この方法で書いたものはすべて、Clojure REPL で直接利用できます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<a href="#server-mode">server</a> が実行されている場合、名前空間は自動的にはリロードされず、一度だけロードされます。 REPL を使って開発を行い、通常通りファイルをリロードすることをお勧めします（例：<code>(require 'my.build :reload)</code>)。
<code>shadow-cljs clj-eval "(require 'my.build :reload)"</code> を実行して、コマンドラインから手動でリロードすることもできます。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_clj_run_による_watch_の呼び出し"><a class="anchor" href="#_clj_run_による_watch_の呼び出し"></a><a class="link" href="#_clj_run_による_watch_の呼び出し">3.3.1. clj-run による watch の呼び出し</a></h4>
<div class="paragraph">
<p>デフォルトでは、 <code>clj-run</code> から呼び出された関数は、 <code>compile</code>, <code>release</code> やその他の Clojure 機能を実行するのに十分な、最小限の <code>shadow-cljs</code> ランタイムにしかアクセスできません。関数が完了すると、JVM は終了します。</p>
</div>
<div class="paragraph">
<p>あるビルドに対して <code>watch</code> を開始したい場合は、呼び出している関数が完全なサーバを必要とすることを宣言する必要があります。これにより、あなたが明示的に <code>(shadow.cljs.devtools.server/stop!)</code> を呼び出すか、 <code>CTRL+C</code> でプロセスを停止させるまで、そのプロセスは生き続けます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns demo.run
  (:require [shadow.cljs.devtools.api :as shadow]))

;; これは完全なサーバインスタンスがないために失敗します
(defn foo
  [&amp; args]
  (shadow/watch :my-build))

;; このメタデータは、watch が動作するようにサーバを起動することを保証します
(defn foo
  {:shadow/requires-server true}
  [&amp; args]
  (shadow/watch :my-build))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_repl_2"><a class="anchor" href="#_repl_2"></a><a class="link" href="#_repl_2">4. REPL</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>REPL は、Clojure(Script)のコードを扱う際に、非常に強力なツールです。 <code>shadow-cljs</code> は、すぐに始められるいくつかのビルトインバージョンと、標準的なビルドに統合されるバージョンを提供します。</p>
</div>
<div class="paragraph">
<p>いくつかのコードをすぐにテストしたい場合は、内蔵の REPL で十分です。自分で何かをするような、より複雑なセットアップが必要な場合は、実際のビルドを使うのが一番です。</p>
</div>
<div class="sect2">
<h3 id="_clojurescript_repl"><a class="anchor" href="#_clojurescript_repl"></a><a class="link" href="#_clojurescript_repl">4.1. ClojureScript REPL</a></h3>
<div class="paragraph">
<p>デフォルトでは、 <code>node-repl</code> と <code>browser-repl</code> のどちらかを選択することができます。どちらも似た動作をしますが、違いは、一方が <code>node.js</code> が管理するプロセスで動作するのに対し、他方は実際のコードを評価するために使用されるブラウザウィンドウを開くことです。</p>
</div>
<div class="sect3">
<h4 id="node-repl"><a class="anchor" href="#node-repl"></a><a class="link" href="#node-repl">4.1.1. Node REPL</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs node-repl</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、すでに接続されている <code>node</code> プロセスで、空の CLJS REPL を開始します。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Node REPL を終了すると、 <code>node</code> プロセスも kill されます。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>node-repl</code> により、追加設定をする必要がなく、すぐに使い始めることができます。</p>
</div>
<div class="paragraph">
<p><code>node-repl</code> は、 <code>(require '[your.core :as x])</code> という通常の方法で、あなたのすべてのコードにアクセスします。ビルドに接続されていないので、ファイルが変更されてもコードの自動再構築は行われず、ホットリロードも提供されません。</p>
</div>
</div>
<div class="sect3">
<h4 id="browser-repl"><a class="anchor" href="#browser-repl"></a><a class="link" href="#browser-repl">4.1.2. Browser REPL</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs browser-repl</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、空の CLJS REPL を起動し、コードが実行される関連するブラウザのウィンドウを開きます。ブラウザ上で実行されるだけでなく、上記の <code>node-repl</code> と同じ機能を持っています。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
ブラウザウィンドウを閉じると REPL は動作しません。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="build-repl"><a class="anchor" href="#build-repl"></a><a class="link" href="#build-repl">4.1.3. ビルドに特化した REPL</a></h4>
<div class="paragraph">
<p><code>node-repl</code> と <code>browser-repl</code> は、特定のビルド構成なしに動作します。つまり、あなたが指示したことだけを実行し、自分では何もしないということです。</p>
</div>
<div class="paragraph">
<p>特定のものをビルドしたい場合は、提供されているビルドターゲットの 1 つを使ってビルドを設定する必要があります。それらのほとんどは、ClojureScript REPL に必要なコードを自動的に注入します。それは追加の設定を必要としないはずです。ビルド CLJS REPL が動作するためには、次の 2 つが必要です。</p>
</div>
<div class="paragraph">
<p>ビルドのための実行中の <code>watch</code> です。
ターゲットの JS ランタイムを接続します。つまり、<code>:browser</code> ターゲットを使用している場合、生成された JS がロードされているブラウザを開く必要があります。 node.js のビルドの場合は、 <code>node</code> プロセスの実行を意味します。</p>
</div>
<div class="paragraph">
<p>両方を入手したら、コマンドラインまたは Clojure REPL から CLJS REPL に接続できます。</p>
</div>
<div class="listingblock">
<div class="title">CLI</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs watch build-id
...

# 異なるターミナル
$ shadow-cljs cljs-repl build-id
shadow-cljs - connected to server
[3:1]~cljs.user=&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">REPL</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs clj-repl
...
[2:0]~shadow.user=&gt; (shadow/watch :browser)
[:browser] Configuring build.
[:browser] Compiling ...
[:browser] Build completed. (341 files, 1 compiled, 0 warnings, 3,19s)
:watching
[2:0]~shadow.user=&gt; (shadow/repl :browser)
[2:1]~cljs.user=&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
REPL を終了するには、<code>:repl/quit</code> と入力してください。これは REPL を終了するだけで、 <code>watch</code> は引き続き実行されます。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
複数の <code>watch</code> ワーカーを並行して実行し、任意の時間にそれらの REPL に接続/切断することができます。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">No connected runtime error の発生</div>
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">[3:1]~cljs.user=&gt; (js/alert "foo")
There is no connected JS runtime.</code></pre>
</div>
</div>
<div class="paragraph">
<p>これが表示された場合、ブラウザでアプリを開くか、 <code>node</code> プロセスを開始する必要があります。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_clojure_repl"><a class="anchor" href="#_clojure_repl"></a><a class="link" href="#_clojure_repl">4.2. Clojure REPL</a></h3>
<div class="paragraph">
<p>提供されている ClojureScript REPL に加えて、Clojure REPL も提供されています。これは、 <code>shadow-cljs</code> プロセスを制御し、他のすべてのビルドコマンドを実行するために使用できます。Clojure REPL から始めて、いつでも CLJS REPL にアップグレードすることができます(そして元に戻すこともできます)。</p>
</div>
<div class="listingblock">
<div class="title">CLI からの実行</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs clj-repl
...
shadow-cljs - REPL - see (help), :repl/quit to exit
[1:0]~shadow.user=&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>名前空間 <code>shadow.cljs.devtools.api</code> には、CLI に対応する関数とほぼ 1 対1に対応する関数があります。デフォルトでは <code>shadow</code> という名前でエイリアスされています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">;; shadow-cljs watch foo
(shadow.cljs.devtools.api/watch :foo)

;; ns のエイリアスが用意されているため同等
(shadow/watch :foo)

;; shadow-cljs watch foo --verbose
(shadow/watch :foo {:verbose true})

;; shadow-cljs compile foo
(shadow/compile :foo)

;; shadow-cljs release foo
(shadow/release :foo)

;; shadow-cljs browser-repl
(shadow/browser-repl)

;; shadow-cljs node-repl
(shadow/node-repl)

;; shadow-cljs cljs-repl foo
(shadow/repl :foo)

;; CLJS REPL に入れば :repl/quit や cljs/quit を使って CLJ に戻ることができる</code></pre>
</div>
</div>
<div style="page-break-after: always;"></div>
<div class="sect3">
<h4 id="embedded"><a class="anchor" href="#embedded"></a><a class="link" href="#embedded">4.2.1. 組み込み</a></h4>
<div class="paragraph">
<p>また、他の CLJ プロセスの中から完全に <code>shadow-cljs</code> を使用することも可能です。クラスパスに <code>thheller/shadow-cljs</code> がロードされていれば、問題ありません。</p>
</div>
<div class="listingblock">
<div class="title">lein repl を使った例</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ lein repl
nREPL server started on port 57098 on host 127.0.0.1 - nrepl://127.0.0.1:57098
REPL-y 0.4.3, nREPL 0.6.0
Clojure 1.10.0
...

user=&gt; (require '[shadow.cljs.devtools.server :as server])
nil
user=&gt; (server/start!)
...
:shadow.cljs.devtools.server/started
user=&gt; (require '[shadow.cljs.devtools.api :as shadow])
nil
user=&gt; (shadow/compile :foo)
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>(shadow.cljs.devtools.server/stop!)</code> を実行することで、組み込みサーバを停止することができます。これにより、実行中のすべてのビルドプロセスも停止します。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
CLJS REPL に切り替えたい場合は、サーバの起動に使用したツールで追加の設定が必要になる場合があります。 <code>lein</code> はデフォルトで nREPL を使用するので、追加の nREPL <code>:middleware</code> を設定する必要があります。 <code>clj</code> を使用する場合は、nREPL を使用しないので、問題ありません。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="config"><a class="anchor" href="#config"></a><a class="link" href="#config">5. 設定</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>shadow-cljs</code> は、プロジェクトのルートディレクトリにある <code>shadow-cljs.edn</code> ファイルによって設定されます。デフォルトのファイルを作成するには
 <code>shadow-cljs init</code> を実行することで、デフォルトのファイルを作成することができます。このファイルには、いくつかのグローバルな設定を含むマップと
マップと、すべてのビルドのための <code>:builds</code> エントリが含まれています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:source-paths [...]
 :dependencies [...]
 :builds {...}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>設定例は以下のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:dependencies
 [[reagent "0.8.0-alpha2"]]

 :source-paths
 ["src"]

 :builds
 {:app {:target :browser
        :output-dir "public/js"
        :asset-path "/js"
        :modules {:main {:entries [my.app]}}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>この例のファイル構造は次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">.
├── package.json
├── shadow-cljs.edn
└── src
    └── my
        └── app.cljs</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="source-paths"><a class="anchor" href="#source-paths"></a><a class="link" href="#source-paths">5.1. ソースのパス</a></h3>
<div class="paragraph">
<p><code>:source-paths</code> は、JVM のクラスパスを設定します。コンパイラはこの設定を使って、Clojure(Script)のソースファイル(例： <code>.cljs</code> )を探します。</p>
</div>
<div class="paragraph">
<p>すべてを 1 つのソースパスにまとめても問題ありませんが、ソースファイルを特定の方法でグループ化したい場合は、複数のソースパスを使用することができます。例えば、テストを別々にしたい場合などに便利です。</p>
</div>
<div class="listingblock">
<div class="title">複数のソースパスの使用</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:source-paths ["src/main" "src/test"]
 ...}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">.
├── package.json
├── shadow-cljs.edn
└── src
    └── main
        └── my
            └── app.cljs
    └── test
        └── my
            └── app_test.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>ソースファイルを拡張子で分けることはお勧めしません（例：<code>src/clj</code>, <code>src/cljs</code>, <code>src/cljc</code>）。なぜか CLJS のプロジェクトテンプレートではこの方法が広く使われていますが、使いにくくなるだけです。</p>
</div>
</div>
<div class="sect2">
<h3 id="_依存関係"><a class="anchor" href="#_依存関係"></a><a class="link" href="#_依存関係">5.2. 依存関係</a></h3>
<div class="sect3">
<h4 id="_clojure_script"><a class="anchor" href="#_clojure_script"></a><a class="link" href="#_clojure_script">5.2.1. Clojure(Script)</a></h4>
<div class="paragraph">
<p>依存関係は、 <code>shadow-cljs.edn</code> 設定ファイルのルートにある <code>:dependencies</code> キーによって管理されます。これらは <code>lein</code> や <code>boot</code> のような他の Clojure ツールが使用するのと同じ記法で宣言されます。</p>
</div>
<div class="paragraph">
<p>各依存関係は <code>[ライブラリ名 "バージョン文字列"]</code> を使ったベクターとして書かれ、 1 つの外側のベクターに入れ子になっています。</p>
</div>
<div class="listingblock">
<div class="title">Example :dependencies</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:source-paths ["src"]
 :dependencies [[reagent "0.9.1"]]
 :builds ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ソースパスは設定全体で一度しか指定されていないことに注意してください。システムは名前空間の依存関係グラフを使って、どのようなコードがビルドの最終出力に必要かを判断します。</p>
</div>
</div>
<div class="sect3">
<h4 id="npm-install"><a class="anchor" href="#npm-install"></a><a class="link" href="#npm-install">5.2.2. JavaScript</a></h4>
<div class="paragraph">
<p><code>shadow-cljs</code> は、 <a href="https://www.npmjs.com/"><code>npm</code></a> エコシステムと完全に統合して、JavaScript の依存関係を管理します。</p>
</div>
<div class="paragraph">
<p>依存関係の管理には、 <code>npm</code> や <code>yarn</code> を使うことができますが、それぞれのドキュメントを参照してください。</p>
</div>
<div class="paragraph">
<p>どちらも、プロジェクトディレクトリ内の <code>package.json</code> ファイルで依存関係を管理します。 <code>npm</code> で入手できるほとんどすべてのパッケージには、そのインストール方法が説明されています。これらの説明は、現在では <code>shadow-cljs</code> にも適用されています。</p>
</div>
<div class="listingblock">
<div class="title">JavaScript パッケージのインストール</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash"># npm
$ npm install the-thing

# yarn
$ yarn add the-thing</code></pre>
</div>
</div>
<div class="paragraph">
<p>それ以上は何も必要ありません。依存関係は <code>package.json</code> ファイルに追加され、これを使って管理されます。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<code>package.json</code> がまだない場合は、コマンドラインから <code>npm init</code> を実行してください。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_js_依存関係の欠如について"><a class="anchor" href="#_js_依存関係の欠如について"></a><a class="link" href="#_js_依存関係の欠如について">JS 依存関係の欠如について</a></h5>
<div class="paragraph">
<p>JavaScript の依存関係の欠如に関連するエラーに遭遇するかもしれません。ほとんどの ClojureScript ライブラリは、使用する <code>npm</code> パッケージをまだ宣言していません。なぜなら、それらは <a href="#cljsjs">CLJSJS</a> を使用することを期待しているからです。私たちは <code>npm</code> を直接使用したいと考えています。つまり、ライブラリが適切に <code>:npm-deps</code> を宣言するまでは、 <code>npm</code> パッケージを手動でインストールする必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">The required JS dependency "react" is not available, it was required by ... (必要な JS の依存関係である "react "が利用できません。これは、 ... によって必要とされていました。)</code></pre>
</div>
</div>
<div class="paragraph">
<p>このメッセージは、 <code>npm install react</code> を行う必要があることを示しています。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<code>react</code> を利用する場合は、おそらく以下の3つのパッケージが必要です。<code>npm install react react-dom create-react-class</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="user-config"><a class="anchor" href="#user-config"></a><a class="link" href="#user-config">5.3. ユーザの設定</a></h3>
<div class="paragraph">
<p>ほとんどの設定はプロジェクト自身で <code>shadow-cljs.edn</code> を通して行われますが、いくつかの設定はユーザーに依存しているかもしれません。 <a href="https://docs.cider.mx">CIDER</a> のようなツールは、追加の <code>cider-nrepl</code> 依存関係を必要とするかもしれませんが、 <code>shadow-cljs.edn</code> 経由でその依存関係を追加しても、Cursive を使用している別のチームメンバーには意味がありません。</p>
</div>
<div class="paragraph">
<p>制限された設定オプションのセットを <code>~/.shadow-cljs/config.edn</code> に追加することで、このユーザーのマシン上でビルドされたすべてのプロジェクトに適用されます。</p>
</div>
<div class="paragraph">
<p>依存関係を追加するには、通常の <code>:dependencies</code> キーを使用します。ここで追加された依存関係は、すべてのプロジェクトに適用されることに注意してください。依存関係は最小限にして、ツール関連の依存関係だけをここに置くようにしてください。ビルドに関連するものはすべて <code>shadow-cljs.edn</code> に置いておくべきで、そうしないと他のユーザーがコンパイルできない可能性があります。これらの依存関係は、 <code>deps.edn</code> や <code>lein</code> を使用する際にも自動的に追加されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:dependencies
 [[cider/cider-nrepl "0.21.1"]]}
;; このバージョンは古くなっている可能性があります。</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>deps.edn</code> を使って依存関係を解決する際に、追加のエイリアスを有効にしたい場合があります。これは <code>:deps-aliases</code> で行うことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">;; プロジェクト内の shadow-cljs.edn
{:deps {:aliases [:cljs]}}

;; ~/.shadow-cljs/config.edn
{:deps-aliases [:cider]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、 <code>deps.edn</code> を使用しているプロジェクトでは、 <code>shadow-cljs</code> コマンドが <code>[:cider :cljs]</code> のエイリアスを使用するようになります。</p>
</div>
<div class="paragraph">
<p>これは、あなたの <code>~/.clojure/deps.edn</code> に追加の <code>:cider</code> エイリアスがある場合に便利かもしれません。</p>
</div>
<div class="paragraph">
<p>デフォルトでは、 <code>shadow-cljs</code> サーバモードでは、組み込まれた nREPL サーバが起動しますが、これは必要ないかもしれません。これを無効にするには、ユーザー設定で <code>:nrepl false</code> を設定します。</p>
</div>
<div class="paragraph">
<p>ユーザー設定で現在受け入れられている値は、<a href="#open-file-command">:open-file-command</a> のみです。他のオプションは現在のところ何の効果もありません。</p>
</div>
</div>
<div class="sect2">
<h3 id="_サーバのオプション"><a class="anchor" href="#_サーバのオプション"></a><a class="link" href="#_サーバのオプション">5.4. サーバのオプション</a></h3>
<div class="paragraph">
<p>このセクションでは、 <code>shadow-cljs</code> サーバインスタンスを構成するその他のオプションについて説明します。これらはオプションです。</p>
</div>
<div class="sect3">
<h4 id="nREPL"><a class="anchor" href="#nREPL"></a><a class="link" href="#nREPL">5.4.1. nREPL</a></h4>
<div class="paragraph">
<p><code>shadow-cljs</code> <a href="#server-mode">server</a> は <a href="https://nrepl.org">nREPL</a> サーバを TCP 経由で提供しています。起動メッセージから nREPL のポートを確認できます。nREPL のポート番号は <code>target/shadow-cljs/nrepl.port</code> に保存されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs watch app
shadow-cljs - HTTP server available at http://localhost:8600
shadow-cljs - server version: &lt;version&gt; running at http://localhost:9630
shadow-cljs - nREPL server started on port 64967
shadow-cljs - watching build :app
[:app] Configuring build.
[:app] Compiling ...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>shadow-cljs.edn</code> でポートや追加のミドルウェアを設定することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :nrepl {:port 9000
         :middleware []} ; 名前空間修飾されたシンボルのオプションリスト
 ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>~/.nrepl/nrepl.edn</code> にあるデフォルトのグローバルコンフィグファイルや、ローカルの <code>.nrepl.edn</code> も起動時に読み込まれ、<code>:middleware</code> の設定に使用できます。</p>
</div>
<div class="paragraph">
<p>人気のミドルウェア <a href="https://github.com/clojure-emacs/cider-nrepl">cider-nrepl</a> がクラスパス上にあれば（例：<code>:dependencies</code> に含まれている）、自動的に使用されます。追加の設定は必要ありません。これを無効にするには、<code>:nrepl {:cider false}</code> を設定します。</p>
</div>
<div class="paragraph">
<p><code>nrepl</code> オプションで <code>:init-ns</code> を設定することで、接続時に起動する名前空間を設定することができます。デフォルトでは <code>shadow.user</code> となります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :nrepl {:init-ns my.repl}
 ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>nREPL サーバは、<code>:nrepl false</code> を設定することで無効にすることができます。</p>
</div>
<div class="sect4">
<h5 id="_nrepl_usage"><a class="anchor" href="#_nrepl_usage"></a><a class="link" href="#_nrepl_usage">nREPL Usage</a></h5>
<div class="paragraph">
<p>nREPL サーバに接続すると、接続は常に Clojure REPL として開始されます。CLJS REPL への切り替えは、 <code>cljs-repl, non-nREPL version</code> と同様に動作します。まず、与えられたビルドの <code>watch</code> を開始する必要があり、次に現在の nREPL セッションをそのビルドに切り替えるために、このビルドを選択する必要があります。ビルドを選択すると、すべての評価は Clojure ではなく ClojureScript で行われます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-repl" data-lang="repl">(shadow/watch :the-build)
(shadow/repl :the-build)</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Clojure に戻るには <code>:cljs/quit</code> を使います。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_組み込み型_nrepl_サーバ"><a class="anchor" href="#_組み込み型_nrepl_サーバ"></a><a class="link" href="#_組み込み型_nrepl_サーバ">組み込み型 nREPL サーバ</a></h5>
<div class="paragraph">
<p>独自の nREPL サーバを提供する他のツール（例：<code>lein</code>）に <code>shadow-cljs</code> を組み込んで使用する場合は、 <code>shadow-cljs</code> ミドルウェアを設定する必要があります。そうしないと、CLJ と CLJS の REPL の間で切り替えることができません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(defproject my-amazing-project "1.0.0"
  ...
  :repl-options
  {:init-ns shadow.user ;; または、あなたが選んだもの
   :nrepl-middleware
   [shadow.cljs.devtools.server.nrepl/middleware]}
  ...)</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
CLJS REPL を使用する前に、<a href="#embedded">embedded server</a>を手動で起動する必要があります。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="socket-repl"><a class="anchor" href="#socket-repl"></a><a class="link" href="#socket-repl">5.4.2. Socket REPL</a></h4>
<div class="paragraph">
<p>Clojure Socket REPL は、サーバモードで自動的に起動され、デフォルトでランダムなポートを使用します。</p>
</div>
<div class="paragraph">
<p>ツールはポート番号を含む <code>.shadow-cljs/socket-repl.port</code> を確認することで、起動されたポートを見つけることができます。</p>
</div>
<div class="paragraph">
<p>また、 <code>shadow-cljs.edn</code> で固定のポートを設定することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :socket-repl
 {:port 9000}
 ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Socket REPL は、<code>:socket-repl false</code> を設定することで無効にすることができます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ssl"><a class="anchor" href="#_ssl"></a><a class="link" href="#_ssl">5.4.3. SSL</a></h4>
<div class="paragraph">
<p><code>shadow-cljs</code> の HTTP サーバは SSL をサポートしています。そのためには、一致する秘密鍵と証明書を提供する Java Keystore が必要です。</p>
</div>
<div class="listingblock">
<div class="title"><code>shadow-cljs.edn</code> に SSL が設定されています。</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :ssl {:keystore "ssl/keystore.jks"
       :password "shadow-cljs"}
 ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上記はデフォルトなので、これらを使用したい場合は、<code>:ssl {}</code> を設定するだけで問題ありません。</p>
</div>
<div class="paragraph">
<p>java <code>keytool</code> コマンドを使ってキーストアを作成することができます。信頼できる自己署名証明書を作成することも可能ですが、やや複雑です。</p>
</div>
<div class="paragraph">
<p>作成された <code>Certificates.p12</code> (macOS) または <code>localhost.pfx</code> (Linux, Windows) ファイルは、 <code>keytool</code> ユーティリティーを使って、必要な <code>keystore.jks</code> にすることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ keytool -importkeystore -destkeystore keystore.jks -srcstoretype PKCS12 -srckeystore localhost.pfx</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
localhost（または使用する任意のホスト）の SAN（Subject Alternative Name）を含む証明書を作成する必要があります。SAN は、Chrome が証明書を信頼して警告を表示しないようにするために必要です。エクスポート時に使用するパスワードは、キーストアに割り当てられたパスワードと一致する必要があります。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="http"><a class="anchor" href="#http"></a><a class="link" href="#http">5.4.4. Primary HTTP(S)</a></h4>
<div class="paragraph">
<p><code>shadow-cljs</code> サーバは、 1 つのプライマリ HTTP サーバを起動します。このサーバは、ホットリロードや REPL クライアントで使用される UI やウェブソケットを提供するために使用されます。デフォルトでは、9630番ポートで待ち受けます。もしそのポートが使用中であれば、 1 つ増やして、開いているポートが見つかるまで再試行します。</p>
</div>
<div class="listingblock">
<div class="title">使用するポートを示すスタートアップメッセージ</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">shadow-cljs - server running at http://0.0.0.0:9630</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ssl</code> が設定されている場合、サーバは代わりに <code>https://</code> を介して利用できます。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<code>:ssl</code> を使用すると、サーバは自動的に HTTP/2 をサポートします。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>代わりに独自のポートを設定したい場合は、<code>:http</code> の設定で行うことができます。</p>
</div>
<div class="listingblock">
<div class="title"><code>shadow-cljs.edn</code> 内の <code>:http</code> の設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :http {:port 12345
        :host "my.machine.local"}
 ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:ssl</code> は、サーバを <code>https://</code> のみに切り替えます。もし、 <code>http://</code> のバージョンを維持したい場合は、別の <code>:ssl-port</code> を設定することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :http {:port 12345
        :ssl-port 23456
        :host "localhost"}
 ...}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dev-http"><a class="anchor" href="#dev-http"></a><a class="link" href="#dev-http">5.4.5. 開発の HTTP(S)</a></h4>
<div class="paragraph">
<p><code>shadow-cljs</code> では、<code>:dev-http</code> という設定項目で、追加の基本的な HTTP サーバを提供することができます。デフォルトでは、これらは設定されたパスからすべての静的ファイルを提供し、リソースが見つからない場合は <code>index.html</code> にフォールバックします (これは、ブラウザのプッシュステートを使用するアプリケーションを開発する際に、一般的に求められるものです)。</p>
</div>
<div class="paragraph">
<p>これらのサーバは <code>shadow-cljs</code> がサーバモードで動作しているときに自動的に開始されます。これらのサーバはどのビルドにも特定されず、それぞれにユニークな <code>:output-dir</code> が使用されている限り、複数のビルドのファイルを提供するために使用することができます。</p>
</div>
<div class="paragraph">
<p>重要なことです。これらは、静的ファイルをサーバする一般的なウェブサーバです。これらはライブリロードや REPL のロジックには必要ありません。どのようなウェブサーバでも使用できますが、これらは単に利便性のために提供されています。</p>
</div>
<div class="paragraph">
<p>基本的な例では、 <code><a href="http://localhost:8000" class="bare">http://localhost:8000</a></code> を介して <code>public</code> ディレクトリを serve します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :dev-http {8000 "public"}
 :builds {...}}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:dev-http</code> は <code>port-number</code> から <code>config</code> へのマップを期待しています。この <code>config</code> は、最も一般的なシナリオに対応したいくつかのショートカットをサポートしています。</p>
</div>
<div class="listingblock">
<div class="title">ファイルシステムのルートからディレクトリを serve する</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">:dev-http {8000 "public"}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">クラスルートから serve する</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">:dev-http {8000 "classpath:public"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、クラスパス上の <code>public/index.html</code> から <code>/index.html</code> へのリクエストを見つけようとするものです。これは <code>.jar</code> ファイルの中のファイルを含む可能性があります。</p>
</div>
<div class="paragraph">
<p>複数のルートから serve する</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">:dev-http {8000 ["a" "b" "classpath:c"]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これはまず、以下の順にクラスパス上で検索を試みます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;project-root&gt;/a/index.html</code></p>
</li>
<li>
<p><code>&lt;project-root&gt;/b/index.html</code></p>
</li>
<li>
<p><code>c/index.html</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>もし何も見つからなければ、デフォルトのハンドラが呼び出されます。</p>
</div>
<div class="paragraph">
<p>長いバージョンのコンフィグでは、マップが要求され、サポートされているオプションは次のとおりです。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>:root</code> </dt>
<dd>
<p>(String) リクエストを処理するためのパスです。 <code>classpath:</code> で始まるパスは、ファイルシステムではなく、クラスパスからリクエストを処理します。すべてのファイルシステムのパスは、プロジェクトのルートからの相対パスです。</p>
</dd>
<dt class="hdlist1"><code>:roots</code> </dt>
<dd>
<p>複数のルートパスが必要な場合は、<code>:root</code> の代わりに使用します。</p>
</dd>
<dt class="hdlist1"><code>:ssl-port</code>  </dt>
<dd>
<p><code>(文字列のベクトル) ssl</code> が設定されている場合、ssl 接続にはこのポートを使用し、通常の HTTP サーバは通常のポートを使用します。 <code>ssl-port</code> が設定されておらず、<code>:ssl</code> が設定されている場合、デフォルトのポートは SSL リクエストのみをサーバします。</p>
</dd>
<dt class="hdlist1"><code>:host</code> </dt>
<dd>
<p>オプションです。listen するホストを指定します。デフォルトは localhost です。</p>
</dd>
<dt class="hdlist1"><code>:handler</code> </dt>
<dd>
<p>オプションです。完全に修飾されたシンボルです。与えられたリクエストに対してリソースが見つからない場合に使用される <code>(defn handler [req] resp)</code> です。
<code>(defn handler [req] resp)</code> は、与えられたリクエストに対してリソースが見つからない場合に使用されます。デフォルトでは <code>shadow.http.push-state/handle</code> となります。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>以下の 2 つのオプションは、デフォルトの組み込みハンドラを使用する場合にのみ適用され、通常は変更する必要はありません。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>:push-state/headers</code> </dt>
<dd>
<p>(オプション) 応答する HTTP ヘッダーのマップです。デフォルトでは、 <code>text/html</code> という標準的なヘッダーを使用します。</p>
</dd>
<dt class="hdlist1"><code>:push-state/index</code> </dt>
<dd>
<p>(オプション) サービスを提供するファイルです。デフォルトでは <code>index.html</code> が使用されます。</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :dev-http
 {8080 {:root "public"
        :handler my.app/handler}}}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="dev-http-proxy"><a class="anchor" href="#dev-http-proxy"></a><a class="link" href="#dev-http-proxy">リバースプロキシのサポート</a></h5>
<div class="paragraph">
<p>デフォルトでは、開発サーバはローカルでリクエストを処理しようとしますが、外部の Web サーバを使ってリクエストを処理したい場合もあります（例：API リクエスト）。これは <code>:proxy-url</code> で設定できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :dev-http
 {8000
  {:root "public"
   :proxy-url "https://some.host"}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><a href="http://localhost:8000/api/foo" class="bare">http://localhost:8000/api/foo</a></code> へのリクエストは、代わりに <code><a href="https://some.host/api/foo" class="bare">https://some.host/api/foo</a></code> が返すコンテンツを提供します。ローカルファイルを持たないすべてのリクエストは、プロキシされたサーバによって提供されます。</p>
</div>
<div class="paragraph">
<p>接続処理を設定するオプションは以下の通りです。</p>
</div>
<div class="dlist Horizontal">
<dl>
<dt><code>:proxy-rewrite-host-header</code> </dt>
<dd>
<p>boolean で、デフォルトは true です。オリジナルの Host ヘッダーを使用するか、<code>:proxy-url</code> からのヘッダーを使うかを決めます。上記の例では <code>localhost</code> と <code>some.host</code> のどちらを使用するかを決定します。</p>
</dd>
<dt><code>:proxy-reuse-x-forwarded</code> </dt>
<dd>
<p>boolean で、デフォルトは false です。プロキシが自分自身を <code>X-Forwarded-For</code> リストに追加するか、新しいリストを開始するかを設定します。</p>
</dd>
<dt><code>:proxy-max-connection-retries</code> </dt>
<dd>
<p>int で、デフォルトは 1 です。</p>
</dd>
<dt><code>:proxy-max-request-time</code> </dt>
<dd>
<p>int でミリ秒を表し、デフォルトは 30000(30秒のリクエストタイムアウト)です。</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jvm-opts"><a class="anchor" href="#jvm-opts"></a><a class="link" href="#jvm-opts">5.5. JVM の設定</a></h3>
<div class="paragraph">
<p>JVM の起動に <code>shadow-cljs.edn</code> を使用する場合、JVM に直接渡される追加のコマンドライン引数を設定することができます。例えば、shadow-cljs.edn が使用する RAM の量を減らしたり増やしたりしたい場合があります。</p>
</div>
<div class="paragraph">
<p>これは、 <code>shadow-cljs.edn</code> のルートに <code>:jvm-opts</code> を設定して、文字列のベクトルを期待することで行われます。</p>
</div>
<div class="listingblock">
<div class="title">Example：RAM 使用量を 1GB に制限</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:source-paths [...]
 :dependencies [...]
 :jvm-opts ["-Xmx1G"]
 :builds ...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JVM に渡すことができる引数はバージョンによって異なります。RAM の割り当てが少なすぎたり多すぎたりすると、パフォーマンスが低下することがあるので注意してください。通常はデフォルトの設定で十分です。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>deps.edn</code> や <code>project.clj</code> を使用する場合は、<code>:jvm-opts</code> を設定する必要があります。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ビルドの設定"><a class="anchor" href="#_ビルドの設定"></a><a class="link" href="#_ビルドの設定">6. ビルドの設定</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>shadow-cljs.edn</code> には、<code>:builds</code> セクションも必要です。ビルドは、ビルド ID をキーにしたビルドのマップでなければなりません。</p>
</div>
<div class="listingblock">
<div class="title">ビルドマップの設定ファイル</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:dependencies [[some-library "1.2.1"] ...]
 :source-paths ["src"]
 :builds
 {:app   {:target     :browser
          ... browser-specific options ...}
  :tests {:target :karma
          ... karma-specific options ...}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>各ビルドには、コンパイラがビルドする成果物が記述されています。ビルドターゲットは <code>shadow-cljs</code> の拡張可能な機能であり、コンパイラにはすでにかなりの数が付属しています。</p>
</div>
<div class="sect2">
<h3 id="_ビルドターゲット"><a class="anchor" href="#_ビルドターゲット"></a><a class="link" href="#_ビルドターゲット">6.1. ビルドターゲット</a></h3>
<div class="paragraph">
<p><code>shadow-cljs</code> の各ビルドでは、コードをどこで実行するかを定義する <code>:target</code> を定義する必要があります。<a href="#target-browser">browser</a> と <a href="#target-node"><code>node.js</code></a> のデフォルトのビルドインがあります。これらはすべて、<code>:dev</code> モードと <code>:release</code> モードを持つという基本的なコンセプトを共有しています。 <code>dev</code> モードでは、高速なコンパイル、ライブコードリロード、REPL など、通常の開発に必要な機能をすべて提供します。 <code>release</code> モードでは、プロダクション向けに最適化された出力が得られます。</p>
</div>
<div class="paragraph">
<p>ターゲットについては別の章で説明します。</p>
</div>
<div class="paragraph">
<p>ここでは一部をご紹介します。</p>
</div>
<div class="dlist Horizontal">
<dl>
<dt><a href="#target-browser"><code>:browser</code></a></dt>
<dd>
<p>Web ブラウザでの実行に適したコードを出力します。
<a href="#target-bootstrap"><code>:bootstrap</code></a>::ブートストラップされた cljs 環境で実行するのに適したコードを出力します。</p>
</dd>
<dt><a href="#target-browser-test"><code>:browser-test</code></a></dt>
<dd>
<p>テストをスキャンして必要なファイルを決定し、ブラウザで実行するのに適したテストを出力します。</p>
</dd>
<dt><a href="#target-karma"><code>:karma</code></a></dt>
<dd>
<p>テストをスキャンして必要なファイルを決定し、karma-runner互換のテストを出力します。 <a href="http://karma-runner.github.io/2.0/index.html">Karma</a> を参照してください。</p>
</dd>
<dt><a href="#target-node-library"><code>:node-library</code></a></dt>
<dd>
<p>ノードライブラリとして使用するのに適したコードを出力します。</p>
</dd>
<dt><a href="#target-node-script"><code>:node-script</code></a></dt>
<dd>
<p>ノードスクリプトとして使用するのに適したコードを出力します。</p>
</dd>
<dt><a href="#target-npm-module"><code>:npm-module</code></a></dt>
<dd>
<p>ノードスクリプトとしての使用に適したコードを出力します。 npm モジュールとして使用するのに適したコードを出力します。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>ターゲットを選択すると残りのビルドオプションが変わるため、ターゲットについては各々の章で詳しく説明します。</p>
</div>
</div>
<div class="sect2">
<h3 id="devtools"><a class="anchor" href="#devtools"></a><a class="link" href="#devtools">6.2. 開発オプション</a></h3>
<div class="paragraph">
<p>通常、各ビルド <code>:target</code> は複数の開発サポートを提供します。それらは各 <code>:build</code> の <code>:devtools</code> キーの下にまとめられています。</p>
</div>
<div class="sect3">
<h4 id="_repl_3"><a class="anchor" href="#_repl_3"></a><a class="link" href="#_repl_3">6.2.1. REPL</a></h4>
<div class="paragraph">
<p><code>watch</code> を実行すると、REPL用のコードが自動的に注入され、通常は追加の設定は必要ありません。 REPL の動作を制御するための追加オプションも用意されています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:repl-init-ns</code> では、REPL をどの名前空間で起動するかを設定することができます。デフォルトでは <code>cljs.user</code> となります。</p>
</li>
<li>
<p><code>repl-pprint</code> では、REPL が eval の結果を print するときに、通常の <code>pr-str</code> の代わりに <code>cljs.pprint</code> を使用します。デフォルトは false です。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app {...
        :devtools {:repl-init-ns my.app
                   :repl-pprint true
                   ...}}}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_プリロード"><a class="anchor" href="#_プリロード"></a><a class="link" href="#_プリロード">6.2.2. プリロード</a></h4>
<div class="paragraph">
<p>開発者は、そのほとんどの時間を開発モードで過ごします。おそらく、 <code>figwheel</code>、 <code>boot-reload</code>、 <code>devtools</code> などのツールに精通していることでしょう。
<code>boot-reload</code>、 <code>devtools</code> などのツールをご存知でしょう。これらのツールの 1 つ以上を自分のビルドに使用することはほぼ確実でしょう。</p>
</div>
<div class="paragraph">
<p>プリロードは、生成された Javascript の先頭に特定の名前空間を強制的に導入するために使用されます。これは一般的に、アプリケーションが実際にロードされて実行される前に、ツールやインスツルメンテーションを注入するために使用されます。preloads オプションは、 <code>shadow-cljs.edn</code> の <code>:devtools</code> / <code>:preloads</code> セクション内、または特定のモジュールの <code>:preloads</code> キー内にある名前空間の単純なリストです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app {...
        :devtools {:preloads [fulcro.inspect.preload]
                   ...}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>例えば、開発中のメインモジュール内でのみプリロードを行い、ウェブワーカーでは行わないようにするなどです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app {...
        :modules {:main {...
                         :preloads
                         [com.fulcrologic.fulcro.inspect.preload
                          com.fulcrologic.fulcro.inspect.dom-picker-preload]
                         :depends-on #{:shared}}
                  :shared {:entries []}
                  :web-worker {...
                    :depends-on #{:shared}
                    :web-worker true}}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:preloads</code> は開発用ビルドにのみ適用され、リリース用ビルドには適用されません。</p>
</div>
<div class="paragraph">
<p>注意: バージョン 2.0.130 以降の shadow-cljs は、 <code>watch</code> と <code>compile</code> のクラスパス上に <code>cljs-devtools</code> がある場合、自動的にそのプリロードに <code>cljs-devtools</code> を追加します。必要なことは、 <code>binaryage/devtools</code> があなたの <code>dependencies</code> リストにあることを確認するだけです。(注意: binaryage/cljs-devtools ではない) もし、特定のターゲットに <code>cljs-devtools</code> を入れたくない場合は、それらのターゲットの <code>:devtools</code> セクションに <code>:console-support false</code> を追加することで、これを抑制することができます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ホットコードリロード"><a class="anchor" href="#_ホットコードリロード"></a><a class="link" href="#_ホットコードリロード">6.2.3. ホットコードリロード</a></h4>
<div class="paragraph">
<p>React と ClojureScript のエコシステムを組み合わせることで、このようなことが超便利になります。 <code>shadow-cljs</code> のシステムには、外部ツールに頼ることなく、ホットコードリロードを行うために必要なものがすべて含まれています。</p>
</div>
<div class="paragraph">
<p>使うには、以下のように実行するだけです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">shadow-cljs watch build-id</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ライフサイクルフック"><a class="anchor" href="#_ライフサイクルフック"></a><a class="link" href="#_ライフサイクルフック">6.2.4. ライフサイクルフック</a></h4>
<div class="paragraph">
<p>ホットコードリロードで更新されたコードが入ってくる直前と直後に関数を実行するようにコンパイラを設定することができます。これは、古いコードの上で閉じてしまうような処理を停止/開始するのに便利です。</p>
</div>
<div class="paragraph">
<p>これらの設定は、ビルド設定の <code>:devtools</code> セクションを介して、またはメタデータタグを介してコード内で直接行うことができます。</p>
</div>
<div class="sect4">
<h5 id="_メタデータ"><a class="anchor" href="#_メタデータ"></a><a class="link" href="#_メタデータ">メタデータ</a></h5>
<div class="paragraph">
<p>通常の CLJS の <code>defn</code> 変数に特定のメタデータを設定することで、ライブリロード時にこれらの関数が特定のタイミングで呼び出されるべきであることをコンパイラに知らせることができます。</p>
</div>
<div class="listingblock">
<div class="title">メタデータを利用した hook の設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.app)

(defn ^:dev/before-load stop []
  (js/console.log "stop"))

(defn ^:dev/after-load start []
  (js/console.log "start"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、新しいコードを読み込む前に <code>my.app/stop</code> を呼び出し、新しいコードがすべて読み込まれたときに <code>my.app/start</code> を呼び出します。このように複数の関数をタグ付けすることができ、それらは名前空間の依存関係の順に呼び出されます。</p>
</div>
<div class="paragraph">
<p>また、リロード処理を行う前に完了すべき非同期処理を行う必要がある場合は、これらの非同期版もあります。</p>
</div>
<div class="listingblock">
<div class="title">async フックの例</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.app)

(defn ^:dev/before-load-async stop [done]
  (js/console.log "stop")
  (js/setTimeout
    (fn []
      (js/console.log "stop complete")
      (done)))

(defn ^:dev/after-load-async start [done]
  (js/console.log "start")
  (js/setTimeout
    (fn []
      (js/console.log "start complete")
      (done)))</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
各関数には、それぞれの作業が完了したときに呼び出されるべきコールバック関数が 1 つあります。このコールバック関数が呼び出されないと、リロード処理は進みません。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>名前空間にメタデータをタグ付けすることで、再コンパイルされても再読み込みされないようにすることが可能です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns ^:dev/once my.thing)

(js/console.warn "will only execute once")</code></pre>
</div>
</div>
<div class="paragraph">
<p>名前空間は常にリロードするようにタグ付けすることもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns ^:dev/always my.thing)

(js/console.warn "will execute on every code change")</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_設定"><a class="anchor" href="#_設定"></a><a class="link" href="#_設定">設定</a></h5>
<div class="paragraph">
<p>メタデータに加えて、ライフサイクルフックを <code>shadow-cljs.edn</code> で設定することができます。</p>
</div>
<div class="dlist Horizontal">
<dl>
<dt><code>:before-load</code> </dt>
<dd>
<p>再コンパイルされたファイルを更新する直前に実行される関数のシンボル（名前空間付き）です。
関数のシンボル（名前空間付き）です。 この関数は本質的に同期的でなければなりません。</p>
</dd>
<dt><code>:before-load-async</code> </dt>
<dd>
<p>リフレッシュする直前に実行する関数 <code>(fn [done])</code> のシンボル（名前空間付き）です。この関数は非同期処理を行うことができますが、処理が完了したことを示すために、 <code>(done)</code> を必ず*呼び出さなければなりません。</p>
</dd>
<dt><code>:after-load</code> </dt>
<dd>
<p>ホットコードのリロードが完了した後に実行する関数のシンボル(名前空間付き)です。</p>
</dd>
<dt><code>:after-load-async</code> </dt>
<dd>
<p>ホットコードのリロードが完了した後に実行される関数 <code>(fn [done])</code> のシンボル(名前空間を含む)です。この関数は非同期処理を行うことができますが、完了したことを示すために、 <code>(done)</code> を必ず呼び出さなければなりません。</p>
</dd>
<dt><code>:autoload</code> </dt>
<dd>
<p>コードをホットロードするかどうかを制御するブール値です。いずれかのコールバックが設定されると、暗黙的に <code>true</code> に設定されます。デフォルトでは <code>:browser</code> ターゲットに対して常に有効で、無効にするには <code>false</code> を設定します。</p>
</dd>
<dt><code>:deignore-warnings</code> </dt>
<dd>
<p>警告を含むコードをリロードするかどうかを制御するブール値です。デフォルトでは <code>false</code> に設定されます。</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="title">ライフサイクルフックの例</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app {...
        :devtools {:before-load  my.app/stop
                   :after-load   my.app/start
                   ...}}}}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
フックは <code>cljs.user</code> 名前空間では宣言できません。フックは、それを含む名前空間が実際にビルドに含まれている場合にのみ使用されます。追加の名前空間を使用する場合は、必ず <code>:preloads</code> でインクルードしてください。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<code>:after-load</code> や <code>:before-load</code> が設定されていない場合、コンパイラは <code>:browser</code> ターゲットのコードのホットリロードのみを試みます。もし、ホットリロードを行いたいが、コールバックが不要な場合は、代わりに <code>:autoload true</code> を設定してください。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="build-hooks"><a class="anchor" href="#build-hooks"></a><a class="link" href="#build-hooks">6.3. ビルドフック</a></h3>
<div class="paragraph">
<p>カスタムコードをコンパイルパイプラインの特定の段階で実行したい場合があります。<code>:build-hooks</code> では、どの関数を呼び出すかを宣言することができ、その関数はその時点でのビルド状態に完全にアクセスすることができます。これは非常に強力で、様々なツールのオプションが可能になります。</p>
</div>
<div class="paragraph">
<p>ビルドごとに <code>:build-hooks</code> キーで設定されます。</p>
</div>
<div class="listingblock">
<div class="title">Example :build-hooks</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app {:target ...
        :build-hooks
        [(my.util/hook 1 2 3)]
        ...}}}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example hook code</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.util)

(defn hook
  {:shadow.build/stage :flush}
  [build-state &amp; args]
  (prn [:hello-world args])
  build-state)</code></pre>
</div>
</div>
<div class="paragraph">
<p>この例では、ビルドが <code>:flush</code> <a href="#compilation-stages">stage</a> を完了した(つまりディスクに書き込まれた)後に <code>(my.util/hook build-state 1 2 3)</code> を呼び出します。この例では <code>[:hello-world (1 2 3)]</code> と表示されますが、実際のフックではもっと便利なことをしてください。</p>
</div>
<div class="paragraph">
<p>フックは通常の Clojure 関数にいくつかのメタデータを追加したものです。</p>
</div>
<div class="paragraph">
<p><code>shadow.build/stage :flush}</code> メタデータは、このフックを <code>:flush</code> でのみ呼び出すようにコンパイラに通知します。</p>
</div>
<div class="paragraph">
<p>フックが複数のステージの後に呼び出されるべきであれば、代わりに <code>{:shadow.build/stages #{:configure :flush}}</code> を設定することができます。そうしないとフックは何もしないので、少なくともひとつの設定済みステージが必要です。</p>
</div>
<div class="paragraph">
<p>すべてのビルドフックは、<code>:target</code> の作業が終わった後に呼び出されます。これらのフックは、最初の引数として <code>build-state</code> (現在のすべてのビルドデータを含む clojure マップ) を受け取り、 <strong>必ず</strong> この <code>build-state</code> を修正して、または修正しないで返します。複数のステージを使用する場合、後のステージが見ることができる追加データを <code>build-state</code> に追加することができます。誤ってビルド全体を壊してしまわないように、名前付きのキーのみを使用することを強くお勧めします。</p>
</div>
<div class="paragraph">
<p><code>build-state</code> には、フックに有用ないくつかの重要なエントリがあります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:shadow.build/build-id</code> - 現在のビルドの ID です。例： <code>:app</code></p>
</li>
<li>
<p><code>:shadow.build/mode</code> - <code>:dev</code> または <code>:release</code> です。</p>
</li>
<li>
<p><code>:shadow.build/stage</code> - 現在のステージです。</p>
</li>
<li>
<p><code>:shadow.build/config</code> - ビルドの設定。フック用の設定データは、ビルドコンフィグに直接格納するか、フック自体の引数として渡すことができます。</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>watch</code> を実行していると、すべてのフックがビルドのたびに繰り返し呼び出されます。ビルドのパフォーマンスに大きな影響を与える可能性がありますので、あまり多くの作業を行わないようにしてください。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="compile-stages"><a class="anchor" href="#compile-stages"></a><a class="link" href="#compile-stages">6.3.1. コンパイル・ステージ</a></h4>
<div class="paragraph">
<p><code>:build-hooks</code> が使用できるステージは以下の通りです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:configure</code> - 初期の <code>:target</code> 特定の設定</p>
</li>
<li>
<p><code>:compile-prepare</code> - コンパイルが行われる前に呼び出されます。</p>
</li>
<li>
<p><code>:compile-finish</code> - すべてのコンパイルが終了した後に呼び出されます。</p>
</li>
<li>
<p><code>optimize-prepare</code> - Closure Compiler の最適化フェーズを実行する前に呼び出されます (<code>:release</code> のみ)</p>
</li>
<li>
<p><code>:optime-finish</code> - Closure が終了した後に呼び出されます (<code>:release</code> のみ)</p>
</li>
<li>
<p><code>:flush</code> - すべてがディスクにフラッシュされた後に呼び出されます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>watch</code> を実行していると、 <code>:configure</code> は一度しか呼ばれません。再コンパイルのたびに、他の項目が再コンパイルのたびに（順に）呼び出されます。 <code>build-state</code> はビルドコンフィグが変更されるまで再利用され、その時点で破棄されて新しいものが作成されることになる。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_コンパイラ_キャッシュ"><a class="anchor" href="#_コンパイラ_キャッシュ"></a><a class="link" href="#_コンパイラ_キャッシュ">6.4. コンパイラ・キャッシュ</a></h3>
<div class="paragraph">
<p><code>shadow-cljs</code> はデフォルトで全てのコンパイル結果をキャッシュします。このキャッシュは、個々のソースファイルに関連する何かが変更されるたびに無効になります（例：コンパイラの設定変更、依存関係の変更など）。これにより、インクリメンタルなコンパイルはスクラッチから始めるよりも <strong>はるかに</strong> 早くなるので、開発者の経験が大幅に改善されます。</p>
</div>
<div class="paragraph">
<p>しかし、キャッシュを無効にすることは、副作用のあるマクロ（ファイルの読み込み、コンパイラの状態外での保存など）を多く使用している場合、常に確実に実行できるとは限りません。そのような場合には、キャッシュを完全に無効にする必要があります。</p>
</div>
<div class="paragraph">
<p>副作用のあるマクロが含まれていることがわかっている名前空間は、キャッシュからブロックすることができます。その名前空間自体はキャッシュされず、それを必要とする名前空間もキャッシュされません。 <a href="https://github.com/cerner/clara-rules">clara-rules</a> ライブラリには副作用のあるマクロが含まれており、デフォルトでブロックされます。どの名前空間をグローバルにブロックするかは、<code>:cache-blockers</code> 設定で指定できます。この設定には、名前空間のシンボルのセットが必要です。</p>
</div>
<div class="listingblock">
<div class="title">clara.rules のキャッシュブロックの例（これはデフォルトで行われます)</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :cache-blockers #{clara.rules}
 :builds {...}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>さらに、<code>:build-options</code> <code>:cache-level</code> エントリーを使って、どの程度のキャッシングが行われるかをより広範囲に渡ってコントロールすることができます。サポートされているオプションは次のとおりです。</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>:all</code> 
</td>
<td class="hdlist2">
<p>デフォルトでは、すべての CLJS ファイルがキャッシュされます。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:jars</code> 
</td>
<td class="hdlist2">
<p>ライブラリからのファイル、つまり <code>.jar</code> ファイル内のソースファイルのみをキャッシュします。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:off</code> 
</td>
<td class="hdlist2">
<p>CLJS のコンパイル結果を一切キャッシュしません（圧倒的に遅いオプションです）。</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">キャッシュを使わずにコンパイルする</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   ...
   :build-options
   {:cache-level :off}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>キャッシュファイルは、ビルドごとに専用のディレクトリに保存されるので、ビルド間でキャッシュが共有されることはありません。 id が <code>:app</code> のビルドには、<code>:dev</code> のキャッシュがディレクトリに格納されます。</p>
</div>
<div class="listingblock">
<div class="title">cljs/core.cljs のキャッシュ場所</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">target/shadow-cljs/builds/app/dev/ana/cljs/core.cljs.cache.transit.json</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:cache-root</code> の設定は、デフォルトでは <code>target/shadow-cljs</code> となり、すべてのキャッシュファイルがどこに書き込まれるかを制御します。これはグローバルにのみ設定可能で、ビルドごとに設定することはできません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:source-paths [...]
 :dependencies [...]
 :cache-root ".shadow-cljs"
 :builds ...}

;; キャッシュは、.shadow-cljs/builds/app/dev/ana/cljs/core.cljs.cache.transit.json になります。</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、<code>:cache-root</code> は常にプロジェクトディレクトリからの相対パスで指定します。絶対パスを指定することもできます (例: <code>/tmp/shadow-cljs</code>)。</p>
</div>
</div>
<div class="sect2">
<h3 id="closure-defines"><a class="anchor" href="#closure-defines"></a><a class="link" href="#closure-defines">6.5. Closure の定義</a></h3>
<div class="paragraph">
<p>Closure Library と Compiler では、基本的にコンパイル時の定数である変数を定義することができます。これを使って、ビルドの特定の機能を設定することができます。 Closure コンパイラは、<code>:advanced</code> 最適化を実行する際にこれらを定数として扱うため、Dead-Code-Elimination パスが完全にサポートされており、 <code>release</code> ビルドに含めるべきではないコードの特定の部分を削除するために使用することができます。</p>
</div>
<div class="paragraph">
<p>コードの中で定義することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns your.app)

(goog-define VERBOSE false)

(when VERBOSE
  (println "Hello World"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、 <code>your.app/VERBOSE</code> 変数がデフォルトで <code>false</code> と定義されます。これにより、<code>:advanced</code> のコンパイル時に <code>println</code> が削除されます。これを <code>:closure-defines</code> オプションで <code>true</code> に変更すると、 <code>println</code> が有効になります。これは、開発時のみ、または常に行うことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   ...
   :modules {:app {:entries [your.app]}}
   ;; 開発時のみ有効
   :dev {:closure-defines {your.app/VERBOSE true}}
   ;; 常に有効にする
   :closure-defines {your.app/VERBOSE true}
   ;; リリース時の有効化も可能
   :release {:closure-defines {your.app/VERBOSE true}}
   }}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
一般的には、disabled バリアントをデフォルトで使用する方が安全です。なぜなら、release ビルドに含まれるべきでないものが含まれる可能性が低くなるからです。また、<code>:closure-defines</code> 変数の設定を忘れると、ほとんどの場合、使用されるコードが増えるのではなく、減ることになります。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Closure Library の Closure 定義</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>goog.DEBUG</code> です。Closure Library では、多くの開発機能でこれを使用しています。 <code>shadow-cljs</code> は、 <code>release</code> のビルドでは、自動的にこれを <code>false</code> に設定します。</p>
</li>
<li>
<p><code>goog.LOCALE</code> : <code>goog.i18n.DateTimeFormat</code> のような、ある種のローカリゼーション機能を設定するために使用されます。これは標準的なロケール文字列を受け入れ、デフォルトでは <code>en</code> となります。ほとんどすべてのロケールがサポートされています。 <a href="https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbols.js">こちら</a> と <a href="https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbolsext.js">こちら</a> を参照してください。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="compiler-options"><a class="anchor" href="#compiler-options"></a><a class="link" href="#compiler-options">6.6. コンパイラのオプション</a></h3>
<div class="paragraph">
<p>CLJS コンパイラは、コードの生成方法に影響を与えるいくつかのオプションをサポートしています。ほとんどの場合、 <code>shadow-cljs</code> は各 <code>:target</code> に対して良いデフォルトを選んでくれますが、時折それらのいくつかを変更したいと思うかもしれません。</p>
</div>
<div class="paragraph">
<p>これらはすべて、ビルド設定の <code>:compiler-options</code> キーにまとめられています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:dependencies [...]
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:fn-invoke-direct true}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>標準的な ClojureScript <a href="https://clojurescript.org/reference/compiler-options">Compiler Options</a>のほとんどは、デフォルトで有効になっているか、適用されていません。そのため、実際に効果があるものはほとんどありません。また、多くのオプションは特定の <code>:target</code> タイプに固有のもので、普遍的に適用されるわけではありません (例えば、<code>:compiler-options {:output-wrapper true}</code> は <code>:target :browser</code> にのみ関係します)。</p>
</div>
<div class="paragraph">
<p>現在サポートされているオプションは以下の通りです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:optimizations</code> は <code>:advanced</code>, <code>:simple</code>, <code>:whitespace</code> のいずれかをサポートしていますが、デフォルトは <code>:advanced</code> です。 <code>none</code> は開発時のデフォルトで、手動で設定することはできません。 <code>none</code> を指定した <code>release</code> は動作しません。</p>
</li>
<li>
<p><code>:infer-externs</code> <code>:all</code>, <code>:auto</code>, <code>true</code> または <code>false</code>, デフォルトは <code>true</code> です。</p>
</li>
<li>
<p><code>:static-fns</code> (ブール値) デフォルトでは <code>true</code> です。</p>
</li>
<li>
<p><code>:fn-invoke-direct</code> (Boolean) デフォルトは <code>false</code> です。</p>
</li>
<li>
<p><code>:ide-asserts</code> (Boolean) のデフォルトは、開発版では <code>false</code> 、 <code>release</code> ビルドでは <code>true</code> です。</p>
</li>
<li>
<p><code>:pretty-print</code> と <code>:pseudo-names</code> はデフォルトで <code>false</code> になります。 <code>shadow-cljs release app --debug</code> を使用すると、設定に手を加えることなく、一時的に両方を有効にすることができます。これは <code>release</code> のビルドで問題が発生したときにとても便利です。</p>
</li>
<li>
<p><code>:source-map</code> (Boolean) 開発中のデフォルトは <code>true</code> で、 <code>release</code> では <code>false</code> です。</p>
</li>
<li>
<p><code>:source-map-include-sources-content</code> (Boolean) デフォルトは <code>true</code> で、ソースマップが <code>.map</code> ファイルに直接ソースを含めるかどうかを決定します。</p>
</li>
<li>
<p><code>:source-map-detail-level</code> <code>:all</code> または <code>:symbols</code> (<code>:symbols</code> は全体のサイズを少し小さくしますが、精度も少し低くなります)</p>
</li>
<li>
<p><code>:externs</code> パスのベクトル、デフォルトでは <code>[]</code> です。</p>
</li>
<li>
<p><code>:checked-arrays</code> (Boolean), デフォルトは <code>false</code> です。</p>
</li>
<li>
<p><code>:anon-fn-naming-policy</code> (論理値)</p>
</li>
<li>
<p><code>:rename-prefix</code> と <code>:rename-prefix-namespace</code> の対応表です。</p>
</li>
<li>
<p>例えば、<code>:warnings {:undeclared-var false}</code> とすると、特定の警告を消すことができます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>サポートされていない、または適用されていないオプション、</p>
</div>
<div class="paragraph">
<p>全く効果がない選択肢は、以下の通りです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:verbose</code> は、 <code>shadow-cljs compile app --verbose</code> を実行することで制御されますが、ビルド設定にはありません。</p>
</li>
<li>
<p><code>:foreign-libs</code> と <code>:libs</code> です。</p>
</li>
<li>
<p><code>:stable-names</code> は常に有効で、無効にすることはできません。</p>
</li>
<li>
<p><code>:install-deps</code></p>
</li>
<li>
<p><code>:source-map-path</code>, <code>:source-asset-path</code>, <code>:source-map-timestamp</code> です。</p>
</li>
<li>
<p><code>:cache-analysis</code> 常に有効で、無効にすることはできません。</p>
</li>
<li>
<p><code>:recompile-dependents</code> (再コンパイル依存)</p>
</li>
<li>
<p><code>:preamble</code></p>
</li>
<li>
<p><code>:hashbang</code> (<code>:node-script</code> ターゲットはこれをサポートしていますが、他のターゲットはサポートしていません)</p>
</li>
<li>
<p><code>:compiler-stats</code> 詳細な情報を得るには、代わりに <code>--verbose</code> を使用してください。</p>
</li>
<li>
<p><code>:optimize-constants</code> は <code>release</code> のビルドでは常に行われ、無効にはできません。</p>
</li>
<li>
<p><code>:parallel-build</code> は常に有効です。</p>
</li>
<li>
<p><code>:aot-cache</code></p>
</li>
<li>
<p><code>:package-json-resolution</code> 代わりに <a href="#js-resolve">:js-options :resolve</a> を参照してください。</p>
</li>
<li>
<p><code>:watch-fn</code></p>
</li>
<li>
<p><code>:process-shim</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="warnigs-as-errors"><a class="anchor" href="#warnigs-as-errors"></a><a class="link" href="#warnigs-as-errors">6.6.1. エラーとしての警告</a></h4>
<div class="paragraph">
<p>ビルドを続行するのではなく、警告を表示してビルドを失敗させたい場合があります（例：CI 環境など）。 <code>warnings-as-errors</code> コンパイラオプションを使って、その処理方法をカスタマイズすることができます。</p>
</div>
<div class="listingblock">
<div class="title">すべての警告をエラーとして扱う</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {...
   :compiler-options {:warnings-as-errors true}}}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">特定の警告のみを表示する</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {...
   :compiler-options {:warnings-as-errors #{:undeclared-var}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可能な警告タイプのキーワードのセットは、 <a href="https://github.com/clojure/clojurescript/blob/5ad96a8b3ae2e3616a19715ba9ba2471a36933a2/src/main/clojure/cljs/analyzer.cljc#L124-L163">https://github.com/clojure/clojurescript/blob/5ad96a8b3ae2e3616a19715ba9ba2471a36933a2/src/main/clojure/cljs/analyzer.cljc#L124-L163</a> にあります。</p>
</div>
<div class="listingblock">
<div class="title">特定の名前空間にのみエラーを投げる</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {...
   :compiler-options {:warnings-as-errors {:ignore #{some.ns some.library.*}
                                           :warnings-types #{:undeclared-var}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ignore</code> には、名前空間を参照するシンボルのセットを指定します。直接マッチするか、または <code>.*</code> のワイルドカードを使用することができます。<code>:warning-types</code> は上記と同じ機能を持っています。これを指定しないと、無視された名前空間以外のすべての警告がスローされます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_出力言語オプション"><a class="anchor" href="#_出力言語オプション"></a><a class="link" href="#_出力言語オプション">6.7. 出力言語オプション</a></h3>
<div class="paragraph">
<p>デフォルトでは、生成される JS の出力は ES5と互換性があり、すべての新しい機能はポリフィルを使用して互換性のあるコードに変換されます。これは現在のところ最も安全なデフォルトであり、現在使用されているほとんどのブラウザ（IE10+を含む）をサポートしています。</p>
</div>
<div class="paragraph">
<p>よりモダンな環境にのみ関心があり、置換せずに元のコードを維持したい場合は、他の出力オプションを選択することができます（例：<code>node</code>、Chrome Extensions、&#8230;&#8203;）。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
これは主に<a href="#npm">npm</a>からインポートされた JS コードや<a href="#classpath-js">classpath</a>からの <code>.js</code> ファイルに影響することに注意してください。 CLJS は現在、ES5 の出力のみを生成し、より高いオプションを設定しても影響を受けません。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>これは <code>:compiler-options</code> の <code>:output-feature-set</code> で設定できます。古い <code>:language-out</code> オプションは <code>:output-feature-set</code> に置き換わるので、使用しないでください。</p>
</div>
<div class="paragraph">
<p>サポートされているオプションは以下の通りです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:es3</code></p>
</li>
<li>
<p><code>:es5</code> - <code>class</code>, <code>const</code>, <code>let</code>, &#8230;&#8203;</p>
</li>
<li>
<p><code>:es6</code> - <code>class</code>, <code>const</code>, <code>let</code>, &#8230;&#8203;</p>
</li>
<li>
<p><code>:es7</code> - 指数演算子 <code>**</code> 。</p>
</li>
<li>
<p><code>:es8</code> - <code>async/await</code>, <code>generators</code>, スプレッド付きオブジェクトリテラル, &#8230;&#8203;</p>
</li>
<li>
<p><code>es-next</code> - Closure コンパイラが現在サポートしているすべての機能です。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:script
  {:target :node-script
   :main foo.bar/main
   ...
   :compiler-options {:output-feature-set :es7}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これらのオプションに関するドキュメントは少し少なく、ほとんどがコード <a href="https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java">こちら</a> に記載されています。</p>
</div>
</div>
<div class="sect2">
<h3 id="_conditional_reading"><a class="anchor" href="#_conditional_reading"></a><a class="link" href="#_conditional_reading">6.8. Conditional Reading</a></h3>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Conditional Reading は <code>shadow-cljs</code> でしか動作しません。この機能は ClojureScript プロジェクトで公式に <a href="https://dev.clojure.org/jira/browse/CLJS-2396">rejected</a> されました。 CLJS でもコンパイルは可能ですが、公式のブランチでのみ動作します(例: <code>:cljs</code>)。いつかは <a href="https://groups.google.com/d/msg/clojure-dev/8YJJM8lJuQs/hR5_vUZPCQAJ">support</a> になるかもしれませんが、今のところはそうではありません。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>shadow-cljs</code> では、 <code>.cljc</code> ファイルに追加のリーダ機能を設定することができます。デフォルトでは、リーダの条件式を使用して、<code>:clj</code>、<code>:cljs</code>、または <code>:cljr</code> 用の個別のコードを生成することしかできません。</p>
</div>
<div class="paragraph">
<p>しかし、多くの CLJS のビルドでは、<code>:target</code> に基づいて、どのコードを生成するかを選択することも望ましいことです。</p>
</div>
<div class="paragraph">
<p>例 一部の <code>npm</code> パッケージは <code>:browser</code> をターゲットにしたときにのみ動作しますが、<code>:node-script</code> のビルドでも使用したい <code>ns</code> があるかもしれません。</p>
</div>
<div class="paragraph">
<p>これは、React アプリでサーバサイドレンダリング(SSR)を使おうとしているときに頻繁に起こるかもしれません。 <code>codemirror</code> はそのようなパッケージの一つです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.awesome.component
  (:require
    ["react" :as react]
    ["codemirror" :as CodeMirror]))

;; React :ref に CodeMirror のインスタンスを作成する場合
(defn init-cm [dom-node]
  (let [cm (CodeMirror/fromTextArea dom-node #js {...})]
    ...))

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>この名前空間は、両方のビルド( <code>:node-script</code> と <code>:browser</code> )で正常にコンパイルされますが、<code>:node-script</code> を実行しようとすると、 <code>codemirror</code> パッケージが DOM にアクセスしようとするため、失敗します。 <code>react-dom/server</code> は refs を使用しないので、 <code>init-cm</code> 関数が呼び出されることはありません。</p>
</div>
<div class="paragraph">
<p><a href="#closure-defines">:closure-defines</a> を使って条件付きで <code>init-cm</code> fn をコンパイルすることはできますが、余分な <code>:require</code> を取り除くために使うことはできません。リーダの条件式を使えば、これが簡単にできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.awesome.component
 (:require
   ["react" :as react]
   ;; 注：ここでの順序は重要です。
   ;; 適用可能な最初のブランチのみが使用されます。
   ;; もし :cljs が最初に使用されたとしても、
   ;; それは :server build に引き継がれます。
   #?@(:node [[]]
       :cljs [["codemirror" :as CodeMirror]])))

#?(:node ;; Node プラットフォームのオーバーライド
   (defn init-cm [dom-node]
    :no-op)
   :cljs ;; デフォルトの処理系
   (defn init-cm [dom-node]
     ... actual impl ...))

...</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><code>:reader-features</code> 設定例</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 ;; アプリのビルドが正常に設定されており、調整は不要
 {:app
  {:target :browser
   ...}
  ;; サーバには :node reader の機能が追加される
  ;; デフォルトの :cljs の代わりに使用される
  :server
  {:target :node-script
   :compiler-options
   {:reader-features #{:node}}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、<code>:server</code> のビルドには <code>codemirror</code> の必要性がなくなり、 <code>init-cm</code> の機能も削除されます。以下のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.awesome.component
  (:require
    ["react" :as react]))

;; 実際にどこにも呼び出されなければ、
;; 以下はデッドコードとして削除されます。

(defn init-cm [dom-node] :no-op)
...</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
この機能は、 <code>.cljc</code> ファイルでのみ利用可能で、 <code>.cljs</code> ファイルでは失敗します。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="config-merge"><a class="anchor" href="#config-merge"></a><a class="link" href="#config-merge">6.9. CLI からのオーバーライド</a></h3>
<div class="paragraph">
<p><code>shadow-cljs.edn</code> の設定に静的に追加できない値や、環境によって変わる可能性のある値を使って、コマンドラインからビルド構成を少しずつ調整したい場合があります。</p>
</div>
<div class="paragraph">
<p>追加の設定データを <code>--config-merge {:some "data"}</code> コマンドラインオプションで渡すことができ、ビルド時の設定にマージされます。 CLI から追加されたデータは、 <code>shadow-cljs.edn</code> ファイルからのデータよりも優先されます。</p>
</div>
<div class="listingblock">
<div class="title">Example <code>shadow-cljs.edn</code> の設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   ...}}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">CLI からの <code>:output-dir</code> をオーバーライドする</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs release app --config-merge '{:output-dir "somewhere/else"}'</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">CLI からの <code>:closure-defines</code> をオーバーライドする</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs release app --config-merge '{:closure-defines {your.app/DEBUG true}}'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>--config-merge</code> は 1 つの EDN マップを想定していますが、複数回使用することができ、左から右に向かってマージされます。追加されたデータは build-hooks でも確認できます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
複数のビルド ID を指定した場合、データは指定したすべてのビルドにマージされます。<code>shadow-cljs release frontend backend --config-merge '{:hello "world"}'</code> を指定すると、両方に適用されます。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="shadow-env"><a class="anchor" href="#shadow-env"></a><a class="link" href="#shadow-env">6.10. 環境変数の使用</a></h3>
<div class="paragraph">
<p>環境変数を使って <code>shadow-cljs.edn</code> の設定値を設定することは可能ですが、代わりに <code>--config-merge</code> の使用を検討すべきです。どうしても環境変数を使わなければならない場合は、 <code>#shadow/env "FOO"</code> というリーダタグを使って設定することができます。また、より短い <code>#env</code> も使用できます。</p>
</div>
<div class="listingblock">
<div class="title">Example <code>shadow-cljs.edn</code> の設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   :closure-defines {your.app/URL #shadow/env "APP_URL"}
   ...}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、 <code>#shadow/env</code> を使用できるサポートされたフォームもいくつかあります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">#shadow/env "APP_URL"
#shadow/env ["APP_URL"]
;; デフォルトの値で、env 変数が設定されていない場合に使用される
#shadow/env ["APP_URL" "default-value"]
#shadow/env ["APP_URL" :default "default-value"]
;; PORT env をデフォルトで整数に変換する
#shadow/env ["PORT" :as :int :default 8080]</code></pre>
</div>
</div>
<div class="paragraph">
<p>サポートされている <code>:as</code> の強制は <code>:int</code>, <code>:bool</code>, <code>:keyword</code>, <code>:symbol</code> です。与えられた <code>:default</code> の値は変換されず、すでに正しい型になっていることが期待されます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>shadow-cljs</code> プロセスが開始されたときに使用された環境変数が使用されます。サーバプロセスが使用されている場合、その環境変数は他のコマンドで設定されたものよりも優先して使用されます。これは主に開発中に関係することですが、混乱を招くかもしれません。また、 <code>--config-merge</code> にはこのような制限はありません。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="build-target-defaults"><a class="anchor" href="#build-target-defaults"></a><a class="link" href="#build-target-defaults">6.11. ビルドとターゲットのデフォルト</a></h3>
<div class="paragraph">
<p>すべてのビルド、または特定のタイプのすべてのターゲットに使用されるデフォルトの設定を使用することができます。</p>
</div>
<div class="paragraph">
<p>設定のマージ順序は以下の通りです。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>:build-defaults</code></p>
</li>
<li>
<p><code>:target-defaults</code></p>
</li>
<li>
<p>実際のビルドコンフィグ</p>
</li>
<li>
<p>追加の設定によるオーバーライド</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Example <code>shadow-cljs.edn</code> の設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :build-defaults
 {:closure-defines
   {your.app/VERBOSE true}}

 :target-defaults
 {:browser
   {:js-options
     {:resolve {"react" {:target :global
                         :global "React"}}}}}

 :builds
 {:app
  {:target :browser
   ...}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>この例では、<code>:app</code> ターゲットは、<code>:build-defaults</code> と <code>:browser</code> の <code>:target-defaults</code> の両方を継承します。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
マージ順で後の方の設定は、前の設定項目を上書きすることはできても、削除することはできません。いったんデフォルトが設定されると、それを削除するにはオーバーライドするしかありません。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="target-browser"><a class="anchor" href="#target-browser"></a><a class="link" href="#target-browser">7. ブラウザを対象とする</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>:browser</code> ターゲットは、ブラウザ環境での実行を想定した出力を行います。開発時には、ライブコードリロード、REPL 、CSS リロードをサポートします。 <code>release</code> の出力は、Closure Compiler によって <code>:advanced</code> の最適化でミニマイズされます。</p>
</div>
<div class="paragraph">
<p>基本的なブラウザの設定は以下のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:dependencies [...]
 :source-paths [...]

 :builds
 {:app {:target :browser
        :output-dir "public/assets/app/js"
        :asset-path "/assets/app/js"
        :modules {:main {:entries [my.app]}}}}}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_出力設定"><a class="anchor" href="#_出力設定"></a><a class="link" href="#_出力設定">7.1. 出力設定</a></h3>
<div class="paragraph">
<p>ブラウザのターゲットは多くのファイルを出力し、それらすべてのためのディレクトリが必要となります。これらのアセットを何らかのサーバで提供する必要があり、Javascript のロードコードは、これらのアセットへのサーバ中心のパスを知る必要があります。指定する必要のあるオプションは以下の通りです。</p>
</div>
<div class="dlist Horizontal">
<dl>
<dt><code>:output-dir</code> </dt>
<dd>
<p>コンパイラのすべての出力に使用するディレクトリです。</p>
</dd>
<dt><code>:asset-path</code> </dt>
<dd>
<p>Web サーバのルートから <code>:output-dir</code> にあるリソースへの相対パスです。</p>
</dd>
</dl>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
各ビルドにはそれぞれ :output-dir が必要で、複数のビルドを同じディレクトリに置くことはできません。
また、このディレクトリは、そのビルドが独占的に所有するものでなければなりません。そこには他のファイルがあってはいけません。
<code>shadow-cljs</code> は何も削除しませんが、そのままにしておいた方が安全です。コンパイルでは、ソースマップ、オリジナルソース、生成ソースなど、開発中のメインエントリーポイントの javascript ファイル以外にも多くのファイルが作成されます。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>:asset-path</code> は、生成された javascript の中のモジュール読み込みコードのパスに追加されるプレフィックスです。これにより、javascript モジュールを Web サーバーのルートの特定のサブディレクトリに出力することができます。動的な読み込み（開発時のホットコードリロードや運用時のコード分​​割）では、ファイルを正しく配置するためにこれが必要です。</p>
</div>
<div class="paragraph">
<p>このように、生成したファイルをディレクトリやアセットパスに配置することで、他のアセット（画像やCSSなど）が同じサーバー上で不用意に衝突することなく共存できるようになります。</p>
</div>
<div class="paragraph">
<p>例えば、<code>/x</code> というURIを求められたときに、Webサーバーが <code>public/x</code> というフォルダを提供し、モジュールの <code>output-dir</code> が <code>public/assets/app/js</code> である場合、アセットパスは <code>/assets/app/js</code> となります。
アセットパスの絶対指定は必須ではありませんが、強く推奨します。</p>
</div>
</div>
<div class="sect2">
<h3 id="_モジュール"><a class="anchor" href="#_モジュール"></a><a class="link" href="#_モジュール">7.2. モジュール</a></h3>
<div class="paragraph">
<p>モジュールは、コンパイルされたソースがどのように束ねられ、最終的な <code>.js</code> がどのように生成されるかを設定します。各モジュールは、エントリーネームスペースのリストを宣言し、そこから依存関係グラフを構築します。複数のモジュールを使用する場合は、最大量のコードがグラフの外縁に移動するようにコードが分割されます。その目的は、ブラウザが最初に読み込むコードの量を最小限にし、残りのコードをオンデマンドで読み込むことです。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
最初は :module を気にしすぎないこと。最初は 1 つにしておいて、後で分割するようにしましょう。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>コンフィグの <code>:modules</code> セクションは、常にモジュール ID をキーとしたマップです。モジュールIDは、Javascript のファイル名を生成する際にも使用されます。
モジュール <code>:main</code> は <code>:output-dir</code> に <code>main.js</code> を生成します。</p>
</div>
<div class="paragraph">
<p>1つのモジュールで利用できるオプションは以下の通りです。</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>:entries</code> 
</td>
<td class="hdlist2">
<p>このモジュールの出力コードの依存関係グラフのルートノードとして機能する名前空間です。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:init-fn</code> 
</td>
<td class="hdlist2">
<p>モジュールが最初にロードされたときに呼び出されるべき関数を指し示す完全修飾シンボルです。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:depends-on</code> 
</td>
<td class="hdlist2">
<p>このモジュールが必要とするものをすべて備えるために、ロードされなければならない他のモジュールの名前です。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:prepend</code> 
</td>
<td class="hdlist2">
<p>JS の出力の前に付加される文字列コンテンツです。コメントや著作権表示などに便利です。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:append</code> 
</td>
<td class="hdlist2">
<p>JS の出力に追加される文字列コンテンツです。コメントや著作権表示などに便利です。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:prepend-js</code> 
</td>
<td class="hdlist2">
<p>Closure オプティマイザーで実行される、有効な javascript をモジュールの出力に追加する文字列です。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:append-js</code> 
</td>
<td class="hdlist2">
<p>Closure オプティマイザーで実行される有効な javascript をモジュールの出力に追加する文字列です。</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下の例では、最小のモジュール構成を示しています:</p>
</div>
<div class="listingblock">
<div class="title">Example :browser config</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app {:target :browser
        :output-dir "public/js"
        ...
        :modules {:main {:entries [my.app]}}}}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example :init-fn によるブラウザ設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app {:target :browser
        :output-dir "public/js"
        ...
        :modules {:main {:init-fn my.app/init}}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>shadow-cljs</code> は、<code>:entries</code> にあるコードエントリポイントのルートセットから依存関係グラフをたどり、実際にコンパイルして出力に含めるために必要なものをすべて見つけます。必要とされない名前空間は含まれません。</p>
</div>
<div class="paragraph">
<p>上記の設定により、<code>public/js/main.js</code> というファイルが作成されます。開発段階では、多くのファイルが格納された <code>public/js/cljs-runtime</code> ディレクトリが追加されます。このディレクトリは <code>release</code> のビルドでは必要ありません。</p>
</div>
</div>
<div class="sect2">
<h3 id="CodeSplitting"><a class="anchor" href="#CodeSplitting"></a><a class="link" href="#CodeSplitting">7.3. コードスプリッティング</a></h3>
<div class="paragraph">
<p>複数のモジュールを宣言すると、モジュール同士がどのように関連しているか、また後でどのようにロードするかをコンパイラが把握できるように、ほんの少しだけ静的な設定を追加する必要があります。</p>
</div>
<div class="paragraph">
<p><code>entries</code> に加えて、どのモジュールがどのモジュールに依存しているか（ <code>:depend-on</code> で）を宣言する必要があります。これをどのように構成するかはニーズ次第で、残念ながら万能のソリューションはありません。</p>
</div>
<div class="paragraph">
<p>例えば、従来の Web サイトでは、さまざまなページがあります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>www.acme.com</code> - ホームページを表示します。</p>
</li>
<li>
<p><code>www.acme.com/login</code> - ログインフォームを提供します。</p>
</li>
<li>
<p><code>www.acme.com/protected</code> - ユーザーがログインしないと利用できない保護されたセクション</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>このような場合には、すべてのページで共有される共通のモジュールを 1 つ用意するのが良いでしょう。そして、各ページごとに 1 つのモジュールを用意します。</p>
</div>
<div class="listingblock">
<div class="title">Example 複数の <code>:modules</code> をもつ設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :output-dir "public/js"
 :modules
 {:shared
  {:entries [my.app.common]}
  :home
  {:entries [my.app.home]
   :depends-on #{:shared}}
  :login
  {:entries [my.app.login]
   :depends-on #{:shared}}
  :protected
  {:entries [my.app.protected]
   :depends-on #{:shared}}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<code>:shared</code> モジュールの <code>:entries</code> を空にすることで、どの名前空間が他のモジュールと共有されているかをコンパイラに把握させることができます。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">生成されたファイル構造</div>
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">.
└── public
    └── js
        ├── shared.js
        ├── home.js
        ├── login.js
        └── protected.js</code></pre>
</div>
</div>
<div class="paragraph">
<p>ホームページの HTML には、各ページに必ず shared.js を記述し、他のページはユーザーがどのページにいるかに応じて条件付きで記述することになります。</p>
</div>
<div class="listingblock">
<div class="title">ログインページの HTML</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;script src="/js/shared.js"&gt;&lt;/script&gt;
&lt;script src="/js/login.js"&gt;&lt;/script&gt;</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>.js</code> ファイルは正しい順序でインクルードする必要があります。これには <code>manifest.edn</code> が役立ちます。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_動的にコードを読み込む"><a class="anchor" href="#_動的にコードを読み込む"></a><a class="link" href="#_動的にコードを読み込む">7.3.1. 動的にコードを読み込む</a></h4>
<div class="paragraph">
<p>最近、シングルページアプリ（SPA）が人気を集めていますが、その仕組みは、どの JS を組み込むかをサーバが決めるのではなく、クライアントが自分で決めるという点で似ています。</p>
</div>
<div class="sect4">
<h5 id="_shadow_cljs_に組み込まれた_loader_support_の使用"><a class="anchor" href="#_shadow_cljs_に組み込まれた_loader_support_の使用"></a><a class="link" href="#_shadow_cljs_に組み込まれた_loader_support_の使用">shadow-cljs に組み込まれた Loader Support の使用</a></h5>
<div class="paragraph">
<p>コンパイラは、 <code>shadow.loader</code> ユーティリティー名前空間の使用に必要なデータの生成をサポートしています。これは、実行時にオンデマンドでモジュールをロードするためのシンプルなインターフェイスを公開しています。</p>
</div>
<div class="paragraph">
<p>ビルド設定に <code>:module-loader true</code> を追加するだけでいいのです。ローダーは常にデフォルトのモジュール（他のすべてが依存するモジュール）に注入されます。</p>
</div>
<div class="paragraph">
<p>実行時には <code>shadow.loader</code> 名前空間を使ってモジュールをロードすることができます。また、ページ内で <code>&lt;script&gt;</code> タグを使用することで、モジュールをイーガーリーにロードすることもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
   {:app
     {:target :browser
      ...
      :module-loader true
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>メインのエントリーポイントに以下のようなものがあったとします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.app
  (:require [shadow.loader :as loader]))

(defn fn-to-call-on-load []
  (js/console.log "extra loaded"))

(defn fn-to-call-on-error []
  (js/console.log "extra load failed"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>そうすると、コードの読み込みに以下のような表現が使えるようになります。</p>
</div>
<div class="listingblock">
<div class="title">モジュールの読み込み</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">;; load は goog.async.Deferred を返し、promise のように使うことができます
(-&gt; (loader/load "extra")
    (.then fn-to-call-on-load fn-to-call-on-error))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">多数のモジュールの読み込み</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">;; JS配列でなければならず、goog.async.Deferred も返します。
(loader/load-many #js ["foo" "bar"])</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">コールバックを含める場合</div>
<p>モジュールがロードされているかどうかは、 <code>(loaded? "module-name")</code> で確認できます。</p>
</div>
<div class="sect5">
<h6 id="_ローダーのコスト"><a class="anchor" href="#_ローダーのコスト"></a><a class="link" href="#_ローダーのコスト">ローダーのコスト</a></h6>
<div class="paragraph">
<p>ローダーの使用は非常に軽量です。ローダーにはいくつかの依存関係がありますが、他に使用することはないでしょう。実際には、<code>:module-loader true</code> を使用すると、デフォルトのモジュールに約8KB の gzip が追加されます。これは、すでに使用している <code>goog.net</code> や <code>goog.events</code> の量や、リリースビルドでどの程度の最適化を行っているかによって変わってきます。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_標準的な_clojurescript_api_の使用"><a class="anchor" href="#_標準的な_clojurescript_api_の使用"></a><a class="link" href="#_標準的な_clojurescript_api_の使用">標準的な ClojureScript API の使用</a></h5>
<div class="paragraph">
<p>生成されたコードは、標準的な ClojureScript の <code>cljs.loader</code> API を使用することができます。手順については、ClojureScript ウェブサイトの <a href="https://clojurescript.org/news/2017-07-10-code-splitting">documentation</a> を参照してください。</p>
</div>
<div class="paragraph">
<p>標準API を使用することの利点は、自分のコードが他の人とうまく調和することです。これはライブラリの作者にとっては特に重要なことでしょう。不利な点は、標準配布の動的なモジュールローディング API は、現在のところ <code>shadow-cljs</code> のサポートに比べてやや使いにくいことです。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="output-wrapper"><a class="anchor" href="#output-wrapper"></a><a class="link" href="#output-wrapper">7.4. アウトプット・ラッパー</a></h3>
<div class="paragraph">
<p><strong>リリースビルドのみ</strong> : Closure Compiler <code>:advanced</code> で生成されたコードは、多くのグローバル変数を作成し、ページ内で実行されている他の JS と競合する可能性があります。生成された変数を分離するために、コードを無名関数でラップし、そのスコープ内でのみ変数が適用されるようにすることができます。</p>
</div>
<div class="paragraph">
<p><code>:modules</code> がひとつしかない <code>:browser</code> の <code>release</code> ビルドは、デフォルトでは <code>(function(){&lt;the-code&gt;}).call(this);</code> でラップされます。そのため、グローバル変数は作成されません。</p>
</div>
<div class="paragraph">
<p>複数の <code>:module</code> (別名 <a href="#CodeSplitting">コードスプリッティング</a>) を使用している場合、各モジュールは依存しているモジュールが作成した変数にアクセスできなければならないため、このオプションはデフォルトでは有効になっていません。</p>
</div>
<div class="paragraph">
<p>Closure Compiler は、<code>:rename-prefix-namespace</code> という名前の複数の <code>:modules</code> と組み合わせた出力ラッパーの使用を有効にする追加オプションをサポートしています。これにより、コンパイラはビルドで使用されるすべてのグローバル変数を、実際のグローバル変数 1 つにスコープします。デフォルトでは、<code>:output-wrapper</code> が <code>true</code> に設定されている場合、これは <code>:rename-prefix-namespace "$APP"</code> に設定されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:target :browser
  ...
  :compiler-options
  {:output-wrapper true
   :rename-prefix-namespace "MY_APP"}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、 <code>MY_APP</code> というグローバル変数を作成するだけです。すべてのグローバル変数の前には <code>MY_APP.</code> がつくので (たとえば、 <code>a</code> だけではなく <code>MY_APP.a</code>)、コードサイズは大幅に増加します。これを短くすることが重要です。ブラウザの圧縮（例：<code>gzip</code>）は、余分なコードのオーバーヘッドを減らすのに役立ちますが、ビルド内のグローバル変数の量に応じて、これでもまだ顕著な増加が見られます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
作成された変数は、実際には直接使えないことに注意してください。作成された変数は、実際には使い物になりませんが、多くのプロパティを含んでいます。エクスポートされた（例: <code>^:export</code> ）変数はすべてグローバルスコープにエクスポートされ、この設定の影響を受けません。この設定は、グローバル変数の作成量を制限するためだけのもので、それ以外には何もありません。直接使用しないでください。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_web_worker"><a class="anchor" href="#_web_worker"></a><a class="link" href="#_web_worker">7.5. Web Worker</a></h3>
<div class="paragraph">
<p><code>modules</code> の設定は、Web Worker として使用されるファイルを生成するためにも使用できます。
<code>web-worker true</code> を設定することで、任意のモジュールを Web Worker として宣言することができます。生成されたファイルには、いくつかの追加ブートストラップコードが含まれます。 <code>:modules</code> の働きにより、ワーカーのみが使用するコードは、ワーカーの最終ファイルにのみ含まれることになります。各ワーカーは専用の CLJS 名前空間を持つべきです。</p>
</div>
<div class="listingblock">
<div class="title">Web Worker スクリプトの生成の一例</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   :asset-path "/js"
   ...
   :modules
   {:shared
    {:entries []}
    :main
    {:init-fn my.app/init
     :depends-on #{:shared}}
    :worker
    {:init-fn my.app.worker/init
     :depends-on #{:shared}
     :web-worker true}}
   }}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上記の設定を行うと、Web Worker を起動するための <code>worker.js</code> が生成されます。
Worker.js は <code>:shared</code> モジュールのすべてのコードを利用できます (ただし <code>:main</code> は利用できません)。 <code>my.app.worker</code> 名前空間にあるコードは、ワーカーの中でのみ実行されます。ワーカーの生成は、開発モードとリリースモードの両方で行われます。</p>
</div>
<div class="paragraph">
<p>なお、<code>:shared</code> モジュールで空の <code>:entries []</code> を指定すると、<code>:main</code> モジュールと <code>:worker</code> モジュールの間で共有されるすべてのコードを収集するようになります。</p>
</div>
<div class="listingblock">
<div class="title">Example エコ・ーワーカー</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.app.worker)

(defn init []
  (js/self.addEventListener "message"
    (fn [^js e]
      (js/postMessage (.. e -data)))))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Sample ワーカーの使用</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.app)

(defn init []
  (let [worker (js/Worker. "/js/worker.js")]
    (.. worker (addEventListener "message" (fn [e] (js/console.log e))))
    (.. worker (postMessage "hello world"))))</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
現在、<code>:shared</code> モジュールがあるので、HTML で適切にロードする必要があります。単に <code>main.js</code> をロードしただけでは、エラーが発生します。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">HTML shared.js と main.js の読み込み</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">&lt;script src="/js/shared.js"&gt;&lt;/script&gt;
&lt;script src="/js/main.js"&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_キャッシュ可能な出力"><a class="anchor" href="#_キャッシュ可能な出力"></a><a class="link" href="#_キャッシュ可能な出力">7.6. キャッシュ可能な出力</a></h3>
<div class="paragraph">
<p>Web環境では、余分なリクエストを避けるために、 <code>.js</code> ファイルを非常に長い時間キャッシュすることが望ましいです。リリースされたバージョンごとに、 <code>.js</code> ファイルにユニークな名前をつけるのが一般的です。これにより、ファイルへのアクセスに使用される URL が変更されるため、永久にキャッシュしても安全です。</p>
</div>
<div class="sect3">
<h4 id="release-version"><a class="anchor" href="#release-version"></a><a class="link" href="#release-version">7.6.1. リリースバージョン</a></h4>
<div class="paragraph">
<p>各リリースに固有のファイル名を作成するには、<code>:release-version</code> という設定を使用します。一般的には、コマンドラインから <a href="#config-merge">--config-merge</a> でこの設定を渡します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">shadow-cljs release app --config-merge '{:release-version "v1"}'</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example :modules config</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
   {:app
     {:target :browser
      ...
      :output-dir "public/js"
      :asset-path "/js"
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、 <code>main.v1.js</code> と <code>extra.v1.js</code> のファイルが、通常の <code>main.js</code> と <code>extra.js</code> ではなく、 <code>public/js</code> に作成されます。</p>
</div>
<div class="paragraph">
<p>手動のバージョンを使うこともできますし、ビルド時に <code>git</code> sha のような自動化されたものを使うこともできます。ただ、ユーザーに何かを出荷したときには、それが何であれ、キャッシュを使って、古いファイルの新しいバージョンを要求しないようにしてください。</p>
</div>
</div>
<div class="sect3">
<h4 id="NameHashing"><a class="anchor" href="#NameHashing"></a><a class="link" href="#NameHashing">7.6.2. フィンガープリント・ハッシュを使ったファイル名</a></h4>
<div class="paragraph">
<p>ビルド設定に <code>:module-hash-names true</code> を追加すると、生成される各出力モジュールファイルに MD5 署名を自動的に作成することができます。つまり、<code>:main</code> モジュールは、デフォルトの <code>main.js</code> ではなく、 <code>main.&lt;md5hash&gt;.js</code> を生成することになります。</p>
</div>
<div class="paragraph">
<p><code>:module-hash-names true</code> は、 32 個の完全な md5ハッシュを含みますが、より短いバージョンを好む場合は、代わりに1～32の数字を指定できます。
1-32の間の数字を指定できます(例: <code>:module-hash-names 8</code>)。ハッシュを短くすると、コンフリクトが発生する可能性が高くなることに注意してください。
競合が発生する可能性が高くなることに注意してください。完全なハッシュを使うことをお勧めします。</p>
</div>
<div class="listingblock">
<div class="title">Example :module-hash-names config</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
   {:app
     {:target :browser
      ...
      :output-dir "public/js"
      :asset-path "/js"
      :module-hash-names true
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>main.js</code> を生成するのではなく、<code>:output-dir</code> に <code>main.&lt;hash&gt;.js</code> を生成するようになりました。</p>
</div>
<div class="paragraph">
<p>ファイル名はリリースごとに変更される可能性があるため、それらを HTML に含めるのは少し複雑になります。
HTML に含めるのは少し複雑です。<a href="#BrowserManifest">Output Manifest</a>はその手助けとなります。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="BrowserManifest"><a class="anchor" href="#BrowserManifest"></a><a class="link" href="#BrowserManifest">7.7. 出力マニフェスト</a></h3>
<div class="paragraph">
<p><code>shadow-cljs</code> は設定された <code>:output-dir</code> に <code>manifest.edn</code> ファイルを生成します。このファイルには、モジュール設定の説明と、追加の <code>:output-name</code> プロパティが含まれています。</p>
</div>
<div class="paragraph">
<p>オリジナルのモジュール名を実際のファイル名にマッピングします (<code>:module-hash-names</code> 機能を使用する際に重要です)。</p>
</div>
<div class="listingblock">
<div class="title">ハッシュ化されたファイル名を使用した場合の manifest.edn の出力例</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">[{:module-id :common,
  :name :common,
  :output-name "common.15D142F7841E2838B46283EA558634EE.js",
  :entries [...],
  :depends-on #{},
  :sources [...]}
 {:module-id :page-a,
  :name :page-a,
  :output-name "page-a.D8844E305644135CBD5CBCF7E359168A.js",
  :entries [...],
  :depends-on #{:common},
  :sources [...]}
 ...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>マニフェストには、すべての <code>:module</code> が依存関係のある順に並べられています。これを使って、<code>:module-id</code> を実際に生成されたファイル名にマッピングすることができます。</p>
</div>
<div class="paragraph">
<p>開発用のビルドでもこのファイルが生成されますので、新しいビルドが完了したときに修正のためにチェックすることができます。開発中は <code>:module-hash-names</code> が適用されないので、通常のファイル名が表示されます。</p>
</div>
<div class="paragraph">
<p>生成されるマニフェストファイルの名前は、<code>:build-options :manifest-name</code> エントリで設定できます。デフォルトでは <code>manifest.edn</code> となります。ファイル名の最後に <code>.json</code> を設定すると、EDN ではなく JSON が出力されます。ファイルは構成された <code>:output-dir</code> からの相対パスになります。</p>
</div>
<div class="listingblock">
<div class="title">Example manifest.json の設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
   {:app
     {:target :browser
      ...
      :build-options {:manifest-name "manifest.json"}
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_開発サポート"><a class="anchor" href="#_開発サポート"></a><a class="link" href="#_開発サポート">7.8. 開発サポート</a></h3>
<div class="paragraph">
<p><code>:browser</code> の設定の <code>:devtools</code> セクションでは、ビルドやCSSのリロードのために、オプションで dev-time HTTP サーバーを設定するために、いくつかの追加オプションをサポートしています。</p>
</div>
<div class="sect3">
<h4 id="hud"><a class="anchor" href="#hud"></a><a class="link" href="#hud">7.8.1. ヘッドアップディスプレイ（HUD）</a></h4>
<div class="paragraph">
<p><code>:browser</code> ターゲットは、HUD を使って、ビルドが開始されたときにローディング・インジケータを表示するようになりました。また、警告やエラーが発生した場合にも表示されます。</p>
</div>
<div class="paragraph">
<p><code>devtools</code> セクションで <code>:hud false</code> を設定することで、完全に無効にすることができます。</p>
</div>
<div class="paragraph">
<p>また、<code>:hud #{:errors :warnings}</code> という設定で気になる機能を指定して、特定の機能を切り替えることもできます。これにより、エラーや警告は表示されますが、進捗状況は表示されません。利用可能なオプションは <code>:errors</code> <code>:warnings</code> <code>:progress</code> です。含まれるオプションのみが有効になり、それ以外は無効になります。</p>
</div>
<div class="sect4">
<h5 id="open-file-command"><a class="anchor" href="#open-file-command"></a><a class="link" href="#open-file-command">ファイルを開く</a></h5>
<div class="paragraph">
<p>警告にはソースの場所へのリンクが含まれており、クリックするとそのファイルをエディタで開くことができます。このためには、ちょっとした設定が必要です。</p>
</div>
<div class="paragraph">
<p>この設定は、プロジェクトのための <code>shadow-cljs.edn</code> 設定の中で行うか、ホームディレクトリの <code>~/.shadow-cljs/config.edn</code> でグローバルに行うことができます。</p>
</div>
<div class="listingblock">
<div class="title">:open-file-command の設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:open-file-command
 ["idea" :pwd "--line" :line :file]}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>open-file-command</code> では、非常にシンプルな DSL を表すベクターを想定しています。文字列はそのままで、キーワードはそれぞれの値で置き換えられます。 <code>clojure.core/format</code> スタイルのパターンを使用して、複数のパラメータを組み合わせる必要がある場合には、ネストしたベクターを使用することができます。</p>
</div>
<div class="paragraph">
<p>上記の例では、以下のように実行されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ idea /path/to/project-root --line 3 /path/to/project-root/src/main/demo/foo.cljs</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">emacsclient の例</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:open-file-command
 ["emacsclient" "-n" ["+%s:%s" :line :column] :file]}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ emacsclient -n +3:1 /path/to/project-root/src/main/demo/foo.cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>利用可能な置換変数は以下の通りです。</p>
</div>
<div class="dlist Horizontal">
<dl>
<dt><code>:pwd</code> </dt>
<dd>
<p>プロセスの作業ディレクトリ（別名：プロジェクトルート）</p>
</dd>
<dt><code>:file</code> </dt>
<dd>
<p>絶対ファイルパス</p>
</dd>
<dt><code>:line</code> </dt>
<dd>
<p>警告・エラーの行番号</p>
</dd>
<dt><code>:column</code> </dt>
<dd>
<p>コラム番号</p>
</dd>
<dt><code>:wsl-file</code> </dt>
<dd>
<p>変換された WSL ファイルのパス。 WSL の Bash で <code>shadow-cljs</code> を実行するときに便利です。 <code>mnt/c/Users/someone/code/project/src/main/demo/foo.cljs</code> のパスを <code>C:Users...</code> に変換します。</p>
</dd>
<dt><code>:wsl-pwd</code> </dt>
<dd>
<p>変換された <code>:pwd</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_css_リローディング"><a class="anchor" href="#_css_リローディング"></a><a class="link" href="#_css_リローディング">7.8.2. CSS リローディング</a></h4>
<div class="listingblock">
<div class="title">Example HTML スニペット</div>
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;link rel="stylesheet" href="/css/main.css"/&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example Hiccup 俺たちは野蛮人じゃないから</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">[:link {:rel "stylesheet" :href "/css/main.css"}]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">内蔵されている dev HTTP サーバの利用</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">:dev-http {8000 "public"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、 <code>public/css/main.css</code> が変更されると、ブラウザは <code>/css/main.css</code> を再読み込みします。</p>
</div>
<div class="paragraph">
<p>現在、 <code>shadow-cljs</code> は CSS を直接コンパイルすることをサポートしていませんが、通常のツールは動作します。
を別途実行する必要があります。ただ、出力が正しい場所に生成されることを確認してください。</p>
</div>
<div class="paragraph">
<p>組み込みのHTTPサーバーを使用しない場合は、代わりに <code>:watch-dir</code> を指定することができ、コンテンツの配信に使用されるドキュメントルートへのパスを指定します。</p>
</div>
<div class="listingblock">
<div class="title">Example :watch-dir の設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
    {:builds
      {:app {...
             :devtools {:watch-dir "public"}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>HTTP サーバが仮想ディレクトリからファイルを提供していて、ファイルシステムのパスが HTML で使われているパスと完全に一致しない場合、プレフィックスとして使われる <code>:watch-path</code> を設定することで、パスを調整することができます。</p>
</div>
<div class="listingblock">
<div class="title">Example <code>public/css/main.css</code> は <code>/foo/css/main.css</code> 下でサーブされます。</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 {:builds
  {:app
   {...
    :devtools {:watch-dir "public"
               :watch-path "/foo"}}}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="proxy-support"><a class="anchor" href="#proxy-support"></a><a class="link" href="#proxy-support">7.8.3. プロキシサポート</a></h4>
<div class="paragraph">
<p>デフォルトでは、devtools クライアントは、設定された HTTP server (通常は <code>localhost</code> ) 経由で <code>shadow-cljs</code> プロセスへの接続を試みます。リバースプロキシを使用して HTML を配信している場合、接続できない場合があります。 <code>:devtools-url</code> を設定することにより、使用する URL を設定することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app {...
        :devtools {:before-load  my.app/stop
                   :after-load   my.app/start
                   :devtools-url "https://some.host/shadow-cljs"
                   ...}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>shadow-cljs</code> は、リクエストの際に <code>:devtools-url</code> をベースとして使用します。これは最終的な URL ではありませんので、設定したパス (例: <code>/shadow-cljs/*</code>) で始まるすべてのリクエストが、 <code>shadow-cljs</code> が実行されているホストに転送されるようにする必要があります。</p>
</div>
<div class="paragraph">
<p>プロキシへの Incoming リクエストは、</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">https://some.host/shadow-cljs/ws/foo/bar?asdf</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下に転送する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">http://localhost:9630/foo/bar?asdf</code></pre>
</div>
</div>
<div class="paragraph">
<p>クライアントは、ファイルを読み込むため、通常の XHR リクエストだけでなく WebSocket リクエストも行います。プロキシが WebSocket を適切にアップグレードするようにしてください。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
リクエストは、ビルド自体で設定したものではなく、メインの HTTP server に転送されなければなりません。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="target-react-native"><a class="anchor" href="#target-react-native"></a><a class="link" href="#target-react-native">8. React Native をターゲットにする</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>:target :react-native</code> は、デフォルトの <code>react-native</code> ツール (例: <code>metro</code> ) に統合することを意図したコードを生成します。これらのツールをラップした <code>expo</code> のようなツールは自動的に動作し、追加の設定は必要ありません。</p>
</div>
<div class="paragraph">
<p>他のターゲット (<code>:source-paths</code> など) と同じ基本的な <a href="#config">main configuration</a> が必要になります。ビルド専用の設定は非常に少なく、(<code>:target</code> 自体の他に) 少なくとも2つのオプションが必要です。</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>:init-fn</code> 
</td>
<td class="hdlist2">
<p>(必須) アプリの init関数の名前空間修飾されたシンボルです。この関数は起動時に一度だけ呼び出され、おそらく何かをレンダリングするはずです。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:output-dir</code> 
</td>
<td class="hdlist2">
<p>(必須) 出力ファイルを書き込むためのディレクトリです。</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">:react-native の設定例</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:source-paths [...]
 :dependencies [...]
 ...
 :builds
 {:app
  {:target :react-native
   :init-fn demo.app/init
   :output-dir "app"}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これをコンパイルすると、 <code>react-native</code> ツールのエントリーポイントとして使用される <code>app/index.js</code> ファイルが生成されます。開発中、<code>:output-dir</code> にはさらに多くのファイルが格納されますが、生成された <code>app/index.js</code> を直接参照するだけにしてください。 <code>release</code> のビルドでは、最適化された <code>app/index.js</code> が生成されるだけで、追加のファイルは必要ありません。</p>
</div>
<div style="page-break-after: always;"></div>
<div class="sect2">
<h3 id="_react_native"><a class="anchor" href="#_react_native"></a><a class="link" href="#_react_native">8.1. React Native</a></h3>
<div class="paragraph">
<p><code>react-native</code> には、ネイティブコードやライブラリを使用できるプレーンな <code>react-native</code> と <a href="https://expo.io/">expo</a> （後述）でラップされた <code>react-native</code> の 2 つの使用方法があります。上記で説明したすべての手順は、プレーンな <code>react-native</code> で <code>shadow-cljs</code> を使い始めるのに十分なものです。このサンプルレポをご覧ください。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/thheller/reagent-react-native" class="bare">https://github.com/thheller/reagent-react-native</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_expo"><a class="anchor" href="#_expo"></a><a class="link" href="#_expo">8.2. Expo</a></h3>
<div class="paragraph">
<p><a href="https://expo.io/">expo</a> を使うと、 <code>react-native</code> の作業がとても簡単になります。 2 つのサンプルセットアップが用意されています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/thheller/fulcro-expo" class="bare">https://github.com/thheller/fulcro-expo</a></p>
</li>
<li>
<p><a href="https://github.com/thheller/reagent-expo" class="bare">https://github.com/thheller/reagent-expo</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>どちらの例も <code>expo init</code> を使用して生成されています。設定で調整した唯一の変更点は、生成された <code>app.json</code> に適切な <code>entryPoint</code> を追加したことです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{
  "expo": {
    "name": "hello-world",
    "slug": "reagent-expo",
    ...
    "entryPoint":"./app/index.js",
    ...
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>expo</code> では、起動時に React Component が登録される必要があります。これは手動で行うこともできますし、Component の作成を行い、代わりに React Element インスタンスがレンダリングを開始することを直接期待する <code>shadow.expo/render-root</code> 関数を使用することもできます。</p>
</div>
<div class="listingblock">
<div class="title"><a href="https://github.com/thheller/reagent-expo/blob/2c73ed0513a8f5050b250c0c7e53b9ae7543cee9/src/main/test/app.cljs#L34-L40">Reagent の例</a></div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(defn start
  {:dev/after-load true}
  []
  (expo/render-root (r/as-element [root])))

(defn init []
  (start))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>init</code> は起動時に一度だけ呼ばれます。この例では特別な設定をする必要がないので、単に <code>start</code> を直接呼び出します。</p>
</div>
<div class="paragraph">
<p><code>start</code> は、コードの変更がリロードされた後に <code>watch</code> が実行されるたびに、繰り返し呼び出されます。</p>
</div>
<div class="paragraph">
<p><code>reagent.core/as-element</code> 関数は、reagent hiccup のマークアップから必要な React Element を生成するために使用することができます。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="target-node"><a class="anchor" href="#target-node"></a><a class="link" href="#target-node">9. Node.js を対象とする</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>独立したスクリプトとして使用することを目的としたコードや、ライブラリとして使用することを目的としたコードの生成をサポートしています。設定ファイルに必要な基本的な設定については、<a href="#config">common configuration</a> の項を参照してください。</p>
</div>
<div class="sect2">
<h3 id="target-node-script"><a class="anchor" href="#target-node-script"></a><a class="link" href="#target-node-script">9.1. Node.js のスクリプト</a></h3>
<div class="paragraph">
<p><code>target :node-script</code> は、<code>Node.js</code> を使用して実行できるシングルファイルのスタンドアローン出力を生成します。
コードは単なる ClojureScript であり、エントリーポイントの定義も簡単です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns demo.script)

(defn main [&amp; cli-args]
  (prn "hello world"))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ビルドオプション"><a class="anchor" href="#_ビルドオプション"></a><a class="link" href="#_ビルドオプション">9.1.1. ビルドオプション</a></h4>
<div class="paragraph">
<p>他のターゲット（ <code>:source-paths</code> など）と同じ基本的な <a href="#config">main configuration</a> が必要になりますが、いくつかのノード固有のビルドターゲットオプションが必要になります。</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>:main</code> 
</td>
<td class="hdlist2">
<p>(必須) スクリプトのエントリーポイントとなる関数の名前空間修飾されたシンボルです。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:output-to</code> 
</td>
<td class="hdlist2">
<p>(必須) 生成されるスクリプトのパスとファイル名です。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:output-dir</code> 
</td>
<td class="hdlist2">
<p>(オプション) 開発モードでサポートするファイルのパスです。デフォルトではキャッシュディレクトリになります。</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Node スクリプトのビルド例</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:source-paths [...]
 ...
 :builds
 {:script
  {:target :node-script
   :main demo.script/main
   :output-to "out/demo-script/script.js"}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これをコンパイルすると、スタンドアロンの <code>out/demo-script/script.js</code> ファイルが作成され、 <code>node script.js &lt;command line args&gt;</code> で呼び出されるようになります。実行すると、起動時に <code>(demo.script/main &lt;command line args&gt;)</code> 関数が呼び出されます。これは <code>:output-to</code> で指定されたファイルのみを生成します。その他のサポートファイル(開発モード用など)は、一時的なサポートディレクトリに書き込まれます。</p>
</div>
</div>
<div class="sect3">
<h4 id="NodeHotCodeReload"><a class="anchor" href="#NodeHotCodeReload"></a><a class="link" href="#NodeHotCodeReload">9.1.2. ホットコードリロード</a></h4>
<div class="paragraph">
<p>サーバーやその他の長時間実行されるプロセスとして動作するスクリプトを書くことがよくあります。ホットコードリロードは、これらの作業を行う際に非常に便利で、設定も簡単です。</p>
</div>
<div class="paragraph">
<p>start/stop コールバック関数の追加して、これらのフックを使用するようにビルドを設定します。</p>
</div>
<div class="paragraph">
<p>ここでは、node の http サーバーの例を紹介します。</p>
</div>
<div class="listingblock">
<div class="title">ホットコードリロードのための start/stop フックを備えた Node スクリプトのサンプル</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns demo.script
  (:require ["http" :as http]))

(defn request-handler [req res]
  (.end res "foo"))

; サーバーを停止/起動できるようにするための、サーバーに接続するための場所
(defonce server-ref
  (volatile! nil))

(defn main [&amp; args]
  (js/console.log "starting server")
  (let [server (http/createServer #(request-handler %1 %2))]

    (.listen server 3000
      (fn [err]
        (if err
          (js/console.error "server start failed")
          (js/console.info "http server running"))
        ))

    (vreset! server-ref server)))

(defn start
  "開始するためのフック。また、ホットコードのリロード用のフックとしても使用されます。"
  []
  (js/console.warn "start called")
  (main))

(defn stop
  "ホットコードリロードフックで、ホットコードリロードが機能するようにリソースをシャットダウンする。"
  [done]
  (js/console.warn "stop called")
  (when-some [srv @server-ref]
    (.close srv
      (fn [err]
        (js/console.log "stop completed" err)
        (done)))))

(js/console.log "__filename" js/__filename)</code></pre>
</div>
</div>
<div class="paragraph">
<p>関連する設定は（ <code>shadow-cljs.edn</code> ）です。</p>
</div>
<div class="listingblock">
<div class="title">ホットコードリロードのためのフックの追加</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
   { :script {... as before

              ; リロードフックの追加
              :devtools {:before-load-async demo.script/stop
                         :after-load demo.script/start}}}}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
多くのライブラリは状態を隠したり、ホットコードのリロードがうまく機能しないような動作をします。コンパイラはこれらのライブラリが何をしているのかを知らないので、これを改善することはできません。
ホットコードリロードは、使用されているアーティファクトをきれいに stop および restart できる状況でのみうまく機能します。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="target-node-library"><a class="anchor" href="#target-node-library"></a><a class="link" href="#target-node-library">9.2. Node.js ライブラリ</a></h3>
<div class="paragraph">
<p><code>:target :node-library</code> は、標準的なノードライブラリとして（ <code>require</code> を介して）使用できるコードを出力します。これは、コンパイルされたJavascript の成果物として再利用するためにコードを公開するのに便利です。</p>
</div>
<div class="paragraph">
<p>他のモードと同様に、<a href="#config">main configuration options</a>が適用され、設定する必要があります。
ターゲット固有のオプションは以下の通りです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:target</code>: <code>:node-library</code> を使用します。</p>
</li>
<li>
<p><code>:output-to</code> : (必須) 生成されるライブラリのパスとファイル名です。</p>
</li>
<li>
<p><code>:output-dir</code> : (オプション) 開発モードでサポートするファイルのパスです。デフォルトではキャッシュディレクトリになります。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ホットコードリロードのストーリーは、<a href="#NodeHotCodeReload">the script target</a>と似ていますが、すべてのコードを簡単にコントロールできないため、うまく機能しないかもしれません。
ロードされるすべてのコードを簡単にコントロールすることができないからです。</p>
</div>
<div class="paragraph">
<p>実際にエクスポートされるコードを制御するには、以下のオプションがあります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:exports</code> - キーワードから完全修飾シンボルへのマップ</p>
</li>
<li>
<p><code>:exports-var</code> - 完全修飾形式のシンボル</p>
</li>
<li>
<p><code>:exports-fn</code> - 完全修飾されたシンボル</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_単一で静的な_デフォルト_エクスポート"><a class="anchor" href="#_単一で静的な_デフォルト_エクスポート"></a><a class="link" href="#_単一で静的な_デフォルト_エクスポート">9.2.1. 単一で静的な デフォルト・エクスポート</a></h4>
<div class="paragraph">
<p><code>:exports-var</code> は、その var の下で宣言されているものをそのまま返します。 これは <code>defn</code> や通常の <code>def</code> を指しています。</p>
</div>
<div class="listingblock">
<div class="title">:exports-var を使用してコンフィグを構築する</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds {:lib {:output-to "lib.js"
                :exports-var demo.ns/f
                ...}}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example CLJS</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns demo.ns)

(defn f [...] ...)
;; または
(def f #js {:foo ...})</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ node
&gt; var f = require('./lib.js');
f(); // 実際の demo.ns/f 関数</code></pre>
</div>
</div>
<div class="paragraph">
<p>事実上モジュールを生成しています。 <code>exports = demo.ns.f;</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_複数の静的な名前付きエクスポート"><a class="anchor" href="#_複数の静的な名前付きエクスポート"></a><a class="link" href="#_複数の静的な名前付きエクスポート">9.2.2. 複数の静的な名前付きエクスポート</a></h4>
<div class="listingblock">
<div class="title">複数のエクスポートを行うビルド構成</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds {:lib {:exports {:g       demo.ns/f
                          :h       other.ns/thing
                          :ns/ok?  another.ns/ok?}
                ...}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このキーワードは、エクスポートされたオブジェクトのエントリの名前として使用されます。このキーワード名には、一切の処理が行われません。(しかし、名前空間は削除されます）。したがって、上記の例では、cljs の <code>f</code> を <code>g</code> にマッピングします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ node
&gt; var lib = require('./lib.js');
lib.g(); // call demo-ns/f
lib["ok?"](); // another-ns/ok? を呼び出す</code></pre>
</div>
</div>
<div class="paragraph">
<p>全く同じことをするには、<code>:exports-var</code> で <code>def</code> を指定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(def exports #js {:g f
                  ...})</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_動的エクスポート"><a class="anchor" href="#_動的エクスポート"></a><a class="link" href="#_動的エクスポート">9.2.3. 動的エクスポート</a></h4>
<div class="paragraph">
<p>さらに完全修飾シンボルとして <code>:exports-fn</code> を指定することもできます。これは、JS オブジェクト(または関数)を返す引数のない関数を指す必要があります。この関数は <code>node</code> が戻り値をキャッシュするため、一度だけ呼ばれます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns demo.ns
  (:require [demo.other :as other]))

(defn generate-exports []
  #js {:hello hello
       :foo other/foo})</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds {:lib {:exports-fn demo.ns/generate-exports
                ...}}}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
exports コンフィグはエクスポートされたシンボルを自動的に追跡し、最適化ステージに渡します。つまり、<code>:exports</code> に記載されているものは、Google Closure の最適化によって名前が変更されることはありません。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_完全な例"><a class="anchor" href="#_完全な例"></a><a class="link" href="#_完全な例">9.2.4. 完全な例</a></h4>
<div class="paragraph">
<p>以下の例では、通常の Node <code>require</code> メカニズムで使われることを想定して <code>lib.js</code> ファイルを作成します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns demo.lib)

(defn hello []
  (prn "hello")
  "hello")</code></pre>
</div>
</div>
<div class="paragraph">
<p>ビルド構成は以下のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds {:library {:target    :node-library
                    :output-to "out/demo-library/lib.js"
                    :exports   {:hello demo.lib/hello}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ランタイムの使用感は期待通りです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">$ cd out/demo-library
$ node
&gt; var x = require('./lib');
undefined
&gt; x.hello()
hello
'hello'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>node-script</code> と同様に <code>:output-to</code> で指定されたファイルのみが作成されます。</p>
</div>
<div class="paragraph">
<p><code>exports</code> マップは CLJS の変数をエクスポートされるべき名前にマッピングします。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
開発モードでは、ノードスクリプトと同じ<a href="#NodeModes">同じ設定</a>になります（追加の依存関係があります）。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="target-npm-module"><a class="anchor" href="#target-npm-module"></a><a class="link" href="#target-npm-module">10. JS エコシステムへの組み込み - :npm-module ターゲット</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>既存のJSプロジェクトにCLJSを統合することを目的とした追加ターゲットがあります。この出力は、既存のJSツール (webpack、browserify、babel、create-react-app 等）とわずかな設定で途切れなく統合できます。</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>:output-dir</code> 
</td>
<td class="hdlist2">
<p>(デフォルト) <code>node_modules/shadow-cljs</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:entries</code> 
</td>
<td class="hdlist2">
<p>(必須) コンパイルされるべき名前空間シンボルのベクトル</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example <code>shadow-cljs.edn</code> の設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:code
  {:target :npm-module
   :entries [demo.foo]}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>デフォルトの <code>:output-dir</code> である <code>"node_modules/shadow-cljs"</code> を使用すると、JS で <code>require("shadow-cljs/demo.foo")</code> を使用して、宣言された名前空間にアクセスすることができます。 <code>node_modules</code> にないものを使用する場合は、相対パスを使ってインクルードする必要があります。 <code>:output-dir "out"</code> では、プロジェクトルートからの <code>require("./out/demo.foo")</code> となります。</p>
</div>
<div class="paragraph">
<p>npm でコードを配布する予定であれば、代わりに<a href="#NodeLibrary"><code>:node-library</code> target</a>を使用した方が、エクスポートや最適化をより細かく制御できるので良いでしょう。</p>
</div>
<div class="sect2">
<h3 id="_最適化の作業"><a class="anchor" href="#_最適化の作業"></a><a class="link" href="#_最適化の作業">10.1. 最適化の作業</a></h3>
<div class="paragraph">
<p><code>gnome-library</code> ターゲットとは異なり、module ターゲットはエクスポートするシンボルをどのように呼びたいかわからないので、そのままエクスポートします。高度なコンパイルを使用している場合は、すべてのシンボルに minified munged の名前が付けられます。</p>
</div>
<div class="paragraph">
<p>保存したいシンボルに <code>:export</code> メタデータを追加するだけで、簡単に解決できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns demo.foo)

(def ^:export foo 5.662)

(defn ^:export bar [] ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、ClojureScriptで理解される標準的なアノテーションで、Google Closure がアーティファクトの名前を変更するのを防ぎます。JS コードは最適化後もそれらにアクセスすることができます。 <code>^:export</code> のヒントがなければ、Closure コンパイラがそれらを削除したり、名前を変更したりするでしょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">var ns = require("shadow-cljs/demo.foo");

ns.foo;
ns.bar();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_テスト"><a class="anchor" href="#_テスト"></a><a class="link" href="#_テスト">11. テスト</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>shadow-cljs</code> は、テストの構築を少しでも簡単にするために、いくつかのユーティリティターゲットを提供しています。</p>
</div>
<div class="paragraph">
<p>すべてのテストターゲットはテストランナーを生成し、設定可能な <code>:ns-regexp</code> にマッチするすべての名前空間を自動的に追加します。デフォルトのテストランナーは <code>cljs.test</code> 用に作られていますが、他のテストフレームワークを使いたい場合は、カスタムランナーを作ることができます。</p>
</div>
<div class="paragraph">
<p>デフォルトの <code>:ns-regexp</code> は <code>"-test$"</code> なので、最初のテストは以下のようになります。</p>
</div>
<div class="listingblock">
<div class="title">File: <code>src/test/demo/app_test.cljs</code>.</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns demo.app-test
  (:require [cljs.test :refer (deftest is)]))

(deftest a-failing-test
  (is (= 1 2)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Clojure の世界では、テストファイルをそれぞれのソースパスに置いておくのが一般的なので、上記の例では、 <code>shadow-cljs.edn</code> の設定で <code>:source-paths ["src/main" "src/test"]</code> を設定していると仮定しています。通常のアプリのコードは <code>src/main</code> に入り、テストは <code>src/test</code> に入ります。ただし、これはオプションで、すべてを <code>src</code> に置いて、<code>:source-paths ["src"]</code> を使うだけでも全く問題ありません。</p>
</div>
<div class="sect2">
<h3 id="_node_js_におけるテスト_a_id_target_node_test_a"><a class="anchor" href="#_node_js_におけるテスト_a_id_target_node_test_a"></a><a class="link" href="#_node_js_におけるテスト_a_id_target_node_test_a">11.1. Node.js におけるテスト　<a id="target-node-test"></a></a></h3>
<div class="paragraph">
<p>このターゲットは、指定された正規表現にマッチするすべてのテスト名前空間を含むテストランナーを作成します。</p>
</div>
<div class="paragraph">
<p>関連する設定オプションは以下の通りです。</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>:target</code> 
</td>
<td class="hdlist2">
<p><code>:node-test</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:output-to</code> 
</td>
<td class="hdlist2">
<p>テストの実行に使用される最終的な出力ファイルです。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:ns-regexp</code> 
</td>
<td class="hdlist2">
<p>(オプション) プロジェクトファイルの名前空間にマッチする正規表現です。これはファイルをスキャンするだけで、ジャーはスキャンしません。デフォルトでは <code>"-test$"</code> となります。
<code>:autorun</code>: (オプション) (boolean, optional) ビルドが完了した際に、 <code>node</code> を介してテストを実行します。これは主に <code>watch</code> と組み合わせて使用することを想定しています。実行中の JVM を強制的に終了させる必要があるため、 <code>node</code> プロセスの終了コードは返されません。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:main</code> 
</td>
<td class="hdlist2">
<p>デフォルトは <code>shadow.test.node/main</code> で、これは <code>cljs.test</code> を使ってテストを実行します。</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">すべての <code>*-spec</code> 名前空間にマッチするテストコンフィグ</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:test
  {:target    :node-test
   :output-to "out/node-tests.js"
   :ns-regexp "-spec$"
   :autorun   true}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>node-test</code> ターゲットは、テストファイルを生成するだけです。これを <code>node</code> 経由で実行することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs compile test
# または
$ shadow-cljs release test

# 手動でテストを実行する場合、:autorun で自動的に実行されます。
$ node out/node-tests.js

# コンパイルとテストの結合
$ shadow-cljs compile test &amp;&amp; node out/node-tests.js</code></pre>
</div>
</div>
<div class="paragraph">
<p>成功すると <code>node</code> プロセスの終了コードは <code>0</code> に設定され、失敗すると <code>1</code> に設定されます。<code>:autorun</code> を使用している場合は、<code>node</code> プロセスの終了コードは返されません。</p>
</div>
</div>
<div class="sect2">
<h3 id="target-browser-test"><a class="anchor" href="#target-browser-test"></a><a class="link" href="#target-browser-test">11.2. ブラウザにおけるテスト</a></h3>
<div class="paragraph">
<p>このターゲットは、(ファイル名のパターンマッチに基づいて) テストを含む名前空間を集めて、テストランナーを起動するためのものです。</p>
</div>
<div class="paragraph">
<p>このターゲットには <code>cljs.test</code> テストを自動的にスキャンして実行するビルトインのランナーが含まれています。</p>
</div>
<div class="paragraph">
<p>関連する設定オプションは以下の通りです。</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>:target</code> 
</td>
<td class="hdlist2">
<p><code>:browser-test</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:test-dir</code> 
</td>
<td class="hdlist2">
<p>ファイルを出力するフォルダです。以下を参照してください。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:ns-regexp</code> 
</td>
<td class="hdlist2">
<p>(オプション) プロジェクトファイルの名前空間にマッチする正規表現です。これはファイルをスキャンするだけで、jar ファイルはスキャンしません。
ジャーのスキャンは行いません。デフォルトは"-test$"です。
<code>:runner-ns</code>: (オプション) start、stop 、init関数を含むことができる名前空間です。デフォルトは <code>shadow.test.browser</code> です。</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通常の <code>:devtools</code> オプションはサポートされていますので、通常はファイルを提供するための http サーバを作成します。
一般的には、次のような設定が必要です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds {:test     {:target    :browser-test
                     :test-dir  "resources/public/js/test"
                     :ns-regexp "-spec$"
                     :runner-ns tests.client-test-main
                     :devtools  {:http-port          8021
                                 :http-root          "resources/public/js/test"}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>test ディレクトリには、index.html と js フォルダがあることを覚えておいてください。</p>
</div>
<div class="paragraph">
<p>カスタムの <code>:runner-ns</code> を指定する場合は、以下のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns tests.client-test-main)

(defn start []
  ... run the tests...)

(defn stop [done]
  ; テストは非同期にすることができます。
  ; ランナーが実際に終了したことがわかるように、
  ; done を呼ばなければなりません。
  (done))

(defn ^:export init []
  (start))</code></pre>
</div>
</div>
<div class="paragraph">
<p>これには <code>init</code>, <code>start</code>, <code>stop</code> というメソッドがあります。 <code>init</code> は起動時に一度だけ呼び出され、 <code>stop</code> はコードがリロードされる前に呼び出され、 <code>start</code> はすべてのコードがリロードされた後に呼び出されます。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<code>:runner-ns</code> はオプションで、デフォルトを使用するには省略してください。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_test_dir_に生成された出力"><a class="anchor" href="#_test_dir_に生成された出力"></a><a class="link" href="#_test_dir_に生成された出力">11.2.1. :test-dir に生成された出力</a></h4>
<div class="paragraph">
<p>出力には、 <code>test-dir</code> フォルダにある 2 つの主要なアーティファクトが含まれます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>index.html</code> - <code>index.html</code> ファイルがまだ存在していない場合に限ります。デフォルトでは、生成されたファイルはテストをロードして、<code>:runner-ns</code> で <code>init</code> を実行します。上書きされないカスタムバージョンを編集または追加することができます。</p>
</li>
<li>
<p><code>js/test.js</code> - Javascript のテストです。テストは常にこの名前になります。モジュールのエントリーは自動生成されます。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="target-karma"><a class="anchor" href="#target-karma"></a><a class="link" href="#target-karma">11.3. 継続的インテグレーションのためにテストを Karma にターゲットする</a></h3>
<div class="paragraph">
<p>CLJS のテストをある種の CI サーバー上でブラウザに対して実行したい場合、コマンドラインからテストを実行してステータスコードを返すことができる必要があります。</p>
</div>
<div class="paragraph">
<p>Karma はよく知られていてサポートされているテストランナーで、これを実行することができます。</p>
</div>
<div class="paragraph">
<p>また、<code>shadow-cljs</code> にはターゲットが含まれており、テストの周りに適切なラッパーを追加することができるので、それによりテストが動作するようになります。</p>
</div>
<div class="sect3">
<h4 id="_karma_のインストール"><a class="anchor" href="#_karma_のインストール"></a><a class="link" href="#_karma_のインストール">11.3.1. Karma のインストール</a></h4>
<div class="paragraph">
<p>詳しい説明は <a href="http://karma-runner.github.io">website</a> をご覧ください。通常、<code>package.json</code> には以下のようなものが必要になります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "name": "CITests",
  "version": "1.0.0",
  "description": "Testing",
  ...
  "devDependencies": {
    "karma": "^2.0.0",
    "karma-chrome-launcher": "^2.2.0",
    "karma-cljs-test": "^0.1.0",
    ...
  },
  "author": "",
  "license": "MIT"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>つまり、Karma 、ブラウザランチャー、そして cljs-test の統合が必要なのです。</p>
</div>
</div>
<div class="sect3">
<h4 id="_build"><a class="anchor" href="#_build"></a><a class="link" href="#_build">11.3.2. Build</a></h4>
<div class="paragraph">
<p>ビルドのオプションは次のとおりです。</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>:target</code> 
</td>
<td class="hdlist2">
<p><code>:karma</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:output-to</code> 
</td>
<td class="hdlist2">
<p><code>:karma</code> :  js ファイルのパス/ファイル名です。</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>:ns-regexp</code> 
</td>
<td class="hdlist2">
<p>(オプション) テストの名前空間にマッチさせる正規表現、デフォルトは "-test$" です。</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>つまり、次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:ci
  {:target :karma
   :output-to  "target/ci.js"
   :ns-regexp  "-spec$"}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、 <code>karma.conf.js</code> も必要です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">module.exports = function (config) {
    config.set({
        browsers: ['ChromeHeadless'],
        // 出力ファイルが存在するディレクトリ
        basePath: 'target',
        // ファイル自体
        files: ['ci.js'],
        frameworks: ['cljs-test'],
        plugins: ['karma-cljs-test', 'karma-chrome-launcher'],
        colors: true,
        logLevel: config.LOG_INFO,
        client: {
            args: ["shadow.test.karma.init"],
            singleRun: true
        }
    })
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>すると、以下のようにテストを実行することができます（ツールのグローバル実行ファイルがインストールされていることが前提です）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ shadow-cljs compile ci
$ karma start --single-run
12 01 2018 01:19:24.222:INFO [karma]: Karma v2.0.0 server started at http://0.0.0.0:9876/
12 01 2018 01:19:24.224:INFO [launcher]: Launching browser ChromeHeadless with unlimited concurrency
12 01 2018 01:19:24.231:INFO [launcher]: Starting browser ChromeHeadless
12 01 2018 01:19:24.478:INFO [HeadlessChrome 0.0.0 (Mac OS X 10.12.6)]: Connected on socket TcfrjxVKmx7xN6enAAAA with id 85554456
LOG: 'Testing boo.sample-spec'
HeadlessChrome 0.0.0 (Mac OS X 10.12.6): Executed 1 of 1 SUCCESS (0.007 secs / 0.002 secs)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="js-deps"><a class="anchor" href="#js-deps"></a><a class="link" href="#js-deps">12. JavaScript との統合</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_npm_a_id_npm_a"><a class="anchor" href="#_npm_a_id_npm_a"></a><a class="link" href="#_npm_a_id_npm_a">12.1. npm<a id="npm"></a></a></h3>
<div class="paragraph">
<p><a href="https://www.npmjs.com/">npm</a> は、JavaScript のデファクトスタンダードのパッケージマネージャとなっています。ほとんどすべての JS ライブラリはそこで見つけることができ、shadow-cljs はそれらのパッケージにアクセスするためのシームレスな統合を提供します。</p>
</div>
<div class="sect3">
<h4 id="_npm_パッケージの使用"><a class="anchor" href="#_npm_パッケージの使用"></a><a class="link" href="#_npm_パッケージの使用">12.1.1. npm パッケージの使用</a></h4>
<div class="paragraph">
<p>大半の npm パッケージには実際のコードの使用法に関する説明も含まれています。古い CommonJS のスタイルでは　<code>require</code> の呼び出しがあるだけです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var react = require("react");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.app
  (:require ["react" :as react]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>require を呼び出すときに使われた "string "パラメータは全てそのまま <code>:require</code> に送られます。 <code>as</code> のエイリアスは任意です。これにより他の CLJS の名前空間と同じようにコードを使うことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(react/createElement "div" nil "hello world")</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>shadow-cljs</code> では。常に <code>ns</code> 形式と、あなたが提供した <code>:as</code> のエイリアスを使用してください。 また、<code>:refer</code> や <code>:rename</code> を使用することもできます。これは、<code>:foreign-libs</code>/CLJSJS が行う、名前空間にものをインクルードしても、コードの中ではグローバルな <code>js/Thing</code> を使用するというものとは異なります。</p>
</div>
<div class="paragraph">
<p>パッケージの中には、1 つの関数をエクスポートするものもあります。</p>
</div>
<div class="paragraph">
<p><code>(:require ["thing" :as thing])</code> と書くと <code>(thing)</code> で直接呼び出すことができます。</p>
</div>
<div class="paragraph">
<p>最近では、いくつかのパッケージが ES6 の <code>import</code> 文を例に挙げています。これらもほぼ 1 対1で翻訳されていますが、デフォルトのエクスポートに関するわずかな違いがあります。</p>
</div>
<div class="paragraph">
<p>以下の表は、比較対照に使用することができます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
この表は、消費されるコードが実際の ES6+コードとしてパッケージされている場合にのみ適用されます。コードが CommonJS としてパッケージされている場合は、<code>:default</code> は適用されないかもしれません。詳細は以下のセクションを参照してください。
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. ES6 Import から CLJS Require へ</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ES6 Import</th>
<th class="tableblock halign-left valign-top">CLJS Require</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>import defaultExport from "module-name";</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(:require ["module-name" :default defaultExport])</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>import * as name from "module-name";</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(:require ["module-name" :as name])</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>import { export } from "module-name";</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(:require ["module-name" :refer (export)])</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>import { export as alias } from "module-name";</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(:require ["module-name" :rename {export alias}])</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>import { export1 , export2 } from "module-name";</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(:require ["module-name" :refer (export1 export2)])</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>import { export1 , export2 as alias2 , [&#8230;&#8203;] } from "module-name";</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(:require ["module-name" :refer (export1) :rename {export2 alias2}])</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>import defaultExport, { export [ , [&#8230;&#8203;] ] } from "module-name";</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(:require ["module-name" :refer (export) :default defaultExport])</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>import defaultExport, * as name from "module-name";</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(:require ["module-name" :as name :default defaultExport])</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>import "module-name";</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(:require ["module-name"])</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以前は、実際には必要のない多くのコードを含むバンドルコードを使用していたことに注意してください。しかし、今回はより良い状況になりました。
ライブラリの中には、必要な部分だけをパッケージ化したものもあり、最終的なビルドに含まれるコードの量を大幅に減らすことができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">// react-virtualized から名前付きでエクスポートすることで、任意のコンポーネントをインポートすることができます。
import { Column, Table } from 'react-virtualized'

// いくつかの react-virtualized コンポーネントしか使用していない場合、
// またはアプリケーションのバンドルサイズが大きくなることを懸念している場合、
// 必要なコンポーネントだけを直接インポートすることができます。
import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer'
import List from 'react-virtualized/dist/commonjs/List'</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my-ns
  ;; 全て
  (:require ["react-virtualized" :refer (Column Table)])
  ;; もしくは一つずつ
  (:require ["react-virtualized/dist/commonjs/AutoSizer" :default virtual-auto-sizer]
            ["react-virtualized/dist/commonjs/List" :default virtual-list]))</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_default_exports_について"><a class="anchor" href="#_default_exports_について"></a><a class="link" href="#_default_exports_について">:default Exports について</a></h5>
<div class="paragraph">
<p>現在、<code>:default</code> オプションは <code>shadow-cljs</code> でのみ利用可能です。</p>
</div>
<div class="paragraph">
<p><a href="https://dev.clojure.org/jira/browse/CLJS-2376">https://dev.clojure.org/jira/browse/CLJS-2376</a> で標準化されることを期待します。</p>
</div>
<div class="paragraph">
<p>標準的な CLJS との互換性を保ちたい場合は、いつでも <code>:as alias</code> を使用して、 <code>alias/default</code> を呼び出すことができます。</p>
</div>
<div class="paragraph">
<p>デフォルトのエクスポートは ECMAScript モジュールで新たに追加されたもので、CommonJS のコードには存在しません。時々、 <code>import Foo from "something"</code> という例を見かけることがありますが、実際には CommonJS のコードです。このような場合、 <code>(:require ["something" :default Foo])</code> は動作せず、 <code>(:require ["something" :as Foo])</code> を代わりに使用する必要があります。</p>
</div>
<div style="page-break-after: always;"></div>
<div class="paragraph">
<p>もし、<code>:require</code> が正しく機能していないようであれば、REPL で見てみることをお勧めします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">$ shadow-cljs browser-repl (or node-repl)
...
[1:1]~cljs.user=&gt; (require '["react-tooltip" :as x])
nil
[1:1]~cljs.user=&gt; x
#object[e]
[1:1]~cljs.user=&gt; (goog/typeOf x)
"function"
[1:1]~cljs.user=&gt; (js/console.dir x)
nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>任意の JS オブジェクトを表示することは必ずしも便利ではないので（上の例のように）、代わりに <code>(js/console.dir x)</code> を使用すると、ブラウザのコンソールでより便利な表現を得ることができます。</p>
</div>
<div class="paragraph">
<p>また、 <code>goog/typeOf</code> が役に立つ場合もあります。上の例では <code>"function"</code> を示しているので、<code>:default</code> を使ってもうまくいきません。<code>:default</code> は基本的に <code>x/default</code> のシンタックスシュガーに過ぎないからです。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="js-provider"><a class="anchor" href="#js-provider"></a><a class="link" href="#js-provider">12.1.2. パッケージプロバイダ</a></h4>
<div class="paragraph">
<p><code>shadow-cljs</code> は、 <code>npm</code> パッケージをビルドに含めるためのいくつかの異なる方法をサポートしています。これらの方法は <code>:js-options :js-provider</code> 設定で設定できます。各 <code>:target</code> は通常、ビルドに適したものを設定しますが、ほとんどの場合、この設定を変更する必要はありません。</p>
</div>
<div class="paragraph">
<p>現在、サポートされている JS プロバイダーは 3 つです。</p>
</div>
<div class="dlist Horizontal">
<dl>
<dt><code>:require</code> </dt>
<dd>
<p>JS の <code>require("thing")</code> 関数呼び出しに直接マッピングします。実行時にネイティブで <code>require</code> を解決することができるため、すべての <code>node.js</code> ターゲットのデフォルトとなります。インクルードされた JS は何も処理されません。</p>
</dd>
<dt><code>:shadow</code> </dt>
<dd>
<p>JS を <code>node_modules</code> 経由で解決し、参照されている各ファイルの最小バージョンをビルドに含めます。これは <code>:browser</code> ターゲットのデフォルトです。<code>node_modules</code> のソースは <code>:advanced</code> のコンパイルを通りません。</p>
</dd>
<dt><code>:closure</code> </dt>
<dd>
<p><code>shadow</code> と同様に解決されますが、Closure Compiler CommonJS/ES6 rewrite facilities を通じて、含まれる全てのファイルを処理しようとします。これらのファイルは <code>:advanced</code> のコンパイルでも処理されます。</p>
</dd>
<dt><code>:external</code> </dt>
<dd>
<p>これは、他の JS ビルドツールでも処理できるようになっており、実際に JS の依存関係を提供します。発行されたインデックス・ファイルには、CLJS の出力が JS の依存関係にアクセスできるようにするための、ちょっとしたグルーコードが含まれています。外部インデックスファイルの出力は、CLJS 出力の前に読み込まれなければなりません。</p>
</dd>
</dl>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title"><code>:shadow</code> vs <code>:closure</code></div>
<div class="paragraph">
<p>理想的には、主要な JS プロバイダとして <code>:closure</code> を使用したいところです。しかし実際には、 <code>npm</code> 経由で入手できる多くのコードは、<code>:advanced</code> のコンパイルによる積極的な最適化とは互換性がありません。これらのコードは、まったくコンパイルできないか、実行時に特定が非常に困難な微妙なバグを露呈します。</p>
</div>
<div class="paragraph">
<p><code>shadow</code> は、<code>:simple</code> を介してコードを処理するだけの、その場しのぎのソリューションのようなもので、適度に最適化されたコードを取得しつつ、より信頼性の高いサポートを実現しています。その出力は、 <code>webpack</code> のような他のツールが生成するものと同等(あるいはそれ以上)であることが多いです。</p>
</div>
<div class="paragraph">
<p>Closure のサポートがより確実なものになるまでは、<code>:shadow</code> が <code>:browser</code> ビルドの推奨 JS プロバイダとなります。</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">Example <code>:browser</code> のビルドで <code>:closure</code> を使用するための設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   ...
   :js-options {:js-provider :closure}
   }}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="js-entry-keys"><a class="anchor" href="#js-entry-keys"></a><a class="link" href="#js-entry-keys">12.1.3. CommonJS vs ESM</a></h4>
<div class="paragraph">
<p>最近では、多くの <code>npm</code> パッケージが複数のビルドバリアント(Build Variant)をユーザに提供しています。 <code>shadow-cljs</code> はデフォルトで <code>package.json</code> の <code>main</code> か <code>browser</code> キーの下にリンクされているバリアントを選択します。多くの場合 CommonJS のコードを指しています。</p>
</div>
<div class="paragraph">
<p>最近のパッケージの中には <code>module</code> エントリを提供しているものもありますが、これは通常 ECMAScript のコード (つまりモダンな JS) を指しています。CommonJS と ESM の間の相互運用は難しいので、 <code>shadow-cljs</code> のデフォルトは CommonJS を使用するようになっていますが、ESM を使用することが有益な場合もあります。</p>
</div>
<div class="paragraph">
<p>これが機能するかどうかは、使用しているパッケージに大きく依存します。JS オプションの <code>:entry-keys</code> を使って、<code>module</code> エントリを優先するように <code>shadow-cljs</code> を設定することができます。これは <code>package.json</code> に含まれる文字列キーのベクトルを受け取り、順に試行されます。デフォルトでは <code>"["browser" "main" "module"]</code> となっています。</p>
</div>
<div class="listingblock">
<div class="title">Example :browser のビルドで :closure を使用するための設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   ...
   :js-options {:entry-keys ["module" "browser" "main"]} ;; まずは "module"を試す
   }}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これを切り替える際には、必ず十分なテストを行い、<a href="#build-report">build report</a> の出力を比較してサイズの違いを確認してください。結果は良い意味でも悪い意味でも大きく変わる可能性があります。</p>
</div>
</div>
<div class="sect3">
<h4 id="js-resolve"><a class="anchor" href="#js-resolve"></a><a class="link" href="#js-resolve">12.1.4. パッケージを解決する</a></h4>
<div class="paragraph">
<p>デフォルトでは <code>shadow-cljs</code> はすべての <code>(:require ["thing" :as x])</code> の要求を <code>npm</code> の規則に従って解決します。つまり、 <code>&lt;project&gt;/node_modules/thing/package.json</code> を見て、そこからコードを追っていきます。この動作をカスタマイズするために、 <code>shadow-cljs</code> は <code>:resolve</code> 設定オプションを公開しており、これによって物事がどのように解決されるかをオーバーライドすることができます。</p>
</div>
<div class="sect4">
<h5 id="js-resolve-global"><a class="anchor" href="#js-resolve-global"></a><a class="link" href="#js-resolve-global">CDN の利用</a></h5>
<div class="paragraph">
<p>CDN経由ですでに React がページに含まれているとします。<code>JS/React</code> を再び使い始めることもできますが、私たちは正当な理由でそれをやめました。その代わりに、 <code>(:require ["react" :as react])</code> を使い続けることができますが、"react "がどのように解決されるかを設定することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   ...
   :js-options
   {:resolve {"react" {:target :global
                       :global "React"}}}}

  :server
  {:target :node-script
   ...}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:app</code> のビルドでは、グローバルな <code>React</code> インスタンスが使用され、<code>:server</code> のビルドでは、引き続き "react " npm パッケージが使用されます。これを動作させるためにコードを変更する必要はありません。</p>
</div>
</div>
<div class="sect4">
<h5 id="js-resolve-npm"><a class="anchor" href="#js-resolve-npm"></a><a class="link" href="#js-resolve-npm">require をリダイレクトする</a></h5>
<div class="paragraph">
<p>ビルドに応じて、どの <code>npm</code> パッケージが実際に使用されるかをもっとコントロールしたい場合があります。コードを変更することなく、ビルド設定から特定の require をリダイレクトすることができます。これは、そのようなパッケージを使用しているソースにアクセスできない場合や、あるビルドのためだけに変更したい場合に便利です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   ...
   :js-options
   {:resolve {"react" {:target :npm
                       :require "preact-compat"}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、ファイルを使って依存関係を上書きすることもできます。パスはプロジェクトルートからの相対パスです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   ...
   :js-options
   {:resolve {"react" {:target :file
                       :file   "src/main/override-react.js"}}}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="js-resolve-limitations"><a class="anchor" href="#js-resolve-limitations"></a><a class="link" href="#js-resolve-limitations">制限事項</a></h5>
<div class="paragraph">
<p><code>shadow-js</code> と <code>:closure</code> は <code>:resolve</code> を完全に制御することができ問題なく動作しますが、<code>:js-provider :require</code> はより限定的です。最初の require にのみ影響を与えることができ、それ以降は標準の <code>require</code> が制御します。つまり、パッケージが内部で <code>require</code> するものに影響を与えることはできません。したがって、<code>require</code> を直接使用するターゲット（例：<code>:node-script</code>）と一緒に使用することはお勧めできません。</p>
</div>
<div class="listingblock">
<div class="title">react を preact にリダイレクトする例</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :node-script
   ...
   :js-options
   {:resolve {"react" {:target :npm
                       :require "preact-compat"}}}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example react-table の利用</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.app
  (:require
    ["react-table" :as rt]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>すべての <code>"react"</code> require が置きかえられるため、上記の例はブラウザで問題なく動作します。内部的には <code>"react-table"</code> がもつ <code>"react"</code> require を含みます。しかし <code>:js-provider :require</code> においては、 <code>require("react-table")</code> が emit され、<code>node</code> が解決法をコントロールします。つまり、私たちが設定した <code>"preact"</code> ではなく、標準の <code>"react"</code> に解決されるということです。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="alt-node-modules"><a class="anchor" href="#alt-node-modules"></a><a class="link" href="#alt-node-modules">12.1.5. 代替モジュールのディレクトリ</a></h4>
<div class="paragraph">
<p>デフォルトで <code>shadow-cljs</code> は JS パッケージを解決する際に <code>&lt;プロジェクトディレクトリ&gt;/node_modules</code> のみを見ます。これは、<code>:js-options</code> の <code>:js-package-dirs</code> オプションで設定できます。これは、グローバルまたはビルドごとに適用することができます。</p>
</div>
<div class="paragraph">
<p>相対パスは、プロジェクトのルートディレクトリを基準に解決されます。パスは左から右に向かって試行され、最初にマッチしたパッケージが使用されます。</p>
</div>
<div class="listingblock">
<div class="title">shadow-cljs.edn のグローバル設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :js-options {:js-package-dirs ["node_modules" "../node_modules"]}
 ...}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">単一のビルドに適用される設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {...
   :js-options {:js-package-dirs ["node_modules" "../node_modules"]}}}}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="classpath-js"><a class="anchor" href="#classpath-js"></a><a class="link" href="#classpath-js">12.2. .js ファイルへの対応</a></h3>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>DANGER: この機能は実験的なものです！</strong> 現在は <code>shadow-cljs</code> でのみサポートされており、これを使おうとすると他の CLJS ツールに怒られます。自分の責任で使用してください。この機能は当初、CLJS のコアでは拒否されていましたが、私は便利だと思いますし、さらなる議論なしに <a href="https://dev.clojure.org/jira/browse/CLJS-2061?focusedCommentId=46191&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-46191">dismissed</a> されるべきではなかったと思います。</p>
</div>
<div class="paragraph">
<p>CLJS には <a href="https://clojurescript.org/guides/javascript-modules">implementation</a> という別の実装がありますが、これは <code>shadow-cljs</code> ではサポートされていません。私はこの実装がある種の面で不足していると感じたので、別の解決策を選びました。しかし、両方のアプローチの長所・短所を議論するのは楽しいことです。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>私たちは <a href="#npm">npm</a> パッケージがどのように使用されるかをカバーしましたが、あなたはすでに多くのプレーンな JavaScript を持つコードベースに取り組んでいるかもしれず、まだすべてを ClojureScript で書き直したくはないでしょう。 <code>shadow-cljs</code> は、JavaScript と ClojureScript の間の100%完全な相互運用性を提供します。つまり、あなたの JS はあなたの CLJS を使うことができ、CLJS はあなたの JS を使うことができるということです。</p>
</div>
<div class="paragraph">
<p>この機能を確実に動作させるためには、いくつかの規則に従わなければなりませんが、すでに実行していることもあるでしょう。</p>
</div>
<div class="sect3">
<h4 id="_js_を_require_する"><a class="anchor" href="#_js_を_require_する"></a><a class="link" href="#_js_を_require_する">12.2.1. JS を require する</a></h4>
<div class="paragraph">
<p>先ほど、 <code>npm</code> パッケージに名前でアクセスする方法を説明しましたが、クラスパス上では、 <code>.js</code> ファイルにフルパスまたは現在の名前空間からの相対パスでアクセスします。</p>
</div>
<div class="listingblock">
<div class="title">クラスパスから JS を読み込む</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns demo.app
  (:require
    ["/some-library/components/foo" :as foo]
    ["./bar" :as bar :refer (myComponent)]))</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
文字列が必要な場合、拡張子 <code>.js</code> が自動的に追加されますが、必要に応じて拡張子を指定することができます。ただし、現在は <code>.js</code> のみサポートしています。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>some-library/components/foo</code> のような絶対的な要求は、ローカルファイルシステムからファイルをロードしようとする <code>node</code> とは異なり、コンパイラがクラスパス上で <code>some-library/components/foo.js</code> を探すことを意味します。同じクラスパスのルールが適用されるので、ファイルは <code>:source-paths</code> にあるか、使用しているサードパーティの <code>.jar</code> ライブラリにあるかもしれません。</p>
</div>
<div class="paragraph">
<p>相対的な require は、まず現在の名前空間を見て、その名前からの相対パスを解決します。上の例では、 <code>demo/app.cljs</code> から <code>./bar</code> の require は <code>demo/bar.js</code> に解決されるので、 <code>(:require ["/demo/bar"])</code> と同じになります。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
ファイルは物理的に同じディレクトリにあってはいけません。ファイルの検索は、代わりにクラスパス上で行われます。これは、相対的な要求が常に物理的なファイルに解決されることを期待する node とは異なります。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example パスが分かれているファイル構造</div>
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">.
├── package.json
├── shadow-cljs.edn
└── src
    └── main
        └── demo
            └── app.cljs
    └── js
        └── demo
            └── bar.js</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_言語サポート"><a class="anchor" href="#_言語サポート"></a><a class="link" href="#_言語サポート">12.2.2. 言語サポート</a></h4>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
クラスパスには、コンパイラが前処理をしなくても利用できる JavaScript だけが含まれていることが期待されています。 <code>npm</code> にもよく同様の規約があります。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Closure Compiler は、クラスパス上で見つかった全ての JavaScript を、その言語設定である <code>ECMASCRIPT_NEXT</code> を使って処理します。この設定が正確に何を意味するのかはよくわかっていませんが、ほとんどのブラウザではまだサポートされていないかもしれない次世代の JavaScript コードを表しています。 ES6 は非常によくサポートされており、ほとんどの ES8 の機能もサポートされています。標準的な CLJS と同様に、これは必要に応じてポリフィルを用いて ES5 にコンパイルされます。</p>
</div>
<div class="paragraph">
<p>Closure Compiler は常にアップデートされていますので、新しい機能は徐々に利用可能になっていきます。ただ、最新の最先端のプレビュー機能がすぐに使えるとは思わないでください。最近追加された <code>async/await</code> のような機能は、すでに十分に機能しています。</p>
</div>
<div class="paragraph">
<p>JS は、 <code>import</code> と <code>export</code> を使って、ES モジュール構文を使って書く必要があります。 JS ファイルは、他の JS ファイルをインクルードしたり、CLJS のコードを直接参照することができます。また、<code>npm</code> パッケージに直接アクセスすることもできますが、ひとつ注意点があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">// 標準的な JS の require
import Foo, { something } from "./other.js";

// npm の require
import React from "react";

// CLJS または Closure Library JS の require
import cljs from "goog:cljs.core";

export function inc(num) {
  return cljs.inc(1);
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Closure Compiler の厳密なチェックにより、CLJS や npm のコードを必要とする場合、 <code>import * as X from "npm";</code> の構文を使用することはできません。他の JS ファイルを必要とする場合には問題なく使用できます。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_javascript_の方言"><a class="anchor" href="#_javascript_の方言"></a><a class="link" href="#_javascript_の方言">12.2.3. JavaScript の方言</a></h4>
<div class="paragraph">
<p>一般的な JavaScript の方言（JSX、CoffeeScript など）には、Closure Compiler では直接解析できないものが多いため、クラスパスに置く前に前処理を行う必要があります。 <a href="https://babeljs.io/">babel</a> は JavaScript の世界でよく使われているので、ここでは例として <code>.jsx</code> ファイルを処理するために <code>babel</code> を使用します。</p>
</div>
<div class="listingblock">
<div class="title">Example shadow-cljs.edn の設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:source-paths
 ["src/main"
  "src/gen"]
 ...}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example ファイル構成</div>
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">.
├── package.json
├── shadow-cljs.edn
└── src
    └── main
        └── demo
            └── app.cljs
    └── js
        ├── .babelrc
        └── demo
            └── bar.jsx</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>src/js</code> が <code>:source-paths</code> に追加されていないことに注目してください。これはクラスパスに含まれないことを意味します。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">src/js/demo/bar.jsx</div>
<div class="content">
<pre class="highlight"><code class="language-jsx" data-lang="jsx">import React from "react";

function myComponent() {
  return &lt;h1&gt;JSX!&lt;/h1&gt;;
}

export { myComponent };</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://babeljs.io/docs/usage/cli/">babel</a> を実行してファイルを変換し、設定された <code>src/gen</code> ディレクトリに書き込んでいます。どのディレクトリを使うかはあなた次第です。私は生成されたファイルには <code>src/gen</code> を使いたい。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ babel src/js --out-dir src/gen
# 開発中は次のようにする
$ babel src/js --out-dir src/gen --watch</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>babel</code> 自体は <code>src/js/.babelrc</code> を通して設定されます。公式 <a href="https://babeljs.io/docs/plugins/transform-react-jsx/">example for JSX</a> を参照してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "plugins": ["transform-react-jsx"]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>いったん <code>babel</code> が <code>src/gen/demo/bar.js</code> を書けば、それは ClojureScript を通して使用できるようになり、ClojureScript のソースと同じようにホットロードされることもあります。</p>
</div>
</div>
<div class="sect3">
<h4 id="_js_から_cljs_へのアクセス"><a class="anchor" href="#_js_から_cljs_へのアクセス"></a><a class="link" href="#_js_から_cljs_へのアクセス">12.2.4. JS から CLJS へのアクセス</a></h4>
<div class="paragraph">
<p>JS ソースは、名前空間を <code>goog:</code> というプレフィックスでインポートすることで、すべての ClojureScript（および Closure Library）に直接アクセスすることができます。このプレフィックスは、コンパイラが名前空間をデフォルトの ES6 エクスポートとして公開するように書き換えます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">import cljs, { keyword } from "goog:cljs.core";

// JS で {:foo "hello world"} を作る。
cljs.array_map(keyword("foo"), "hello world");</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
現在は <code>goog:</code> という接頭辞は ES6 形式のファイルでのみ動作します。
<code>require("goog:cljs.core")</code> は動作しません。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cljsjs"><a class="anchor" href="#cljsjs"></a><a class="link" href="#cljsjs">12.3. cljsjs.* の移行について</a></h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>CLJSJS は Javascript のライブラリをパッケージにすることで、 ClojureScript から利用できるようにしようという試みです。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><code>shadow-cljs</code> は <a href="#npm">npm packages</a> に直接アクセスできるので、再パッケージ化された <a href="https://github.com/cljsjs/packages">CLJSJS</a> packages に頼る必要はありません。</p>
</div>
<div class="paragraph">
<p>しかし、多くの CLJS ライブラリはまだ CLJSJS パッケージを使用しており、 <code>shadow-cljs</code> はそれらをもうサポートしていないので、それらは壊れてしまいます。しかし、これらの <code>cljsjs</code> 名前空間を模倣するのはとても簡単です。なぜなら、それらはほとんど <code>npm</code> パッケージから構築されているからです。それには、 <code>cljsjs.thing</code> を元の <code>npm</code> パッケージにマップして、期待されるグローバル変数を公開する shim ファイルが必要です。</p>
</div>
<div class="paragraph">
<p>React の場合は、 <code>src/cljsjs/react.cljs</code> のようなファイルが必要です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns cljsjs.react
  (:require ["react" :as react]
            ["create-react-class" :as crc]))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(js/goog.object.set react "createClass" crc)
(js/goog.exportSymbol "React" react)</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは誰もが手動で行うのは面倒なので、私は <a href="https://github.com/thheller/shadow-cljsjs"><code>shadow-cljsjs</code></a> というライブラリを作りました。
ライブラリを作成しました。すべてのパッケージが含まれているわけではありませんが、これからも追加していきますので、ご協力をお願いします。</p>
</div>
<div class="paragraph">
<p>注：<code>shadow-cljsjs</code> ライブラリは、shim ファイルを提供するだけです。実際のパッケージは、自分で
自分で実際のパッケージを <code>npm install</code> する必要があります。</p>
</div>
<div class="sect3">
<h4 id="_cljsjs_を使いませんか"><a class="anchor" href="#_cljsjs_を使いませんか"></a><a class="link" href="#_cljsjs_を使いませんか">12.3.1. CLJSJS を使いませんか?</a></h4>
<div class="paragraph">
<p>CLJSJS のパッケージは、基本的に <code>npm</code> からパッケージを取り出し、 <code>.jar</code> に入れて <a href="https://clojars.org">clojars</a> で再公開するだけです。おまけに Externs もバンドルされています。コンパイラはこれらのファイルに対して何もせず、生成された出力の先頭に追加するだけです。</p>
</div>
<div class="paragraph">
<p>これは、 <code>npm</code> に直接アクセスできないときには非常に便利でしたが、すべてのパッケージが他のパッケージと簡単に結合できるわけではないので、ある種の問題があります。あるパッケージは <code>react</code> に依存しているかもしれませんが、 <code>npm</code> を通してこれを表現するのではなく、 <a href="https://github.com/cljsjs/packages/tree/master/material-ui">それらは</a> 自分自身の <code>react</code> をバンドルします。注意しないと、 2 つの異なる <code>react</code> バージョンをビルドに含めることになり、非常に紛らわしいエラーが発生したり、少なくともビルドサイズが大幅に大きくなったりする可能性があります。</p>
</div>
<div class="paragraph">
<p>また、すべての <code>npm</code> パッケージが CLJSJS で利用できるわけではなく、パッケージのバージョンを同期させるには手作業が必要なため、パッケージが古くなってしまうこともあります。</p>
</div>
<div class="paragraph">
<p><code>shadow-cljs</code> は、コード内の競合を避けるために、CLJSJS を全くサポートしません。あるライブラリが古い <code>cljsjs.react</code> を使おうとする一方で、別のライブラリはより新しい <code>(:require ["react"])</code> を直接使うかもしれません。そうすると、再びページ上に 2 つのバージョンの <code>react</code> が存在することになります。</p>
</div>
<div class="paragraph">
<p>そのため、唯一欠けているのはバンドルされた Externs です。多くの場合、<a href="#infer-externs">externs inference</a>が改善されたため、これらは必要ありません。また、これらの Externs はサードパーティのツールを使って生成されていることが多いので、いずれにしても完全には正確ではありません。</p>
</div>
<div class="paragraph">
<p>結論: <a href="#npm">npm</a> を直接使う。<a href="#infer-externs">:infer-externs auto</a> を使う。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="release"><a class="anchor" href="#release"></a><a class="link" href="#release">13. プロダクションコードの生成&#8201;&#8212;&#8201;全ターゲット</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>開発モードでは、常に各々の名前空間に対して個別のファイルを出力するため、それらを分離してホットロードすることができます。実際のサーバにコードをデプロイする準備ができたら、Closure Compiler を実行して、それぞれの <a href="#Modules">module</a> に対して単一の最小化された結果を生成します。</p>
</div>
<div class="paragraph">
<p>デフォルトでは、リリースモードの出力ファイルは、開発モードの出力ファイルをそのまま置き換えるようになっています。
これらのファイルを HTML にインクルードする方法に違いはありません。また
ブラウザターゲットでのキャッシュ特性を改善するために <a href="#NameHashing">filename hashing</a> を使用することができます。</p>
</div>
<div class="listingblock">
<div class="title">最小化された出力の生成</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">$ shadow-cljs release build-id</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_リリースの構成"><a class="anchor" href="#_リリースの構成"></a><a class="link" href="#_リリースの構成">13.1. リリースの構成</a></h3>
<div class="paragraph">
<p>通常、ビルド用のリリースバージョンを作成するために、追加の設定をする必要はありません。デフォルトの設定は必要なものをすべて含んでおり、追加の設定が必要になるのは、デフォルトを上書きしたい場合だけです。</p>
</div>
<div class="paragraph">
<p>各 <code>:target</code> には、各プラットフォームに最適化された優れたデフォルトがすでに用意されているので、心配する必要はありません。</p>
</div>
<div class="sect3">
<h4 id="Optimization"><a class="anchor" href="#Optimization"></a><a class="link" href="#Optimization">13.1.1. 最適化</a></h4>
<div class="paragraph">
<p>最適化レベルは、設定の <code>:compiler-options</code> セクションで選択できます。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>:target</code> ではすでに適切なレベルに設定されているので、通常は <code>:optimizations</code> を設定する必要はありません。
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<code>:optimizations</code> は <code>release</code> コマンドを使ったときにのみ適用されます。開発用のビルドは Closure Compiler によって最適化されることはありません。開発用のビルドは常に <code>:none</code> に設定されます。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :build
   {:build-id
     {...
      :compiler-options {:optimizations :simple}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>利用可能な最適化レベルの詳細については <a href="https://developers.google.com/closure/compiler/docs/compilation_levels">Closure コンパイラのドキュメント</a> を参照してください。</p>
</div>
</div>
<div class="sect3">
<h4 id="_release_固有_vs_開発環境"><a class="anchor" href="#_release_固有_vs_開発環境"></a><a class="link" href="#_release_固有_vs_開発環境">13.1.2. release 固有 vs 開発環境</a></h4>
<div class="paragraph">
<p>リリースビルドを実行する際に、ビルド内の設定値を別々にしたい場合は、ビルドセクションに <code>:dev</code> や <code>:release</code> セクションを含めることで、設定を上書きすることができます。</p>
</div>
<div class="listingblock">
<div class="title">Example shadow-cljs.edn ビルド設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:source-paths ["src"]
 :dependencies []
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   :asset-path "/js"
   :modules {:base {:entries [my.app.core]}}

   ;; 開発向けの設定
   :dev {:compiler-options {:devcards true}}

   ;; 本番環境向けの設定
   :release {:compiler-options {:optimizations :simple}}}}}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="externs"><a class="anchor" href="#externs"></a><a class="link" href="#externs">13.2. extern </a></h3>
<div class="paragraph">
<p>Closure Compiler <code>:advanced</code> のコンパイルによってビルドを完全に最適化したいので <a href="https://developers.google.com/closure/compiler/docs/api-tutorial3">Externs</a> を扱う必要があります。 Externs は、<code>:advanced</code> のコンパイルの際に含まれないコードの断片を表します。 <code>advanced</code> はプログラム全体の最適化を行いますが、どうしても含まれないコードもあるため、Externs はコンパイラにそのコードを知らせます。 Externs がないと、コンパイラは含めるべきでないコードの名前を変えたり、削除したりすることがあります。</p>
</div>
<div class="paragraph">
<p>通常、すべての JS Dependencies は外部の扱い(foreign) であり、<code>:advanced</code> ではパスされないため、Externs が必要となります。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
extern が必要なのは <code>:advanced</code> モードのみで、<code>:simple</code> モードでは必要ありません。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="infer-externs"><a class="anchor" href="#infer-externs"></a><a class="link" href="#infer-externs">13.2.1. Externs の推論</a></h4>
<div class="paragraph">
<p>Externs を扱うために、 <code>shadow-cljs</code> コンパイラは、強化された externs の推論を提供します。</p>
</div>
<div class="listingblock">
<div class="title">Example Config</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:infer-externs :auto}
   }}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>auto</code> では、コンパイラはコンパイル時にあなたのファイルだけを対象に追加のチェックを行います。また、ライブラリコードに含まれる externs の問題については警告しません。 <code>all</code> では、すべてのファイルに対して有効になりますが、多くの警告を受ける可能性があることに注意してください。</p>
</div>
<div class="paragraph">
<p>有効にすると、コンパイラが JS と CLJS のどちらのコードを使用しているかを判断できない場合に警告が表示されます。</p>
</div>
<div class="listingblock">
<div class="title">Example Code</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(defn wrap-baz [x]
  (.baz x))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example Warning</div>
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">------ WARNING #1 --------------------------------------------------------------
 File: ~/project/src/demo/thing.cljs:23:3
--------------------------------------------------------------------------------
  21 |
  22 | (defn wrap-baz [x]
  23 |   (.baz x))
---------^----------------------------------------------------------------------
 Cannot infer target type in expression (. x baz)
--------------------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>advanced</code> では、コンパイラが <code>.baz</code> をより短いものにリネームしますが、Externs はこれがリネームしてはいけない外部プロパティであることをコンパイラに知らせます。</p>
</div>
<div class="paragraph">
<p><code>shadow-cljs</code> は、ネイティブな相互運用を行うオブジェクトに typehint を追加すると、適切な externs を生成することができます。</p>
</div>
<div class="listingblock">
<div class="title">extern の生成を助ける型ヒント</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(defn wrap-baz [x]
  (.baz ^js x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>typehint の <code>^js</code> を指定すると、コンパイラが適切な externs を生成するようになり、警告が消えます。これで、このプロパティは名前を変えても大丈夫です。</p>
</div>
<div class="listingblock">
<div class="title">複数の Interop コール</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(defn wrap-baz [x]
  (.foo ^js x)
  (.baz ^js x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interop コールを個別にアノテーションするのは面倒なので、変数のバインディング自体をアノテーションすることができます。この変数は、この変数のスコープ全体で使用されます。両方の呼び出しのextern はまだ生成されます。</p>
</div>
<div class="listingblock">
<div class="title">x を直接アノテーションする</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(defn wrap-baz [^js x]
  (.foo x)
  (.baz x))</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
すべてを <code>^js</code> でアノテーションしないでください。時には、CLJS や ClosureJS のオブジェクトでインターロップを行うことがあります。これらはextern を必要としません。 CLJS オブジェクトを扱うことが確実な場合は、 <code>^clj</code> のヒントを使うことをお勧めします。
間違って <code>^js</code> を使用しても世界の終わりではありませんが、変数の名前を変更できるのに変更されない場合、いくつかの最適化に影響を与える可能性があります。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">ヒントは不要、extern は自動的に推測される</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(js/Some.Thing.coolFunction)</code></pre>
</div>
</div>
<div class="paragraph">
<p>また、<code>:require</code> バインディングの呼び出しも自動的に推論されます。</p>
</div>
<div class="paragraph">
<p><code>.as</code> と <code>:refer</code> のバインディングにヒントは必要ありません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my.app
  (:require ["react" :as react :refer (createElement)]))

(react/createElement "div" nil "hello world")
(createElement "div" nil "hello world")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_手動のextern"><a class="anchor" href="#_手動のextern"></a><a class="link" href="#_手動のextern">13.2.2. 手動のextern</a></h4>
<div class="paragraph">
<p>一部のライブラリでは、extern を個別の <code>.js</code> ファイルとして提供しています。 Externs は、<code>:externs</code> コンパイラオプションを使って、ビルドに組み込むことができます。</p>
</div>
<div class="listingblock">
<div class="title">手動のextern 設定</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:externs ["path/to/externs.js" ...]}
   }}}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
コンパイラは、プロジェクトルートに相対するファイルを最初に探します。ファイルが見つからない場合は、クラスパスからの読み込みも試みます。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_簡易なextern"><a class="anchor" href="#_簡易なextern"></a><a class="link" href="#_簡易なextern">13.2.3. 簡易なextern</a></h4>
<div class="paragraph">
<p>Externs を手動で書くことは困難ですが、<code>shadow-cljs</code> にはより便利な書き方があります。<code>shadow-cljs check &lt;your-build&gt;</code> とすることで、不足している Externs を素速く追加することができます。</p>
</div>
<div class="paragraph">
<p>まず、 <code>externs/&lt;your-build&gt;.txt</code> を作成します。ビルド <code>:app</code> は <code>externs/app.txt</code> となります。このファイルの各行は、名前を変更してはいけない JS のプロパティを1つの単語で指定します。グローバル変数の前には、 <code>global:</code> をつけます。</p>
</div>
<div class="listingblock">
<div class="title">Example externs/app.txt</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure"># これはコメントです。
foo
bar
global:SomeGlobalVariable</code></pre>
</div>
</div>
<div class="paragraph">
<p>この例では、コンパイラは <code>something.foo()</code>, <code>something.bar()</code> という名前の変更を止めます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_コード_ストリッピング"><a class="anchor" href="#_コード_ストリッピング"></a><a class="link" href="#_コード_ストリッピング">13.3. コード・ストリッピング</a></h3>
<div class="paragraph">
<p>Closure コンパイラは、不要なコードを名前で削除することをサポートしています。これにより、通常のデッドコード除去では除去できない、あるいは除去したくないコードを除去することができます。これは、実際に気になるコードが削除される可能性があるため非常に危険ですが、多くの開発者専用コードを簡単に削除することができます。これは 4 つのオプションに分類されていて、そのうち ClojureScript に関連するのはほぼ <code>:strip-type-prefixes</code> だけですが、他にも有用なオプションがあるかもしれません。</p>
</div>
<div class="listingblock">
<div class="title">Example cljs.pprint のすべての使用を削除</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{...
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:strip-type-prefixes #{"cljs.pprint"}
   }}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これらのオプションは、それぞれ文字列のセットとして指定されます。ここで指定されている名前はすべて JS の名前なので、特定の CLJS の名前はマングされなければならないことに注意してください。<code>my-lib.core</code> は <code>my_lib.core</code> となります。</p>
</div>
<div class="dlist Horizontal">
<dl>
<dt><code>:strip-types</code> </dt>
<dd>
<p>deftype/defrecord の宣言や使用を削除できるようにします。<code>#{"my.ns.FooBar}</code> は <code>(defrecord FooBar [])</code> を削除します。</p>
</dd>
<dt><code>:strip-type-prefixes</code> </dt>
<dd>
<p>与えられた Prefix のいずれかで始まるものをすべて削除します。 CLJS の名前空間全体を削除することができます。</p>
</dd>
<dt><code>:strip-name-prefixes</code> </dt>
<dd>
<p>与えられたプレフィックスで始まるすべてのプロパティを削除します。プレフィックスでプロパティを削除することができます。<code>#{"log"}</code> は <code>this.logX</code> や <code>(defn log-me [&#8230;&#8203;])</code> を削除します。</p>
</dd>
<dt><code>:strip-name-suffixes</code> </dt>
<dd>
<p>サフィックスでプロパティを削除することができます。<code>#{"log"}</code> は <code>this.myLog</code> または <code>(defn my-log [&#8230;&#8203;])</code> を削除します。</p>
</dd>
</dl>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>DANGER: これらのオプションには注意が必要です。これらのオプションはビルド全体に適用され、実際に必要なコードが削除される可能性があります。また、自分が書いたものではないライブラリのコードを誤って削除してしまう可能性もあります。このオプションを使用する前に、必ず他のオプションを検討してください。</strong></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="build-report"><a class="anchor" href="#build-report"></a><a class="link" href="#build-report">13.4. ビルドレポート</a></h3>
<div class="paragraph">
<p><code>shadow-cljs</code> では、 <code>release</code> のビルドに対して、含まれているソースの詳細な内訳と、それぞれが全体のサイズにどれだけ貢献しているかを含む、詳細なレポートを生成することができます。</p>
</div>
<div class="paragraph">
<p>レポートのサンプルは <a href="https://code.thheller.com/demos/build-report/huge.html">こちら</a>をご覧ください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ npx shadow-cljs run shadow.cljs.build-report &lt;build-id&gt; &lt;path/to/output.html&gt;
# 例
$ npx shadow-cljs run shadow.cljs.build-report app report.html</code></pre>
</div>
</div>
<div class="paragraph">
<p>上記の例では、<code>:app</code> をビルドする際に、プロジェクトディレクトリに <code>report.html</code> を生成します。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
生成される <code>report.html</code> は完全に自己完結型で、必要なデータ/js/css をすべて含んでいます。他の外部ソースは必要ありません。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_エディタの統合"><a class="anchor" href="#_エディタの統合"></a><a class="link" href="#_エディタの統合">14. エディタの統合</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_cursive"><a class="anchor" href="#_cursive"></a><a class="link" href="#_cursive">14.1. Cursive</a></h3>
<div class="paragraph">
<p>Cursive は現在、 <code>shadow-cljs.edn</code> による依存関係の解決をサポートしていません。 <code>shadow-cljs pom</code> を実行して <code>pom.xml</code> を生成し、それを IntelliJ.NET を使ってインポートすることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">$ shadow-cljs pom</code></pre>
</div>
</div>
<div class="paragraph">
<p>続いて、Cursive の File &#8594; New &#8594; Project from Existing Sources で、プロジェクトディレクトリに生成された <code>pom.xml</code> を選択します。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
このためには、Build Tools→Maven プラグインを有効にする必要があります。デフォルトでは有効になっていない場合があります。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>あるいは、ダミーの <code>project.clj</code> を作成したり、完全な<a href="#Leiningen">Leiningen integration</a>を使用することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(defproject your/project "0.0.0"
  :dependencies
  [[thheller/shadow-cljs "X.Y.Z"]]

  :source-paths
  ["src"])</code></pre>
</div>
</div>
<div class="paragraph">
<p>IntelliJ が提供する Terminal の中で <code>npx shadow-cljs server</code> を実行し、 <code>Clojure REPL &#8594; Remote</code> Run Configuration を使って、提供される<a href="#nREPL">nREPL server</a>に接続することができます。Cursive Clojure REPL &#8594; Remote で "Use port from nREPL file "オプションを選択するか、お好みで固定の nREPL ポートを設定するだけです。</p>
</div>
<div class="paragraph">
<p>最初に接続したときの Cursive REPL は、常に CLJ REPL として起動することに注意してください。これを CLJS に切り替えるには、 <code>(shadow/repl :your-build-id)</code> を呼び出します。これにより、自動的に Cursive オプションも切り替わります。CLJ REPL に戻るには、<code>:cljs/quit</code> と入力します。</p>
</div>
</div>
<div class="sect2">
<h3 id="cider"><a class="anchor" href="#cider"></a><a class="link" href="#cider">14.2. Emacs / CIDER</a></h3>
<div class="paragraph">
<p>このセクションは、CIDER のバージョン 0.20.0 以上を対象に書かれています。お使いの Emacs にこのバージョンの <code>cider</code> パッケージが入っていることを確認してください。インストールの詳細については、リンク: <a href="https://docs.cider.mx">CIDER documentation</a> を参照してください。</p>
</div>
<div class="sect3">
<h4 id="_clojurescript_repl_の起動"><a class="anchor" href="#_clojurescript_repl_の起動"></a><a class="link" href="#_clojurescript_repl_の起動">14.2.1. ClojureScript REPL の起動</a></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">M-x cider-jack-in-cljs</code></pre>
</div>
</div>
<div class="paragraph">
<p>CIDER は、ClojureScript REPL の種類を尋ねてきます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">Select ClojureScript REPL type:</code></pre>
</div>
</div>
<div class="paragraph">
<p>ClojureScript REPL タイプを選択します。</p>
</div>
<div class="paragraph">
<p>shadow と入力します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">Select shadow-cljs build:</code></pre>
</div>
</div>
<div class="paragraph">
<p>ビルドターゲットの名前を入力してください（例：<code>app</code>）。</p>
</div>
<div class="paragraph">
<p>Emacs は、その兄弟の <code>shadow-cljs</code> サーバへの新しい nREPL 接続を開き、ClojureScript REPL 環境にブートストラップします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">shadow.user&gt; To quit, type: :cljs/quit
[:selected :app]
cljs.repl&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、ClojureScript を評価したり、 <code>cider-find-var</code> で変数の定義にジャンプしたりすることができるようになります。</p>
</div>
<div class="paragraph">
<p>例えば、ブラウザにアラートを表示する場合などです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">cljs.repl&gt; (js/alert "Jurassic Park!")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dir_local_によるスタートアップの簡素化"><a class="anchor" href="#_dir_local_によるスタートアップの簡素化"></a><a class="link" href="#_dir_local_によるスタートアップの簡素化">14.2.2. dir-local によるスタートアップの簡素化</a></h4>
<div class="paragraph">
<p>プロジェクトのルートに <code>.dir-locals.el</code> ファイルを作成することで、スタートアップの流れを簡単にすることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">((nil . ((cider-default-cljs-repl . shadow)
	 (cider-shadow-default-options . "&lt;自身のビルド名&gt;"))))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_proto_repl_atom"><a class="anchor" href="#_proto_repl_atom"></a><a class="link" href="#_proto_repl_atom">14.3. Proto REPL (Atom)</a></h3>
<div class="paragraph">
<p>Proto REPL は主に Clojure の開発を目的としており、大半の機能は ClojureScript では動作しません。単純な評価のためにそれを使用することは可能です。</p>
</div>
<div class="paragraph">
<p>使えるようにするには、いくつかの設定が必要です。</p>
</div>
<div class="paragraph">
<p>(1) <code>:source-paths</code> の中に、 <code>user.clj</code> を作成します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure"> (ns user)

 (defn reset [])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Proto REPL は接続時にこの fn を呼び出すので、このファイルは <code>user/reset</code> fn を定義していなければなりません。</p>
</div>
<div class="paragraph">
<p>もし <code>user/reset</code> が見つからなければ、<code>tools.namespace</code> が呼び出され、実行中の <code>shadow-cljs</code> サーバが破壊されます。私たちはこれを望んでいません。ここで何かできるかもしれませんが、CLJS のために何かする必要はありません。</p>
</div>
<div class="paragraph">
<p>(2) <a href="#user-config">~/.shadow-cljs/config.edn</a> または <code>shadow-cljs.edn</code> の <code>:dependencies</code> に <code>[proto-repl "0.3.1"]</code> を追加してください。</p>
</div>
<div class="paragraph">
<p>(3) 固定の<a href="#nREPL">nREPL ポート</a>を設定する</p>
</div>
<div class="paragraph">
<p>(4) <code>shadow-cljs server</code> または <code>shadow-cljs watch your-build</code> を起動します。</p>
</div>
<div class="paragraph">
<p>(5) Atom コマンド <code>Proto Repl: Remote Nrepl Connection</code> で <code>localhost</code> と設定したポートに接続します。</p>
</div>
<div class="paragraph">
<p>(6) <code>(shadow.cljs.devtools.api/watch :your-build)</code> を評価する (4 で <code>server</code> を使用した場合)</p>
</div>
<div class="paragraph">
<p>(7) <code>(shadow.cljs.devtools.api/nrepl-select :your-build)</code> を評価します。 REPL 接続は CLJS モードになり、評価するものはすべて JS で評価されることになります。 Clojure モードに戻るには、<code>:repl/quit</code> とすることができます。もし <code>[:no-worker :browser]</code> が出たら、まず <code>watch</code> を起動する必要があります。</p>
</div>
<div class="paragraph">
<p>(8) CLJS を評価する前に、クライアントを接続する必要があります（例：<code>:browser</code> App を構築する際のブラウザ）。</p>
</div>
<div class="paragraph">
<p>(9) <code>(js/alert "foo")</code> のように、いくつかの JS を評価します。接続されている JS ランタイムがありませんと表示される場合は、クライアントが正しく接続されていません。それ以外の場合は、ブラウザにアラートが表示されます。</p>
</div>
</div>
<div class="sect2">
<h3 id="_chlorine_atom"><a class="anchor" href="#_chlorine_atom"></a><a class="link" href="#_chlorine_atom">14.4. Chlorine (Atom)</a></h3>
<div class="paragraph">
<p>Chlorine は、Atom を Socket REPL に接続しますが、同時に名前空間のリフレッシュも試みます。まず、Chlorine パッケージのコンフィグを開き、コンフィグ <code>Should we use clojure.tools.namespace to refresh</code> が <code>simple</code> に設定されているかどうかを確認します。そうしないと、実行中の <code>shadow-cljs</code> サーバが破壊されてしまいます。</p>
</div>
<div class="paragraph">
<p>設定が正しいことを確認したら、shadow アプリを起動できます（<code>app</code> は任意のビルドに置き換えてください）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">$ shadow-cljs watch app</code></pre>
</div>
</div>
<div class="paragraph">
<p>あとは、atom コマンドの <code>Chlorine: Connect Clojure Socket Repl</code>. これで Clojure のコードを評価する REPL が接続されます。次に、 <code>Chlorine: Connect Clojure Socket Repl</code> を実行してください。 <code>Connect Embeded</code> を実行すると、ClojureScript の REPL も接続されます。</p>
</div>
<div class="paragraph">
<p>これで、 <code>Chlorine: Evaluate&#8230;&#8203;</code> コマンドを使って、任意の Clojure または ClojureScript REPL を評価することができます。 <code>.clj</code> ファイルは Clojure として、 <code>cljc</code> ファイルは ClojureScript として評価されます。</p>
</div>
</div>
<div class="sect2">
<h3 id="_calva_vs_code"><a class="anchor" href="#_calva_vs_code"></a><a class="link" href="#_calva_vs_code">14.5. Calva (VS Code)</a></h3>
<div class="paragraph">
<p>今のところ <code>browser</code> ターゲットでしかテストしていません。おそらく他のターゲットでも動作します。</p>
</div>
<div class="sect3">
<h4 id="_依存関係_2"><a class="anchor" href="#_依存関係_2"></a><a class="link" href="#_依存関係_2">14.5.1. 依存関係</a></h4>
<div class="paragraph">
<p>VS Code が必要で <a href="https://marketplace.visualstudio.com/items?itemName=betterthantomorrow.calva#overview">Calva</a>エクステンションをインストールする必要があります。</p>
</div>
<div class="paragraph">
<p>Calva は nREPL と <code>cider-nrepl</code> のミドルウェアを使用しているので、この依存関係を <a href="#user-config">~/.shadow-cljs/config.edn</a> または <code>shadow-cljs.edn</code> に含める必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">[cider/cider-nrepl "0.21.0"]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>shadow-cljs</code> は、この依存関係を確認すると、必要な <code>cider-nrepl</code> ミドルウェアを注入します。</p>
</div>
</div>
<div class="sect3">
<h4 id="_calva_と_repl_の接続"><a class="anchor" href="#_calva_と_repl_の接続"></a><a class="link" href="#_calva_と_repl_の接続">14.5.2. Calva と REPL の接続</a></h4>
<div class="paragraph">
<p>それが終わったら、shadow app を起動します。(<code>app</code> の代わりにどんなビルドでも使用します)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">$ shadow-cljs watch app</code></pre>
</div>
</div>
<div class="paragraph">
<p>アプリがブラウザに読み込まれ、アプリを起動したターミナルに JS runime connected と表示されると、Calva はそのレプリケーションに接続できるようになります。VS Code でプロジェクトを開くと、Calva はデフォルトで自動接続を試み、 <code>shadow-cljs.edn</code> から読み込んだビルドのリストを表示します。正しいもの(この例では <code>:app</code>)を選択すると、Calva の Clojure と Clojurescript のサポートが有効になります。</p>
</div>
<div class="paragraph">
<p>アプリ起動時にすでに VS Code でプロジェクトを開いている場合は、コマンドを実行してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">Calva: Connect to a Running REPL Server in the Project</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_特徴"><a class="anchor" href="#_特徴"></a><a class="link" href="#_特徴">14.5.3. 特徴</a></h4>
<div class="paragraph">
<p>利用可能んs機能の一部をご紹介します。</p>
</div>
<div class="sect4">
<h5 id="_intellisense_など"><a class="anchor" href="#_intellisense_など"></a><a class="link" href="#_intellisense_など">Intellisense など</a></h5>
<div class="ulist">
<ul>
<li>
<p>hover で定義を見る</p>
</li>
<li>
<p>自動補完のヘルプを表示する</p>
</li>
<li>
<p>定義ファイルへの移動（Mac では <code>cmd-click</code>、Windows や Linux では <code>ctrl-click</code> ）。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_ファイル_フォーム_セレクションの評価"><a class="anchor" href="#_ファイル_フォーム_セレクションの評価"></a><a class="link" href="#_ファイル_フォーム_セレクションの評価">ファイル、フォーム、セレクションの評価</a></h5>
<div class="ulist">
<ul>
<li>
<p>ファイルを評価する: <code>ctrl+alt+c enter</code> (ファイルを開くときに自動的に行われます。)</p>
</li>
<li>
<p>インライン評価をする: <code>ctrl+alt+c e</code>.</p>
</li>
<li>
<p>エディタ内で評価して置きかえる: <code>ctrl+alt+c r</code>.</p>
</li>
<li>
<p>評価結果を整形して表示する: <code>ctrl+alt+c p</code>.</p>
</li>
<li>
<p>評価のために統合ターミナルの repl にフォームを送る: <code>ctrl+alt+c alt+e</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_テストの実行"><a class="anchor" href="#_テストの実行"></a><a class="link" href="#_テストの実行">テストの実行</a></h5>
<div class="ulist">
<ul>
<li>
<p>名前空間のテストを実行する: <code>ctrl+alt+c t</code></p>
</li>
<li>
<p>すべてのテストを実行する: <code>ctrl+alt+c shift+t</code> (これまでの大規模プロジェクトでは非常に不便でした)</p>
</li>
<li>
<p>以前に失敗したテストを再実行する: <code>ctrl+alt+c ctrl+t</code> (テストの失敗はエクスプローラーやエディタでマークされ、簡単にアクセスできるように Problem タブにリストアップされます)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_ターミナルの_repl"><a class="anchor" href="#_ターミナルの_repl"></a><a class="link" href="#_ターミナルの_repl">ターミナルの REPL</a></h5>
<div class="ulist">
<ul>
<li>
<p>ターミナルレプリの名前空間を、現在開いているファイルの名前空間に切り替える: <code>ctrl+alt+c n</code></p>
</li>
<li>
<p>現在のファイルを読み込んで、名前空間を切り替える: <code>ctrl+alt+c alt+n</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_cljc_のファイル群"><a class="anchor" href="#_cljc_のファイル群"></a><a class="link" href="#_cljc_のファイル群">Cljc のファイル群</a></h5>
<div class="ulist">
<ul>
<li>
<p>Clojure と Clojurescript の repl を <code>ctrl+alt+c ctrl+alt+t</code> で切り替えます。または、ステータスバーの緑の <code>cljc/clj</code> ボタンをクリックすることでも可能です。これにより、どの repl がエディタをバックアップしているか、どの端末の repl にアクセスしているかの両方が決定されます（上記参照）。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fireplace_vim_vim_neovim"><a class="anchor" href="#_fireplace_vim_vim_neovim"></a><a class="link" href="#_fireplace_vim_vim_neovim">14.6. Fireplace.vim (Vim/Neovim)</a></h3>
<div class="paragraph">
<p><a href="https://www.vim.org/scripts/script.php?script_id=4978">Fireplace.vim</a> は <a href="https://nrepl.org/">nREPL</a> クライアントとして動作することで、Clojure REPL の統合を提供する Vim/Neovim プラグインです。Shadow-CLJS と組み合わせることで、ClojureScript REPL の統合も可能になります。</p>
</div>
<div class="paragraph">
<p>このガイドでは、公式 <a href="https://github.com/thheller/shadow-cljs#quick-start">Shadow-CLJS Quick Start</a> ガイドで作成されたアプリを例にしているため、アプリの <code>shadow-cljs.edn</code> にあるいくつかの設定項目を参照しています。とはいえ、これらの設定項目はかなり一般的なものなので、ちょっとした修正で他のアプリにも適用できるはずです。</p>
</div>
<div class="sect3">
<h4 id="_依存関係_3"><a class="anchor" href="#_依存関係_3"></a><a class="link" href="#_依存関係_3">14.6.1. 依存関係</a></h4>
<div class="paragraph">
<p><a href="https://www.vim.org/scripts/script.php?script_id=4978">Fireplace.vim</a> を、Vim/Neovim でプラグインをインストールするお好みの方法でインストールします。</p>
</div>
<div class="paragraph">
<p><a href="https://nrepl.org/">nREPL</a> クライアントとして <a href="https://www.vim.org/scripts/script.php?script_id=4978">Fireplace.vim</a> は <a href="https://docs.cider.mx/cider-nrepl/">CIDER-nREPL</a> (これは一般的なエディタに依存しない REPL 操作を提供する nREPL ミドルウェアです)に依存しているため、この依存関係を<a href="#user-config">~/.shadow-cljs/config.edn </a> または <code>shadow-cljs.edn</code> (次のサブセクションで示すように) にこの依存関係を含める必要があります。Shadow-CLJS は、この依存関係を確認すると、必要な CIDER-nREPL ミドルウェアを注入します。</p>
</div>
</div>
<div class="sect3">
<h4 id="_アプリの準備"><a class="anchor" href="#_アプリの準備"></a><a class="link" href="#_アプリの準備">14.6.2. アプリの準備</a></h4>
<div class="paragraph">
<p>公式ガイドの <a href="https://github.com/thheller/shadow-cljs#quick-start">Shadow-CLJS Quick Start</a> に沿ってサンプルアプリを作成し、<code>shadow-cljs.edn</code> を以下のように修正します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">;; shadow-cljs の設定
{:source-paths
 ["src/dev"
  "src/main"
  "src/test"]

 ;; 追加 - Fireplace.vim で必要な CIDER-nREPL ミドルウェア
 :dependencies
 [[cider/cider-nrepl "0.22.4"]]

 ;; 追加 - Fireplace.vim が接続する REPL サーバーのポート(例：3333)
 :nrepl
 {:port 3333}

 ;; 追加 - アプリを提供する開発時の HTTP サーバーのポート(例：8080)
 :dev-http
 {8080 "public"}

 :builds
 {:frontend  ; 注：これは以下の各所で参照されているビルド ID です。
  {:target :browser
   :modules {:main {:init-fn acme.frontend.app/init}}}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これが完了したら、アプリを起動します（ <code>shadow-cljs.edn</code> で指定されている Shadow-CLJS のビルド ID、<code>frontend</code> に注意してください）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sh" data-lang="sh">npx shadow-cljs watch frontend</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://localhost:8080/" class="bare">http://localhost:8080/</a> 、ブラウザでアプリを開きます。この手順を行わないと、Vim/Neovim 内から REPL サーバに接続しようとすると <a href="https://www.vim.org/scripts/script.php?script_id=4978">Fireplace.vim</a> から次のようなエラーメッセージが表示されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">No application has connected to the REPL server.
Make sure your JS environment has loaded your compiled ClojureScript code.</code></pre>
</div>
</div>
<div class="paragraph">
<p>どのアプリケーションも REPL サーバに接続していません。
JS環境がコンパイルした ClojureScript コードを読み込んでいることを確認してください。</p>
</div>
</div>
<div class="sect3">
<h4 id="_fireplace_vim_と_repl_サーバの接続"><a class="anchor" href="#_fireplace_vim_と_repl_サーバの接続"></a><a class="link" href="#_fireplace_vim_と_repl_サーバの接続">14.6.3. Fireplace.vim と REPL サーバの接続</a></h4>
<div class="paragraph">
<p>Vim/Neovim で ClojureScript のソースファイルを開き、以下のコマンドを実行して <a href="https://www.vim.org/scripts/script.php?script_id=4978">Fireplace.vim</a> を REPL サーバに接続します（REPL サーバのポートは、 <code>shadow-cljs.edn</code> で指定されている <code>3333</code> であることに注意してください）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">:Connect 3333
=&gt;
Connected to nrepl://localhost:3333/
Scope connection to: ~/code/clojurescript/acme-app (ENTER)</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、（ClojureScript ではなく）Clojure の REPL セッションが作成されます。次のコマンドを実行して、セッションに ClojureScript のサポートを追加します ( <code>shadow-CLJS.edn</code> で指定されている Shadow-CLJS のビルド ID、 <code>frontend</code> に注意してください)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">:CljEval (shadow/repl :frontend)
=&gt;
To quit, type: :cljs/quit
[:selected :frontend]
Press ENTER or type command to continue</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、REPL サーバに対して <a href="https://www.vim.org/scripts/script.php?script_id=4978">Fireplace.vim</a> コマンドが実行できるようになります。実行可能なコマンドの全リストについては <a href="https://www.vim.org/scripts/script.php?script_id=4978">Fireplace.vim</a> のドキュメントを参照してください。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_トラブルシューティング"><a class="anchor" href="#_トラブルシューティング"></a><a class="link" href="#_トラブルシューティング">15. トラブルシューティング</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="failed-to-load"><a class="anchor" href="#failed-to-load"></a><a class="link" href="#failed-to-load">15.1. 起動時のエラー</a></h3>
<div class="paragraph">
<p>時々 <code>shadow-cljs</code> が正しく起動しないことがあります。このエラーはしばしば非常に分かりづらく、特定するのが困難です。最も一般的な原因は、いくつかの重要な依存関係が衝突していることです。単に <code>:dependencies</code> の管理に <code>shadow-cljs.edn</code> を使用している場合には、これらの種類のエラーから守るためにいくつかの特別なチェックを行いますが、 <code>deps.edn</code> や <code>project.clj</code> を使用している場合には、これらの保護を行うことができないため、これらのツールを使用している場合には、これらのエラーがより頻繁に発生します。</p>
</div>
<div class="paragraph">
<p>一般的に、注意すべき重要な依存関係は以下の通りです。</p>
</div>
<div class="paragraph">
<p>各 <code>shadow-cljs</code> バージョンは、ある特定のバージョンの組み合わせでしかテストされておらず、最良の互換性を得るためには、そのバージョンセットに固執することが推奨されます。異なるバージョンを使用している場合でも動作するかもしれませんが、何らかのおかしな問題が発生した場合は、まず依存するバージョンの修正を検討してください。</p>
</div>
<div class="paragraph">
<p>各バージョンに必要な依存関係は、clojars で確認できます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://clojars.org/thheller/shadow-cljs" class="bare">https://clojars.org/thheller/shadow-cljs</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これらの問題を診断する方法はツールによって異なりますので、詳細は該当するセクションを参照してください。</p>
</div>
<div class="paragraph">
<p>一般的に、確実にしたいのであれば、選択した <code>shadow-cljs</code> のバージョンと一緒に、一致する依存関係のバージョンを直接宣言すればよいのですが、それは <code>shadow-cljs</code> をアップグレードするたびに、それらのバージョンも更新しなければならないことを意味します。不要な依存関係を正しく特定することは、より多くの作業を必要とするかもしれませんが、将来のアップグレードを容易にするでしょう。</p>
</div>
<div class="paragraph">
<p><code>shadow-cljs</code> は、上に挙げたすべての依存関係について常に最新のバージョンである可能性が高いため、古い依存関係を維持する必要がある場合は、shadow-cljs のバージョンも古いものにする必要があるかもしれません。</p>
</div>
<div class="paragraph">
<p>そのため、 <code>org.clojure/clojurescript</code> が通常提供しているバージョンに依存していると、問題が発生する可能性があります。そのため、 <code>org.clojure/clojurescript</code> が通常供給するバージョンに依存している場合、問題が発生する可能性があります。</p>
</div>
<div class="paragraph">
<p>もし、あなたの生活をより楽にしたいのであれば、できれば <code>shadow-cljs.edn</code> を使って依存関係を管理してください。このような問題が発生する可能性は非常に低いですし、少なくともあなたに直接警告してくれます。</p>
</div>
<div class="paragraph">
<p>正しいバージョンを入手したにもかかわらず、問題が解決しない場合は <a href="https://github.com/thheller/shadow-cljs/issues">Github Issue</a>を開き、依存関係のリストを含む問題の詳細をご報告ください。</p>
</div>
<div class="sect3">
<h4 id="_deps_edn_tools_deps"><a class="anchor" href="#_deps_edn_tools_deps"></a><a class="link" href="#_deps_edn_tools_deps">15.1.1. deps.edn / tools.deps</a></h4>
<div class="paragraph">
<p><code>shadow-cljs.edn</code> の <a href="#tools-deps">:deps</a> キーで依存関係を管理するために <code>deps.edn</code> を使用している場合、さらなる診断のために <code>clj</code> ツールを直接使用することが推奨されます。まず最初に、あなたが <code>shadow-cljs.edn</code> を通してどのエイリアスを適用しているかを確認する必要があります。つまり、もしあなたが <code>:deps {:aliases [:dev :cljs]}</code> を設定しているのであれば、さらにコマンドを実行する際に、これらのエイリアスを指定する必要があります。</p>
</div>
<div class="paragraph">
<p>まず最初に、 <code>deps.edn</code> で直接宣言されているすべての依存関係が、期待されるバージョンであることを確認する必要があります。推移的な依存関係によって、問題のあるバージョンが含まれていることがあります。すべての依存関係をリストアップするには、以下の方法があります。</p>
</div>
<div class="listingblock">
<div class="title">アクティブな依存関係をすべてリストアップ</div>
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ clj -A:dev:cljs -Stree</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、すべての依存関係がリストアップされます。これを追いかけるのはちょっと大変ですが、上述の依存関係のために正しいバージョンを取得しているかどうかを確認する必要があります。</p>
</div>
<div class="paragraph">
<p>詳細は <a href="https://clojure.org/reference/deps_and_cli">tools.deps</a>の公式ドキュメントをご参照ください。</p>
</div>
</div>
<div class="sect3">
<h4 id="_project_clj_leiningen"><a class="anchor" href="#_project_clj_leiningen"></a><a class="link" href="#_project_clj_leiningen">15.1.2. project.clj / Leiningen</a></h4>
<div class="paragraph">
<p><code>project.clj</code> を使って依存関係を管理している場合、 <code>lein</code> を直接使って問題を診断するときには、 <code>shadow-cljs.edn</code> から設定した <code>:lein</code> プロファイルを指定する必要があります。例えば、<code>:lein {:profiles "+cljs"}</code> とすると、すべてのコマンドに対して <code>lein with-profiles +cljs</code> が必要になります。</p>
</div>
<div class="listingblock">
<div class="title">Example deps のリスト</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure"># no profile
$ lein deps :tree

# with profile
$ lein with-profiles +cljs deps :tree</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは通常、一番上に現在のコンフリクトをすべてリストアップし、一番下に依存関係のツリーで提案を提供します。提案は必ずしも完全には正確ではありませんので、誤解を招かないように、また <code>thheller/shadow-cljs</code> アーティファクトに除外項目を追加しないようにしてください。</p>
</div>
<div class="paragraph">
<p>詳しくは <a href="https://leiningen.org/">Leiningen</a> のドキュメントをご参照ください。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repl-troubleshooting"><a class="anchor" href="#repl-troubleshooting"></a><a class="link" href="#repl-troubleshooting">15.2. REPL</a></h3>
<div class="paragraph">
<p>CLJS REPL を動作させることは、時として厄介であり、すべての可動部品が非常に複雑であるため、多くの問題が発生する可能性があります。このガイドでは、人々が遭遇する最も一般的な問題と、その解決方法を取り上げたいと思います。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="assets/img/shadow-cljs-repl.png" alt="shadow cljs repl">
</div>
</div>
<div class="sect3">
<h4 id="cljs-repl-anatomy"><a class="anchor" href="#cljs-repl-anatomy"></a><a class="link" href="#cljs-repl-anatomy">15.2.1. CLJS REPL の分析</a></h4>
<div class="paragraph">
<p>Clojure の REPL は、その名が示す通りのことを行います。 1 つのフォームを読み、それを評価し、結果を print し、それを再び行うためにループします。</p>
</div>
<div class="paragraph">
<p>しかし、ClojureScript では、コンパイルは JVM上で行われますが、結果は JavaScript ランタイムで評価されるので、もう少し複雑です。普通の REPL の経験をエミュレートするためには、さらにいくつかのステップが必要になります。 <code>shadow-cljs</code> では、通常の CLJS とは実装が少し異なりますが、基本的な原理は同じです。</p>
</div>
<div class="paragraph">
<p>まず、REPL クライアントが必要です。これは単に CLI (例: <code>shadow-cljs cljs-repl app</code>) または <code>nREPL</code> を介して接続されたエディタかもしれません。クライアントは常に <code>shadow-cljs</code> サーバと直接会話し、残りの部分は <code>shadow-cljs</code> が処理します。クライアント側からは、まだ通常の REPL のように見えますが、バックグラウンドではさらにいくつかのステップが行われています。</p>
</div>
<div class="paragraph">
<p>1) Read : すべては与えられた InputStream から単数の CLJS フォームを読み取ることから始まります。これは <code>stdin</code> から直接ブロック化して読み取るか、 <code>nREPL</code> の場合は文字列から読み取ることになります。文字のストリームは実際のデータストラクチャーに変えられ、 <code>"(+ 1 2)"</code> (文字列)は <code>(+ 1 2)</code> (リスト)になります。</p>
</div>
<div class="paragraph">
<p>2）Compile : そのフォームは、 <code>shadow-cljs</code> JVM 側でコンパイルされ、一連の命令に変換されます。</p>
</div>
<div class="paragraph">
<p>3）Transfer Out : これらの命令は、接続された JavaScript ランタイムに転送されます。これはブラウザであったり、 <code>node</code> プロセスであったりします。</p>
</div>
<div class="paragraph">
<p>4) 評価 : 接続されたランタイムは、受け取った命令を <code>eval</code> します。</p>
</div>
<div class="paragraph">
<p>5) Print : JS ランタイムでは、 <code>eval</code> の結果が文字列として出力されます．</p>
</div>
<div class="paragraph">
<p>6) Transfer Back :  Print された結果は、 <code>shadow-cljs</code> の JVM 側に転送されます。</p>
</div>
<div class="paragraph">
<p>7) Reply :  JVM 側は受信した結果を最初の呼び出し元に転送し、結果は適切な OutputStream にプリントされます（または nREPL メッセージとして送信されます）。</p>
</div>
<div class="paragraph">
<p>8）Loop :  1）から繰り返します。</p>
</div>
</div>
<div class="sect3">
<h4 id="_javascript_のランタイム"><a class="anchor" href="#_javascript_のランタイム"></a><a class="link" href="#_javascript_のランタイム">15.2.2. JavaScript のランタイム</a></h4>
<div class="paragraph">
<p><code>shadow-cljs</code> の JVM 側では、関連するすべての REPL コマンドを処理する、与えられたビルドのための <code>watch</code> の実行が必要になります。これは専用のスレッドを使用し、開発中に起こりうるすべてのイベントを管理します（例：REPL の入力、ファイルの変更など）。</p>
</div>
<div class="paragraph">
<p>しかし、コンパイルされた JS コードは、JS ランタイム(例えば、ブラウザや <code>node</code> プロセス)によって読み込まれなければならず、その JS ランタイムは実行中の <code>shadow-cljs</code> プロセスに接続しなければなりません。ほとんどの <code>:target</code> 設定では、必要なコードがデフォルトで追加されており、自動的に接続されるはずです。その接続がどのように行われるかはランタイムに依存しますが、通常は WebSocket を使用して、実行中の <code>shadow-cljs</code> <a href="#http">HTTP server</a> に接続します。</p>
</div>
<div class="paragraph">
<p>接続が完了すると、REPL を使用できるようになります。 JS ランタイムをリロード（例：ブラウザのページを手動でリロード）すると、ランタイムのすべての REPL の状態が消去されますが、コンパイラ側の状態の一部は、 <code>watch</code> が再起動されるまで残りますのでご注意ください。</p>
</div>
<div class="paragraph">
<p>複数の JS ランタイムが <code>watch</code> プロセスに接続する可能性があります。 <code>shadow-cljs</code> はデフォルトで、最初に接続した JS ランタイムを <code>eval</code> の対象として選択します。ある <code>:browser</code> ビルドを複数のブラウザで開いた場合、最初のブラウザだけが <code>eval</code> コードに使用されます。また、開発中に iOS と Android で隣り合わせに <code>:react-native</code> アプリを開くこともできます。評価できるのは 1 つのランタイムだけで、そのランタイムが切断されると、接続された時間に基づいて次のランタイムが引き継ぐことになります。</p>
</div>
</div>
<div class="sect3">
<h4 id="missing-js-runtime"><a class="anchor" href="#missing-js-runtime"></a><a class="link" href="#missing-js-runtime">15.2.3. JS ランタイムの欠落</a></h4>
<div class="paragraph">
<p>Missing JS runtime <a id="missing-js-runtime"></a></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>どのアプリケーションも REPL サーバに接続していません。JS環境がコンパイルした ClojureScript コードを読み込んでいることを確認してください。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>このエラーメッセージは、JS ランタイム (例: ブラウザ) が <code>shadow-cljs</code> サーバに接続していないことを意味します。 REPL クライアントは正常に <code>shadow-cljs</code> サーバに接続しましたが、上で説明したように、実際に <code>eval</code> するためにはまだ JS ランタイムが必要です。</p>
</div>
<div class="paragraph">
<p>通常の <code>shadow-cljs</code> ビルドは JS ランタイムを管理していないので、実行する責任があります。</p>
</div>
<div class="sect4">
<h5 id="repl-trouble-browser"><a class="anchor" href="#repl-trouble-browser"></a><a class="link" href="#repl-trouble-browser">:target :browser</a></h5>
<div class="paragraph">
<p><a href="#target-browser"><code>:target :browser</code></a> ビルドの場合、 <code>watch</code> プロセスは、設定された <code>:output-dir</code> (デフォルトは <code>public/js</code>) に与えられたコードをコンパイルします。生成された <code>.js</code> は、ブラウザで読み込む必要があります。ロードされると、ブラウザコンソールには <code>WebSocket connected</code> というメッセージが表示されます。何らかのカスタム HTTP サーバを使用している場合や、過剰なファイアウォールが接続をブロックしている場合は、いくつかの追加設定を行う必要があるかもしれません（例：<a href="#proxy-support">:devtools-url</a>経由）。目標は、<a href="#http">primary HTTP server</a>に接続できるようにすることです。</p>
</div>
</div>
<div class="sect4">
<h5 id="repl-trouble-node"><a class="anchor" href="#repl-trouble-node"></a><a class="link" href="#repl-trouble-node">:target :node-script, :node-library</a></h5>
<div class="paragraph">
<p>これらのターゲットは、 <code>.js</code> ファイルを作成し、 <code>node</code> プロセスで実行することを意図しています。しかし、様々なオプションがあるため、それらを自分で実行する必要があります。例えば、<code>:node-script</code> を <code>node the-script.js</code> 経由で実行すると、起動時に <code>shadow-cljs</code> サーバへの接続を試みます。起動時には <code>WebSocket connected</code> というメッセージが表示されるはずです。出力はコンパイルされたマシン上でのみ動作するように設計されていますので、 <code>watch</code> の出力を他のマシンにコピーしないでください。</p>
</div>
</div>
<div class="sect4">
<h5 id="repl-trouble-react-native"><a class="anchor" href="#repl-trouble-react-native"></a><a class="link" href="#repl-trouble-react-native">:target :react-native</a></h5>
<div class="paragraph">
<p>生成された <code>&lt;:output-dir&gt;/index.js</code> ファイルを <code>react-native</code> アプリに追加し、実際のデバイスやエミュレータで読み込む必要があります。また、起動時には <code>shadow-cljs</code> サーバへの接続を試みます。ログの出力は <code>react-native log-android|log-ios</code> で確認することができ、アプリが実行されると <code>WebSocket connected</code> というメッセージが表示されるはずです。もし起動時に WebSocket 関連のエラーが表示される場合は、代わりに shadow-cljs プロセスへの接続に失敗した可能性があります。これは、IP 検出が誤った IP を選択した場合に発生する可能性があります。どの IP が使用されたかは <code>shadow-cljs watch app --verbose</code> で確認できますし、 <code>shadow-cljs watch app --config-merge '{:local-ip "1.2.3.4"}'</code> で上書きすることもできます。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="publish"><a class="anchor" href="#publish"></a><a class="link" href="#publish">16. ライブラリの publish</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>ClojureScript のライブラリは、Clojure と同様に <code>maven</code> リポジトリに公開されます。最も一般的には <a href="https://clojars.org/">Clojars</a> に公開されますが、他のすべての標準的な maven リポジトリでも動作します。</p>
</div>
<div class="paragraph">
<p>しかし、ClojureScript ライブラリは、JAR(基本的には単なる ZIP 圧縮ファイル)で公開されたアンコンパイルされたソースファイルであるため、maven に公開できる一般的なツールであれば動作します。(例: <code>mvn</code>, <code>gradle</code>, <code>lein</code>, など). 公開するために余分なコンパイルやその他のステップは必要ありません。ClojureScript コンパイラや、そのための shadow-cljs は全く関係ありません。</p>
</div>
<div class="sect2">
<h3 id="publish-lein"><a class="anchor" href="#publish-lein"></a><a class="link" href="#publish-lein">16.1. Leiningen</a></h3>
<div class="paragraph">
<p>ライブラリを公開するには様々なオプションがありますが、現在は <a href="https://leiningen.org/">Leiningen</a> をお勧めしています。セットアップは非常に簡単で、設定は全く必要ありません。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
これは、ライブラリ自体の開発時に Leiningen を使用しなければならないということではありません。公開時には Leiningen を使用し、それ以外は通常通り <code>shadow-cljs</code> を使用することが推奨されています。実際の <code>:dependencies</code> の定義をコピーする必要があるのは、公開した後だけです。しかし、開発に関連する依存関係を排除することを忘れないでください。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>すでに、すべての主要なソースが <code>src/main</code> に配置されている推奨のプロジェクト構造を使用している場合、非常にシンプルな <code>project.clj</code> で公開することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(defproject your.cool/library "1.0.0"
  :description "Does cool stuff"
  :url "https://the.inter.net/wherever"

  ;; これはオプションで、必要なものを追加したり、削除したりすることができます。
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}

  :dependencies
  ;; Clojure では常に provided を使用します。(Script)
  [[org.clojure/clojurescript "1.10.520" :scope "provided"]
   [some.other/library "1.0.0"]

  :source-paths
  ["src/main"])</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより、必要な <code>pom.xml</code> が生成され、 <code>src/main</code> からのすべてのソースが、公開された <code>.jar</code> ファイルに格納されます。あとは <code>lein deploy clojars</code> を実行するだけで公開されます。この作業を初めて行う場合は、まず適切な認証を設定する必要があります。その設定方法については、公式の <a href="https://github.com/technomancy/leiningen/blob/stable/doc/DEPLOY.md">Leiningen</a> および <a href="https://github.com/clojars/clojars-web/wiki/Tutorial">Clojars</a> のドキュメントを参照してください。</p>
</div>
<div class="sect3">
<h4 id="_jar_署名の無効化"><a class="anchor" href="#_jar_署名の無効化"></a><a class="link" href="#_jar_署名の無効化">16.1.1. JAR 署名の無効化</a></h4>
<div class="paragraph">
<p>Leiningen はライブラリを公開する前に GPG で署名することをデフォルトとしています。これは良いデフォルトですが、設定が面倒であったり、実際に署名を検証する人があまりいないことを考えると、 <code>project.clj</code> にシンプルな <code>:repositories</code> 設定を追加することで、このステップを無効にすることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(defproject your.cool/library "1.0.0"
  ...
  :repositories
  {"clojars" {:url "https://clojars.org/repo"
              :sign-releases false}}
  ...)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jar_をクリーンに保つ"><a class="anchor" href="#_jar_をクリーンに保つ"></a><a class="link" href="#_jar_をクリーンに保つ">16.1.2. JAR をクリーンに保つ</a></h4>
<div class="paragraph">
<p>ライブラリのテストやその他の開発関連のコードを書く場合は、ライブラリと一緒に公開しないように、必ず <code>src/dev</code> や <code>src/test</code> に置いてください。</p>
</div>
<div class="paragraph">
<p>また、 <code>resources/*</code> に出力することも避けてください。Leiningen や他のツールが <code>.jar</code> にそれらのファイルを含める可能性があり、下流のユーザーに問題を引き起こす可能性があります。 <code>.jar</code> には実際のソースファイルのみを入れ、コンパイルされたコードは一切入れないようにしてください。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
lein jar を実行し、 <code>jar -tvf target/library-1.0.0.jar</code> で最終的に含まれるファイルを検査することで、すべてがクリーンであることを確認できますし、そうすべきです。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="publish-deps-cljs"><a class="anchor" href="#publish-deps-cljs"></a><a class="link" href="#publish-deps-cljs">16.2. JS の依存関係を宣言する</a></h3>
<div class="paragraph">
<p>現在、 <code>shadow-cljs</code> のみが <code>npm</code> とのクリーンな自動インターロップストーリーを持っていることに注意してください。これは、他のツールを使用しているあなたのライブラリのユーザーにとって問題となるかもしれません。CLJSJS のフォールバックを提供したり、 <code>webpack</code> 関連のワークフローのための特別なドキュメントを公開したりすることを検討するとよいでしょう。</p>
</div>
<div class="paragraph">
<p>プロジェクト（例：<code>src/main/deps.cljs</code>）の中に、<code>:npm-deps</code> 付きの <code>deps.cljs</code> を含めることで、 <code>npm</code> の依存関係を直接宣言することができます。</p>
</div>
<div class="listingblock">
<div class="title">Example src/main/deps.cljs</div>
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">{:npm-deps {"the-thing" "1.0.0"}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここでは、追加の <code>:foreign-libs</code> 定義を提供することもできます。これらは <code>shadow-cljs</code> には影響しませんが、他のツールには役立つかもしれません。</p>
</div>
<div class="paragraph">
<p>詳しくは <a href="https://clojurescript.org/reference/packaging-foreign-deps" class="bare">https://clojurescript.org/reference/packaging-foreign-deps</a> をご覧ください。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_上手くいかない場合はどうすればいいか"><a class="anchor" href="#_上手くいかない場合はどうすればいいか"></a><a class="link" href="#_上手くいかない場合はどうすればいいか">17. 上手くいかない場合はどうすればいいか</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>JS の世界は今でも急速に進化しており、誰もが同じ方法でコードを書いたり配布したりしているわけではないので、<code>shadow-cljs</code> が自動的に回避できないものもあります。これらは通常、カスタムの <code>:resolve</code> 設定で解決できますが、バグや見落としもあるかもしれません。</p>
</div>
<div class="paragraph">
<p>この章の説明で解決できない場合は、次のような場所で質問してみてください。
<a href="https://clojurians.slack.com/messages/C6N245JGG"><code>#shadow-cljs</code> Slack チャンネル</a>で聞いてみてください。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hacking"><a class="anchor" href="#_hacking"></a><a class="link" href="#_hacking">18. Hacking</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_ライブラリのパッチ適用"><a class="anchor" href="#_ライブラリのパッチ適用"></a><a class="link" href="#_ライブラリのパッチ適用">18.1. ライブラリのパッチ適用</a></h3>
<div class="paragraph">
<p><code>shadow-cljs</code> コンパイラは、あなたのソースパス上にあるものが最初にコンパイルされるようにし、JAR からのファイルを優先します。つまり、ライブラリからソースファイルをコピーしてパッチを当て、それを自分のソースディレクトリにインクルードすることができるのです。</p>
</div>
<div class="paragraph">
<p>これは、そのプロジェクトをクローンして、そのセットアップやビルドなどを理解しなくても、修正をテストするための便利な方法です(<code>shadow-cljs</code> 自体もテストできます!)。
プロジェクトをクローンして、そのセットアップやビルドなどを理解することなく、修正をテストする便利な方法です。</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0<br>
Last updated 2021-08-06 14:06:00 JST
</div>
</div>
</body>
</html>